#ifndef WINDOW_H
#define WINDOW_H

#include "win32_shared.h"

#include <commctrl.h>
#include <commdlg.h>
#include <richedit.h>
#include <zmouse.h>

namespace iso {

namespace win {
using iso::align;

iso_export bool					ProcessMessage(bool wait);
iso_export uint32				ProcessMessage(const HANDLE *handles, int num, bool all = false, float timeout = 0, uint32 mask = QS_ALLINPUT);
iso_export uint64				GetVersion(const char *path);
iso_export NONCLIENTMETRICSA	GetNonClientMetrics();
iso_export void					SetModelessDialog(HWND hWnd);

template<int N> uint32	ProcessMessage(const HANDLE(&h)[N], bool all = false, float timeout = 0, uint32 mask = QS_ALLINPUT) {
	return ProcessMessage(h, N, all, timeout, mask);
}

template<typename C> using textT = const string_paramT<C>&;
#ifdef UNICODE
typedef const string_param16&	text;
#else
typedef const string_param&		text;
#endif

class Control;

//----------------------------------------------------------------------
//	Message
//----------------------------------------------------------------------

struct wparam {
	WPARAM	v;
	wparam()						: v(0)					{}
	wparam(int64 i)					: v(i)					{}
	wparam(uint16 lo, uint16 hi)	: v(MAKEWPARAM(lo, hi))	{}
	template<typename T> wparam(const T *p)	: v((WPARAM)p)	{}
	template<typename C> wparam(const alloc_string<C> &s)			: v((LPARAM)s.begin())	{}
	template<typename C, int N> wparam(const fixed_string<N, C> &s)	: v((LPARAM)s.begin())	{}

	operator WPARAM() const	{ return v; }
};

struct lparam {
	LPARAM	v;
	lparam()						: v(0)					{}
	lparam(int64 i)					: v(i)					{}
	lparam(uint16 lo, uint16 hi)	: v(MAKELPARAM(lo, hi))	{}
	lparam(const Colour &c)			: v(c.c)				{}

	template<typename T> lparam(const H<T> &h)	: v((LPARAM)(T)h)	{}
	template<typename T> lparam(const T *p)		: v((LPARAM)p)	{}
#ifdef __clang__
	template<typename R, typename...P> lparam(R (*p)(P...))	 : v((LPARAM)(void*)p)	{}
#endif
	explicit lparam(const POINT &p) : v(MAKELPARAM(WORD(p.x), WORD(p.y))) {}
	template<typename C> lparam(const alloc_string<C> &s)			: v((LPARAM)s.begin())	{}
	template<typename C, int N> lparam(const fixed_string<N, C> &s)	: v((LPARAM)s.begin())	{}
	template<typename C> lparam(const string_paramT<C> &s)			: v((LPARAM)s.begin())	{}

	operator LPARAM() const	{ return v; }
};

enum {
	WM_ISO_CHILDRECT	= WM_APP + 0
};

enum MSG_ID {
	kWM_NULL = 0x0000,					kWM_CREATE = 0x0001,				kWM_DESTROY = 0x0002,				kWM_MOVE = 0x0003,					kWM_SIZE = 0x0005,					kWM_ACTIVATE = 0x0006,				kWM_SETFOCUS = 0x0007,				kWM_KILLFOCUS = 0x0008,
	kWM_SETVISIBLE = 0x0009,			kWM_ENABLE = 0x000A,				kWM_SETREDRAW = 0x000B,				kWM_SETTEXT = 0x000C,				kWM_GETTEXT = 0x000D,				kWM_GETTEXTLENGTH = 0x000E,			kWM_PAINT = 0x000F,					kWM_CLOSE = 0x0010,
	kWM_QUERYENDSESSION = 0x0011,		kWM_QUIT = 0x0012,					kWM_QUERYOPEN = 0x0013,				kWM_ERASEBKGND = 0x0014,			kWM_SYSCOLORCHANGE = 0x0015,		kWM_ENDSESSION = 0x0016,			kWM_SYSTEMERROR = 0x0017,			kWM_SHOWWINDOW = 0x0018,
	kWM_CTLCOLOR = 0x0019,				kWM_SETTINGCHANGE = 0x001A,			kWM_DEVMODECHANGE = 0x001B,			kWM_ACTIVATEAPP = 0x001C,			kWM_FONTCHANGE = 0x001D,			kWM_TIMECHANGE = 0x001E,			kWM_CANCELMODE = 0x001F,			kWM_SETCURSOR = 0x0020,
	kWM_MOUSEACTIVATE = 0x0021,			kWM_CHILDACTIVATE = 0x0022,			kWM_QUEUESYNC = 0x0023,				kWM_GETMINMAXINFO = 0x0024,			kWM_LOGOFF = 0x0025,				kWM_PAINTICON = 0x0026,				kWM_ICONERASEBKGND = 0x0027,		kWM_NEXTDLGCTL = 0x0028,
	kWM_ALTTABACTIVE = 0x0029,			kWM_SPOOLERSTATUS = 0x002A,			kWM_DRAWITEM = 0x002B,				kWM_MEASUREITEM = 0x002C,			kWM_DELETEITEM = 0x002D,			kWM_VKEYTOITEM = 0x002E,			kWM_CHARTOITEM = 0x002F,			kWM_SETFONT = 0x0030,
	kWM_GETFONT = 0x0031,				kWM_SETHOTKEY = 0x0032,				kWM_GETHOTKEY = 0x0033,				kWM_FILESYSCHANGE = 0x0034,			kWM_ISACTIVEICON = 0x0035,			kWM_UNUSED0036 = 0x0036,			kWM_QUERYDRAGICON = 0x0037,			kWM_WINHELP = 0x0038,
	kWM_COMPAREITEM = 0x0039,			kWM_FULLSCREEN = 0x003A,			kWM_CLIENTSHUTDOWN = 0x003B,		kWM_DDEMLEVENT = 0x003C,			kWM_TESTING = 0x0040,				kWM_COMPACTING = 0x0041,			kWM_OTHERWINDOWCREATED = 0x0042,	kWM_OTHERWINDOWDESTROYED = 0x0043,
	kWM_COMMNOTIFY = 0x0044,			kWM_MEDIASTATUSCHANGE = 0x0045,		kWM_WINDOWPOSCHANGING = 0x0046,		kWM_WINDOWPOSCHANGED = 0x0047,		kWM_POWER = 0x0048,					kWM_COPYGLOBALDATA = 0x0049,		kWM_COPYDATA = 0x004A,				kWM_CANCELJOURNAL = 0x004B,
	kWM_LOGONNOTIFY = 0x004C,			kWM_KEYF1 = 0x004D,					kWM_NOTIFY = 0x004E,				kWM_ACCESS_WINDOW = 0x004F,			kWM_INPUTLANGCHANGEREQUEST = 0x0050,kWM_INPUTLANGCHANGE = 0x0051,		kWM_TCARD = 0x0052,					kWM_HELP = 0x0053,
	kWM_USERCHANGED = 0x0054,			kWM_NOTIFYFORMAT = 0x0055,			kWM_FINALDESTROY = 0x0070,			kWM_MEASUREITEM_CLIENTDATA = 0x0071,kWM_CONTEXTMENU = 0x007B,			kWM_STYLECHANGING = 0x007C,			kWM_STYLECHANGED = 0x007D,			kWM_DISPLAYCHANGE = 0x007E,
	kWM_GETICON = 0x007F,				kWM_SETICON = 0x0080,				kWM_NCCREATE = 0x0081,				kWM_NCDESTROY = 0x0082,				kWM_NCCALCSIZE = 0x0083,			kWM_NCHITTEST = 0x0084,				kWM_NCPAINT = 0x0085,				kWM_NCACTIVATE = 0x0086,
	kWM_GETDLGCODE = 0x0087,			kWM_SYNCPAINT = 0x0088,				kWM_SYNCTASK = 0x0089,				kWM_MYSTERY = 0x008B,				kWM_NCMOUSEMOVE = 0x00A0,			kWM_NCLBUTTONDOWN = 0x00A1,			kWM_NCLBUTTONUP = 0x00A2,			kWM_NCLBUTTONDBLCLK = 0x00A3,
	kWM_NCRBUTTONDOWN = 0x00A4,			kWM_NCRBUTTONUP = 0x00A5,			kWM_NCRBUTTONDBLCLK = 0x00A6,		kWM_NCMBUTTONDOWN = 0x00A7,			kWM_NCMBUTTONUP = 0x00A8,			kWM_NCMBUTTONDBLCLK = 0x00A9,		kWM_NCXBUTTONDOWN = 0x00AB,			kWM_NCXBUTTONUP = 0x00AC,
	kWM_NCXBUTTONDBLCLK = 0x00AD,		kWM_INPUT = 0x00FF,					kWM_KEYDOWN = 0x0100,				kWM_KEYUP = 0x0101,					kWM_CHAR = 0x0102,					kWM_DEADCHAR = 0x0103,				kWM_SYSKEYDOWN = 0x0104,			kWM_SYSKEYUP = 0x0105,
	kWM_SYSCHAR = 0x0106,				kWM_SYSDEADCHAR = 0x0107,			kWM_YOMICHAR = 0x0108,				kWM_CONVERTREQUEST = 0x010A,		kWM_CONVERTRESULT = 0x010B,			kWM_INTERIM = 0x010C,				kWM_IME_STARTCOMPOSITION = 0x010D,	kWM_IME_ENDCOMPOSITION = 0x010E,
	kWM_IME_COMPOSITION = 0x010F,		kWM_INITDIALOG = 0x0110,			kWM_COMMAND = 0x0111,				kWM_SYSCOMMAND = 0x0112,			kWM_TIMER = 0x0113,					kWM_HSCROLL = 0x0114,				kWM_VSCROLL = 0x0115,				kWM_INITMENU = 0x0116,
	kWM_INITMENUPOPUP = 0x0117,			kWM_SYSTIMER = 0x0118,				kWM_MENUSELECT = 0x011F,			kWM_MENUCHAR = 0x0120,				kWM_ENTERIDLE = 0x0121,				kWM_MENURBUTTONUP = 0x0122,			kWM_MENUDRAG = 0x0123,				kWM_MENUGETOBJECT = 0x0124,
	kWM_UNINITMENUPOPUP = 0x0125,		kWM_MENUCOMMAND = 0x0126,			kWM_CHANGEUISTATE = 0x0127,			kWM_UPDATEUISTATE = 0x0128,			kWM_QUERYUISTATE = 0x0129,			kWM_CTLCOLORMSGBOX = 0x0132,		kWM_CTLCOLOREDIT = 0x0133,			kWM_CTLCOLORLISTBOX = 0x0134,
	kWM_CTLCOLORBTN = 0x0135,			kWM_CTLCOLORDLG = 0x0136,			kWM_CTLCOLORSCROLLBAR = 0x0137,		kWM_CTLCOLORSTATIC = 0x0138,		

	kWM_MOUSEMOVE = 0x0200,				kWM_LBUTTONDOWN = 0x0201,			kWM_LBUTTONUP = 0x0202,				kWM_LBUTTONDBLCLK = 0x0203,			kWM_RBUTTONDOWN = 0x0204,			kWM_RBUTTONUP = 0x0205,				kWM_RBUTTONDBLCLK = 0x0206,			kWM_MBUTTONDOWN = 0x0207,
	kWM_MBUTTONUP = 0x0208,				kWM_MBUTTONDBLCLK = 0x0209,			kWM_MOUSEWHEEL = 0x020A,			kWM_XBUTTONDOWN = 0x020B,			kWM_XBUTTONUP = 0x020C,				kWM_XBUTTONDBLCLK = 0x020D,			kWM_PARENTNOTIFY = 0x0210,			kWM_ENTERMENULOOP = 0x0211,
	kWM_EXITMENULOOP = 0x0212,			kWM_NEXTMENU = 0x0213,				kWM_SIZING = 0x0214,				kWM_CAPTURECHANGED = 0x0215,		kWM_MOVING = 0x0216,				kWM_POWERBROADCAST = 0x0218,		kWM_DEVICECHANGE = 0x0219,			kWM_MDICREATE = 0x0220,
	kWM_MDIDESTROY = 0x0221,			kWM_MDIACTIVATE = 0x0222,			kWM_MDIRESTORE = 0x0223,			kWM_MDINEXT = 0x0224,				kWM_MDIMAXIMIZE = 0x0225,			kWM_MDITILE = 0x0226,				kWM_MDICASCADE = 0x0227,			kWM_MDIICONARRANGE = 0x0228,
	kWM_MDIGETACTIVE = 0x0229,			kWM_DROPOBJECT = 0x022A,			kWM_QUERYDROPOBJECT = 0x022B,		kWM_BEGINDRAG = 0x022C,				kWM_DRAGLOOP = 0x022D,				kWM_DRAGSELECT = 0x022E,			kWM_DRAGMOVE = 0x022F,				kWM_MDISETMENU = 0x0230,
	kWM_ENTERSIZEMOVE = 0x0231,			kWM_EXITSIZEMOVE = 0x0232,			kWM_DROPFILES = 0x0233,				kWM_MDIREFRESHMENU = 0x0234,		kWM_IME_SETCONTEXT = 0x0281,		kWM_IME_NOTIFY = 0x0282,			kWM_IME_CONTROL = 0x0283,			kWM_IME_COMPOSITIONFULL = 0x0284,
	kWM_IME_SELECT = 0x0285,			kWM_IME_CHAR = 0x0286,				kWM_IME_REQUEST = 0x0288,			kWM_IME_KEYDOWN = 0x0290,			kWM_IME_KEYUP = 0x0291,				kWM_NCMOUSEHOVER = 0x02A0,			kWM_MOUSEHOVER = 0x02A1,			kWM_NCMOUSELEAVE = 0x02A2,
	kWM_MOUSELEAVE = 0x02A3,			

	kWM_CUT = 0x0300,					kWM_COPY = 0x0301,					kWM_PASTE = 0x0302,					kWM_CLEAR = 0x0303,					kWM_UNDO = 0x0304,					kWM_RENDERFORMAT = 0x0305,			kWM_RENDERALLFORMATS = 0x0306,		kWM_DESTROYCLIPBOARD = 0x0307,
	kWM_DRAWCLIPBOARD = 0x0308,			kWM_PAINTCLIPBOARD = 0x0309,		kWM_VSCROLLCLIPBOARD = 0x030A,		kWM_SIZECLIPBOARD = 0x030B,			kWM_ASKCBFORMATNAME = 0x030C,		kWM_CHANGECBCHAIN = 0x030D,			kWM_HSCROLLCLIPBOARD = 0x030E,		kWM_QUERYNEWPALETTE = 0x030F,
	kWM_PALETTEISCHANGING = 0x0310,		kWM_PALETTECHANGED = 0x0311,		kWM_HOTKEY = 0x0312,				kWM_SYSMENU = 0x0313,				kWM_HOOKMSG = 0x0314,				kWM_EXITPROCESS = 0x0315,			kWM_WAKETHREAD = 0x0316,			kWM_PRINT = 0x0317,
	kWM_PRINTCLIENT = 0x0318,			kWM_APPCOMMAND = 0x0319,			kWM_PENWINFIRST = 0x0380,			kWM_PENWINLAST = 0x038F,			kWM_DDE_INITIATE = 0x03E0,			kWM_DDE_TERMINATE = 0x03E1,			kWM_DDE_ADVISE = 0x03E2,			kWM_DDE_UNADVISE = 0x03E3,
	kWM_DDE_ACK = 0x03E4,				kWM_DDE_DATA = 0x03E5,				kWM_DDE_REQUEST = 0x03E6,			kWM_DDE_POKE = 0x03E7,				kWM_DDE_EXECUTE = 0x03E8,	           
	kWM_USER = 0x0400,

	//edit control messages
	kEM_GETSEL = 0x00B0,				kEM_SETSEL = 0x00B1,				kEM_GETRECT = 0x00B2,				kEM_SETRECT = 0x00B3,				kEM_SETRECTNP = 0x00B4,				kEM_SCROLL = 0x00B5,				kEM_LINESCROLL = 0x00B6,			kEM_SCROLLCARET = 0x00B7,
	kEM_GETMODIFY = 0x00B8,				kEM_SETMODIFY = 0x00B9,				kEM_GETLINECOUNT = 0x00BA,			kEM_LINEINDEX = 0x00BB,				kEM_SETHANDLE = 0x00BC,				kEM_GETHANDLE = 0x00BD,				kEM_GETTHUMB = 0x00BE,				kEM_LINELENGTH = 0x00C1,
	kEM_REPLACESEL = 0x00C2,			kEM_GETLINE = 0x00C4,				kEM_SETLIMITTEXT = 0x00C5,			kEM_CANUNDO = 0x00C6,				kEM_UNDO = 0x00C7,					kEM_FMTLINES = 0x00C8,				kEM_LINEFROMCHAR = 0x00C9,			kEM_SETTABSTOPS = 0x00CB,
	kEM_SETPASSWORDCHAR = 0x00CC,		kEM_EMPTYUNDOBUFFER = 0x00CD,		kEM_GETFIRSTVISIBLELINE = 0x00CE,	kEM_SETREADONLY = 0x00CF,			kEM_SETWORDBREAKPROC = 0x00D0,		kEM_GETWORDBREAKPROC = 0x00D1,		kEM_GETPASSWORDCHAR = 0x00D2,		kEM_SETMARGINS = 0x00D3,
	kEM_GETMARGINS = 0x00D4,			kEM_GETLIMITTEXT = 0x00D5,			kEM_POSFROMCHAR = 0x00D6,			kEM_CHARFROMPOS = 0x00D7,			kEM_SETIMESTATUS = 0x00D8,			kEM_GETIMESTATUS = 0x00D9,			kEM_CANPASTE = 0x0432,				kEM_DISPLAYBAND = 0x0433,
	kEM_EXGETSEL = 0x0434,				kEM_EXLIMITTEXT = 0x0435,			kEM_EXLINEFROMCHAR = 0x0436,		kEM_EXSETSEL = 0x0437,				kEM_FINDTEXT = 0x0438,				kEM_FORMATRANGE = 0x0439,			kEM_GETCHARFORMAT = 0x043A,			kEM_GETEVENTMASK = 0x043B,
	kEM_GETOLEINTERFACE = 0x043C,		kEM_GETPARAFORMAT = 0x043D,			kEM_GETSELTEXT = 0x043E,			kEM_HIDESELECTION = 0x043F,			kEM_PASTESPECIAL = 0x0440,			kEM_REQUESTRESIZE = 0x0441,			kEM_SELECTIONTYPE = 0x0442,			kEM_SETBKGNDCOLOR = 0x0443,
	kEM_SETCHARFORMAT = 0x0444,			kEM_SETEVENTMASK = 0x0445,			kEM_SETOLECALLBACK = 0x0446,		kEM_SETPARAFORMAT = 0x0447,			kEM_SETTARGETDEVICE = 0x0448,		kEM_STREAMIN = 0x0449,				kEM_STREAMOUT = 0x044A,				kEM_GETTEXTRANGE = 0x044B,
	kEM_FINDWORDBREAK = 0x044C,			kEM_SETOPTIONS = 0x044D,			kEM_GETOPTIONS = 0x044E,			kEM_FINDTEXTEX = 0x044F,			kEM_GETWORDBREAKPROCEX = 0x0450,	kEM_SETWORDBREAKPROCEX = 0x0451,	kEM_SETUNDOLIMIT = 0x0452,			kEM_REDO = 0x0454,
	kEM_CANREDO = 0x0455,				kEM_GETUNDONAME = 0x0456,			kEM_GETREDONAME = 0x0457,			kEM_STOPGROUPTYPING = 0x0458,		kEM_SETTEXTMODE = 0x0459,			kEM_GETTEXTMODE = 0x045A,			kEM_AUTOURLDETECT = 0x045B,			kEM_GETAUTOURLDETECT = 0x045C,
	kEM_SETPALETTE = 0x045D,			kEM_GETTEXTEX = 0x045E,				kEM_GETTEXTLENGTHEX = 0x045F,		kEM_SHOWSCROLLBAR = 0x0460,			kEM_SETTEXTEX = 0x0461,				kEM_SETPUNCTUATION = 0x0464,		kEM_GETPUNCTUATION = 0x0465,		kEM_SETWORDWRAPMODE = 0x0466,
	kEM_GETWORDWRAPMODE = 0x0467,		kEM_SETIMECOLOR = 0x0468,			kEM_GETIMECOLOR = 0x0469,			kEM_SETIMEOPTIONS = 0x046A,			kEM_GETIMEOPTIONS = 0x046B,			kEM_SETLANGOPTIONS = 0x0478,		kEM_GETLANGOPTIONS = 0x0479,		kEM_GETIMECOMPMODE = 0x047A,
	kEM_FINDTEXTW = 0x047B,				kEM_FINDTEXTEXW = 0x047C,			kEM_RECONVERSION = 0x047D,			kEM_SETBIDIOPTIONS = 0x04C8,		kEM_GETBIDIOPTIONS = 0x04C9,		kEM_SETTYPOGRAPHYOPTIONS = 0x04CA,	kEM_GETTYPOGRAPHYOPTIONS = 0x04CB,	kEM_SETEDITSTYLE = 0x04CC,
	kEM_GETEDITSTYLE = 0x04CD,			kEM_GETSCROLLPOS = 0x04DD,			kEM_SETSCROLLPOS = 0x04DE,			kEM_SETFONTSIZE = 0x04DF,			kEM_GETZOOM = 0x04E0,				kEM_SETZOOM = 0x04E1,				

	//icon control
	kSBM_SETPOS = 0x00E0,				kSBM_GETPOS = 0x00E1,				kSBM_SETRANGE = 0x00E2,				kSBM_GETRANGE = 0x00E3,				kSBM_ENABLE_ARROWS = 0x00E4,		kSBM_SETRANGEREDRAW = 0x00E6,		kSBM_SETSCROLLINFO = 0x00E9,		kSBM_GETSCROLLINFO = 0x00EA,
	kSTM_SETICON = 0x0170,				kSTM_GETICON = 0x0171,				kSTM_SETIMAGE = 0x0172,				kSTM_GETIMAGE = 0x0173,				

	//button
	kBM_GETCHECK = 0x00F0,				kBM_SETCHECK = 0x00F1,				kBM_GETSTATE = 0x00F2,				kBM_SETSTATE = 0x00F3,				kBM_SETSTYLE = 0x00F4,				kBM_CLICK = 0x00F5,					kBM_GETIMAGE = 0x00F6,				kBM_SETIMAGE = 0x00F7,

	//combo control
	kCB_GETEDITSEL = 0x0140,			kCB_LIMITTEXT = 0x0141,				kCB_SETEDITSEL = 0x0142,			kCB_ADDSTRING = 0x0143,				kCB_DELETESTRING = 0x0144,			kCB_DIR = 0x0145,					kCB_GETCOUNT = 0x0146,				kCB_GETCURSEL = 0x0147,
	kCB_GETLBTEXT = 0x0148,				kCB_GETLBTEXTLEN = 0x0149,			kCB_INSERTSTRING = 0x014A,			kCB_RESETCONTENT = 0x014B,			kCB_FINDSTRING = 0x014C,			kCB_SELECTSTRING = 0x014D,			kCB_SETCURSEL = 0x014E,				kCB_SHOWDROPDOWN = 0x014F,
	kCB_GETITEMDATA = 0x0150,			kCB_SETITEMDATA = 0x0151,			kCB_GETDROPPEDCONTROLRECT = 0x0152,	kCB_SETITEMHEIGHT = 0x0153,			kCB_GETITEMHEIGHT = 0x0154,			kCB_SETEXTENDEDUI = 0x0155,			kCB_GETEXTENDEDUI = 0x0156,			kCB_GETDROPPEDSTATE = 0x0157,
	kCB_FINDSTRINGEXACT = 0x0158,		kCB_SETLOCALE = 0x0159,				kCB_GETLOCALE = 0x015A,				kCB_GETTOPINDEX = 0x015B,			kCB_SETTOPINDEX = 0x015C,			kCB_GETHORIZONTALEXTENT = 0x015D,	kCB_SETHORIZONTALEXTENT = 0x015E,	kCB_GETDROPPEDWIDTH = 0x015F,
	kCB_SETDROPPEDWIDTH = 0x0160,		kCB_INITSTORAGE = 0x0161,				

	//listbox
	kLB_ADDSTRING = 0x0180,				kLB_INSERTSTRING = 0x0181,			kLB_DELETESTRING = 0x0182,			kLB_SELITEMRANGEEX = 0x0183,		kLB_RESETCONTENT = 0x0184,			kLB_SETSEL = 0x0185,				kLB_SETCURSEL = 0x0186,				kLB_GETSEL = 0x0187,
	kLB_GETCURSEL = 0x0188,				kLB_GETTEXT = 0x0189,				kLB_GETTEXTLEN = 0x018A,			kLB_GETCOUNT = 0x018B,				kLB_SELECTSTRING = 0x018C,			kLB_DIR = 0x018D,					kLB_GETTOPINDEX = 0x018E,			kLB_FINDSTRING = 0x018F,
	kLB_GETSELCOUNT = 0x0190,			kLB_GETSELITEMS = 0x0191,			kLB_SETTABSTOPS = 0x0192,			kLB_GETHORIZONTALEXTENT = 0x0193,	kLB_SETHORIZONTALEXTENT = 0x0194,	kLB_SETCOLUMNWIDTH = 0x0195,		kLB_ADDFILE = 0x0196,				kLB_SETTOPINDEX = 0x0197,
	kLB_GETITEMRECT = 0x0198,			kLB_GETITEMDATA = 0x0199,			kLB_SETITEMDATA = 0x019A,			kLB_SELITEMRANGE = 0x019B,			kLB_SETANCHORINDEX = 0x019C,		kLB_GETANCHORINDEX = 0x019D,		kLB_SETCARETINDEX = 0x019E,			kLB_GETCARETINDEX = 0x019F,
	kLB_SETITEMHEIGHT = 0x01A0,			kLB_GETITEMHEIGHT = 0x01A1,			kLB_FINDSTRINGEXACT = 0x01A2,		kLB_SETLOCALE = 0x01A5,				kLB_GETLOCALE = 0x01A6,				kLB_SETCOUNT = 0x01A7,				kLB_INITSTORAGE = 0x01A8,			kLB_ITEMFROMPOINT = 0x01A9,
	kLB_INSERTSTRINGUPPER = 0x01AA,		kLB_INSERTSTRINGLOWER = 0x01AB,		kLB_ADDSTRINGUPPER = 0x01AC,		kLB_ADDSTRINGLOWER = 0x01AD,		

	//combo and listbox
	kLBCB_CARETON = 0x01A3,				kLBCB_CARETOFF = 0x01A4,			

	//context menu
	kMN_SETHMENU = 0x01E0,				kMN_GETHMENU = 0x01E1,				kMN_SIZEWINDOW = 0x01E2,			kMN_OPENHIERARCHY = 0x01E3,			kMN_CLOSEHIERARCHY = 0x01E4,		kMN_SELECTITEM = 0x01E5,			kMN_CANCELMENUS = 0x01E6,			kMN_SELECTFIRSTVALIDITEM = 0x01E7,
	kMN_GETPPOPUPMENU = 0x01EA,			kMN_FINDMENUWINDOWFROMPOINT = 0x01EB,kMN_SHOWPOPUPWINDOW = 0x01EC,		kMN_BUTTONDOWN = 0x01ED,			kMN_MOUSEMOVE = 0x01EE,				kMN_BUTTONUP = 0x01EF,				kMN_SETTIMERTOOPENHIERARCHY = 0x01F0,kMN_DBLCLK = 0x01F1,

	//combo and edit
	kCBEM_INSERTITEMA = 0x0401,			kCBEM_SETIMAGELIST = 0x0402,		kCBEM_GETIMAGELIST = 0x0403,		kCBEM_GETITEMA = 0x0404,			kCBEM_SETITEMA = 0x0405,			kCBEM_GETCOMBOCONTROL = 0x0406,		kCBEM_GETEDITCONTROL = 0x0407,		kCBEM_SETEXSTYLE = 0x0408,
	kCBEM_GETEXSTYLE = 0x0409,			kCBEM_GETEXTENDEDSTYLE = 0x0409,	kCBEM_HASEDITCHANGED = 0x040A,		kCBEM_INSERTITEMW = 0x040B,			kCBEM_SETITEMW = 0x040C,			kCBEM_GETITEMW = 0x040D,			kCBEM_SETEXTENDEDSTYLE = 0x040E,	

	//dialog
	kDM_GETDEFID = 0x0400,				kDM_SETDEFID = 0x0401,				kDM_REPOSITION = 0x0402,			

	//rebar control
	kRB_INSERTBAND = 0x0401,			kRB_INSERTBANDA = 0x0401,			kRB_DELETEBAND = 0x0402,			kRB_GETBARINFO = 0x0403,			kRB_SETBARINFO = 0x0404,			kRB_GETBANDINFO = 0x0405,			kRB_SETBANDINFO = 0x0406,			kRB_SETBANDINFOA = 0x0406,
	kRB_SETPARENT = 0x0407,				kRB_HITTEST = 0x0408,				kRB_GETRECT = 0x0409,				kRB_INSERTBANDW = 0x040A,			kRB_SETBANDINFOW = 0x040B,			kRB_GETBANDCOUNT = 0x040C,			kRB_GETROWCOUNT = 0x040D,			kRB_GETROWHEIGHT = 0x040E,
	kRB_IDTOINDEX = 0x0410,				kRB_GETTOOLTIPS = 0x0411,			kRB_SETTOOLTIPS = 0x0412,			kRB_SETBKCOLOR = 0x0413,			kRB_GETBKCOLOR = 0x0414,			kRB_SETTEXTCOLOR = 0x0415,			kRB_GETTEXTCOLOR = 0x0416,			kRB_SIZETORECT = 0x0417,
	kRB_BEGINDRAG = 0x0418,				kRB_ENDDRAG = 0x0419,				kRB_DRAGMOVE = 0x041A,				kRB_GETBARHEIGHT = 0x041B,			kRB_GETBANDINFOW = 0x041C,			kRB_GETBANDINFOA = 0x041D,			kRB_MINIMIZEBAND = 0x041E,			kRB_MAXIMIZEBAND = 0x041F,
	kRB_GETBANDBORDERS = 0x0422,		kRB_SHOWBAND = 0x0423,				kRB_SETPALETTE = 0x0425,			kRB_GETPALETTE = 0x0426,			kRB_MOVEBAND = 0x0427,				kRB_PUSHCHEVRON = 0x042B,

	//toolbar control
	kTB_ENABLEBUTTON = 0x0401,			kTB_CHECKBUTTON = 0x0402,			kTB_PRESSBUTTON = 0x0403,			kTB_HIDEBUTTON = 0x0404,			kTB_INDETERMINATE = 0x0405,			kTB_MARKBUTTON = 0x0406,			kTB_ISBUTTONENABLED = 0x0409,		kTB_ISBUTTONCHECKED = 0x040A,
	kTB_ISBUTTONPRESSED = 0x040B,		kTB_ISBUTTONHIDDEN = 0x040C,		kTB_ISBUTTONINDETERMINATE = 0x040D,	kTB_ISBUTTONHIGHLIGHTED = 0x040E,	kTB_SETSTATE = 0x0411,				kTB_GETSTATE = 0x0412,				kTB_ADDBITMAP = 0x0413,				kTB_ADDBUTTONS = 0x0414,
	kTB_INSERTBUTTON = 0x0415,			kTB_DELETEBUTTON = 0x0416,			kTB_GETBUTTON = 0x0417,				kTB_BUTTONCOUNT = 0x0418,			kTB_COMMANDTOINDEX = 0x0419,		kTB_SAVERESTORE = 0x041A,			kTB_CUSTOMIZE = 0x041B,				kTB_ADDSTRING = 0x041C,
	kTB_GETITEMRECT = 0x041D,			kTB_BUTTONSTRUCTSIZE = 0x041E,		kTB_SETBUTTONSIZE = 0x041F,			kTB_SETBITMAPSIZE = 0x0420,			kTB_AUTOSIZE = 0x0421,				kTB_GETTOOLTIPS = 0x0423,			kTB_SETTOOLTIPS = 0x0424,			kTB_SETPARENT = 0x0425,
	kTB_SETROWS = 0x0427,				kTB_GETROWS = 0x0428,				kTB_GETBITMAPFLAGS = 0x0429,		kTB_SETCMDID = 0x042A,				kTB_CHANGEBITMAP = 0x042B,			kTB_GETBITMAP = 0x042C,				kTB_GETBUTTONTEXT = 0x042D,			kTB_REPLACEBITMAP = 0x042E,
	kTB_SETINDENT = 0x042F,				kTB_SETIMAGELIST = 0x0430,			kTB_GETIMAGELIST = 0x0431,			kTB_LOADIMAGES = 0x0432,			kTB_GETRECT = 0x0433,				kTB_SETHOTIMAGELIST = 0x0434,		kTB_GETHOTIMAGELIST = 0x0435,		kTB_SETDISABLEDIMAGELIST = 0x0436,
	kTB_GETDISABLEDIMAGELIST = 0x0437,	kTB_SETSTYLE = 0x0438,				kTB_GETSTYLE = 0x0439,				kTB_GETBUTTONSIZE = 0x043A,			kTB_SETBUTTONWIDTH = 0x043B,		kTB_SETMAXTEXTROWS = 0x043C,		kTB_GETTEXTROWS = 0x043D,			kTB_GETOBJECT = 0x043E,
	kTB_GETBUTTONINFOW = 0x043F,		kTB_SETBUTTONINFOW = 0x0440,		kTB_GETBUTTONINFOA = 0x0441,		kTB_SETBUTTONINFOA = 0x0442,		kTB_HITTEST = 0x0445,				kTB_SETDRAWTEXTFLAGS = 0x0446,		kTB_GETHOTITEM = 0x0447,			kTB_SETHOTITEM = 0x0448,
	kTB_SETANCHORHIGHLIGHT = 0x0449,	kTB_GETANCHORHIGHLIGHT = 0x044A,	kTB_MAPACCELERATORA = 0x044E,		kTB_GETINSERTMARK = 0x044F,			kTB_SETINSERTMARK = 0x0450,			kTB_INSERTMARKHITTEST = 0x0451,		kTB_MOVEBUTTON = 0x0452,			kTB_GETMAXSIZE = 0x0453,
	kTB_SETEXTENDEDSTYLE = 0x0454,		kTB_GETEXTENDEDSTYLE = 0x0455,		kTB_GETPADDING = 0x0456,			kTB_SETPADDING = 0x0457,			kTB_SETINSERTMARKCOLOR = 0x0458,	kTB_GETINSERTMARKCOLOR = 0x0459,	kTB_MAPACCELERATORW = 0x045A,		kTB_GETSTRING = 0x045C,

	//progress bar control
	kPBM_SETRANGE = 0x0401,				kPBM_SETPOS = 0x0402,				kPBM_DELTAPOS = 0x0403,				kPBM_SETSTEP = 0x0404,				kPBM_STEPIT = 0x0405,				kPBM_SETRANGE32 = 0x0406,			kPBM_GETRANGE = 0x0407,				kPBM_GETPOS = 0x0408,
	kPBM_SETBARCOLOR = 0x0409,

	//trackbar control
	kTBM_GETPOS = 0x0400,				kTBM_GETRANGEMIN = 0x0401,			kTBM_GETRANGEMAX = 0x0402,			kTBM_GETTIC = 0x0403,				kTBM_SETTIC = 0x0404,				kTBM_SETPOS = 0x0405,				kTBM_SETRANGE = 0x0406,				kTBM_SETRANGEMIN = 0x0407,
	kTBM_SETRANGEMAX = 0x0408,			kTBM_CLEARTICS = 0x0409,			kTBM_SETSEL = 0x040A,				kTBM_SETSELSTART = 0x040B,			kTBM_SETSELEND = 0x040C,			kTBM_GETPTICS = 0x040E,				kTBM_GETTICPOS = 0x040F,			kTBM_GETNUMTICS = 0x0410,
	kTBM_GETSELSTART = 0x0411,			kTBM_GETSELEND = 0x0412,			kTBM_CLEARSEL = 0x0413,				kTBM_SETTICFREQ = 0x0414,			kTBM_SETPAGESIZE = 0x0415,			kTBM_GETPAGESIZE = 0x0416,			kTBM_SETLINESIZE = 0x0417,			kTBM_GETLINESIZE = 0x0418,
	kTBM_GETTHUMBRECT = 0x0419,			kTBM_GETCHANNELRECT = 0x041A,		kTBM_SETTHUMBLENGTH = 0x041B,		kTBM_GETTHUMBLENGTH = 0x041C,		kTBM_SETTOOLTIPS = 0x041D,			kTBM_GETTOOLTIPS = 0x041E,			kTBM_SETTIPSIDE = 0x041F,			kTBM_SETBUDDY = 0x0420,
	kTBM_GETBUDDY = 0x0421,

	// tooltip control
	kTTM_ACTIVATE = 0x0401,				kTTM_SETDELAYTIME = 0x0403,			kTTM_ADDTOOLA = 0x0404,				kTTM_DELTOOLA = 0x0405,				kTTM_NEWTOOLRECTA = 0x0406,			kTTM_RELAYEVENT = 0x0407,			kTTM_GETTOOLINFOA = 0x0408,			kTTM_SETTOOLINFOA = 0x0409,
	kTTM_HITTESTA = 0x040A,				kTTM_GETTEXTA = 0x040B,				kTTM_UPDATETIPTEXTA = 0x040C,		kTTM_GETTOOLCOUNT = 0x040D,			kTTM_ENUMTOOLSA = 0x040E,			kTTM_GETCURRENTTOOLA = 0x040F,		kTTM_WINDOWFROMPOINT = 0x0410,		kTTM_TRACKACTIVATE = 0x0411,
	kTTM_TRACKPOSITION = 0x0412,		kTTM_SETTIPBKCOLOR = 0x0413,		kTTM_SETTIPTEXTCOLOR = 0x0414,		kTTM_GETDELAYTIME = 0x0415,			kTTM_GETTIPBKCOLOR = 0x0416,		kTTM_GETTIPTEXTCOLOR = 0x0417,		kTTM_SETMAXTIPWIDTH = 0x0418,		kTTM_GETMAXTIPWIDTH = 0x0419,
	kTTM_SETMARGIN = 0x041A,			kTTM_GETMARGIN = 0x041B,			kTTM_POP = 0x041C,					kTTM_UPDATE = 0x041D,				kTTM_GETBUBBLESIZE = 0x041E,		kTTM_ADJUSTRECT = 0x041F,			kTTM_SETTITLEA = 0x0420,			kTTM_SETTITLEW = 0x0421,
	kTTM_ADDTOOLW = 0x0432,				kTTM_DELTOOLW = 0x0433,				kTTM_NEWTOOLRECTW = 0x0434,			kTTM_GETTOOLINFOW = 0x0435,			kTTM_SETTOOLINFOW = 0x0436,			kTTM_HITTESTW = 0x0437,				kTTM_GETTEXTW = 0x0438,				kTTM_UPDATETIPTEXTW = 0x0439,
	kTTM_ENUMTOOLSW = 0x043A,			kTTM_GETCURRENTTOOLW = 0x043B,

	// hotkey control
	kHKM_SETHOTKEY = 0x0401,			kHKM_GETHOTKEY = 0x0402,			kHKM_SETRULES = 0x0403,				

	//status bar control
	kSB_SETTEXTA = 0x0401,				kSB_GETTEXTA = 0x0402,				kSB_GETTEXTLENGTHA = 0x0403,		kSB_SETPARTS = 0x0404,				kSB_GETPARTS = 0x0406,				kSB_GETBORDERS = 0x0407,			kSB_SETMINHEIGHT = 0x0408,			kSB_SIMPLE = 0x0409,
	kSB_GETRECT = 0x040A,				kSB_SETTEXTW = 0x040B,				kSB_GETTEXTLENGTHW = 0x040C,		kSB_GETTEXTW = 0x040D,				kSB_ISSIMPLE = 0x040E,				kSB_SETICON = 0x040F,				kSB_SETTIPTEXTA = 0x0410,			kSB_SETTIPTEXTW = 0x0411,
	kSB_GETTIPTEXTA = 0x0412,			kSB_GETTIPTEXTW = 0x0413,			kSB_GETICON = 0x0414,				

	//animation control
	kACM_OPEN = 0x0464,					kACM_PLAY = 0x0465,					kACM_STOP = 0x0466,	                

	//common dialog
	kCDM_GETSPEC = 0x0464,				kCDM_GETFILEPATH = 0x0465,			kCDM_GETFOLDERPATH = 0x0466,		kCDM_GETFOLDERIDLIST = 0x0467,		kCDM_SETCONTROLTEXT = 0x0468,		kCDM_HIDECONTROL = 0x0469,			kCDM_SETDEFEXT = 0x046A,			

	//up-down controls
	kUDM_SETRANGE = 0x0465,				kUDM_GETRANGE = 0x0466,				kUDM_SETPOS = 0x0467,				kUDM_GETPOS = 0x0468,				kUDM_SETBUDDY = 0x0469,				kUDM_GETBUDDY = 0x046A,				kUDM_SETACCEL = 0x046B,				kUDM_GETACCEL = 0x046C,
	kUDM_SETBASE = 0x046D,				kUDM_GETBASE = 0x046E,				kUDM_SETRANGE32 = 0x046F,			kUDM_GETRANGE32 = 0x0470,			kUDM_SETPOS32 = 0x0471,				kUDM_GETPOS32 = 0x0472,					

	//property sheet
	kPSM_SETCURSEL = 0x0465,			kPSM_REMOVEPAGE = 0x0466,			kPSM_ADDPAGE = 0x0467,				kPSM_CHANGED = 0x0468,				kPSM_RESTARTWINDOWS = 0x0469,		kPSM_REBOOTSYSTEM = 0x046A,			kPSM_CANCELTOCLOSE = 0x046B,		kPSM_QUERYSIBLINGS = 0x046C,
	kPSM_UNCHANGED = 0x046D,			kPSM_APPLY = 0x046E,				kPSM_SETTITLE = 0x046F,				kPSM_SETWIZBUTTONS = 0x0470,		kPSM_PRESSBUTTON = 0x0471,			kPSM_SETCURSELID = 0x0472,			kPSM_SETFINISHTEXT = 0x0473,		kPSM_GETTABCONTROL = 0x0474,
	kPSM_ISDIALOGMESSAGE = 0x0475,		kPSM_GETCURRENTPAGEHWND = 0x0476,	kPSM_INSERTPAGE = 0x0477,			kPSM_SETHEADERTITLEA = 0x047D,		kPSM_SETHEADERTITLEW = 0x047E,		kPSM_SETHEADERSUBTITLEA = 0x047F,	kPSM_SETHEADERSUBTITLEW = 0x0480,	kPSM_HWNDTOINDEX = 0x0481,
	kPSM_INDEXTOHWND = 0x0482,			kPSM_PAGETOINDEX = 0x0483,			kPSM_INDEXTOPAGE = 0x0484,			kPSM_IDTOINDEX = 0x0485,			kPSM_INDEXTOID = 0x0486,			kPSM_GETRESULT = 0x0487,			kPSM_RECALCPAGESIZES = 0x0488,		

	//ip address control
	kIPM_CLEARADDRESS = 0x0464,			kIPM_SETADDRESS = 0x0465,			kIPM_GETADDRESS = 0x0466,			kIPM_SETRANGE = 0x0467,				kIPM_SETFOCUS = 0x0468,				kIPM_ISBLANK = 0x0469,				

	//drag list
	kDL_BEGINDRAG = 0x0485,				kDL_DRAGGING = 0x0486,				kDL_DROPPED = 0x0487,				kDL_CANCELDRAG = 0x0488,			

	//listview control
	kLVM_GETBKCOLOR = 0x1000,			kLVM_SETBKCOLOR = 0x1001,			kLVM_GETIMAGELIST = 0x1002,			kLVM_SETIMAGELIST = 0x1003,			kLVM_GETITEMCOUNT = 0x1004,			kLVM_GETITEM = 0x1005,				kLVM_SETITEM = 0x1006,				kLVM_INSERTITEM = 0x1007,
	kLVM_DELETEITEM = 0x1008,			kLVM_DELETEALLITEMS = 0x1009,		kLVM_GETCALLBACKMASK = 0x100A,		kLVM_SETCALLBACKMASK = 0x100B,		kLVM_GETNEXTITEM = 0x100C,			kLVM_FINDITEM = 0x100D,				kLVM_GETITEMRECT = 0x100E,			kLVM_SETITEMPOSITION = 0x100F,
	kLVM_GETITEMPOSITION = 0x1010,		kLVM_GETSTRINGWIDTH = 0x1011,		kLVM_HITTEST = 0x1012,				kLVM_ENSUREVISIBLE = 0x1013,		kLVM_SCROLL = 0x1014,				kLVM_REDRAWITEMS = 0x1015,			kLVM_ARRANGE = 0x1016,				kLVM_EDITLABEL = 0x1017,
	kLVM_GETEDITCONTROL = 0x1018,		kLVM_GETCOLUMN = 0x1019,			kLVM_SETCOLUMN = 0x101A,			kLVM_INSERTCOLUMN = 0x101B,			kLVM_DELETECOLUMN = 0x101C,			kLVM_GETCOLUMNWIDTH = 0x101D,		kLVM_SETCOLUMNWIDTH = 0x101E,		kLVM_GETHEADER = 0x101F,
	kLVM_CREATEDRAGIMAGE = 0x1021,		kLVM_GETVIEWRECT = 0x1022,			kLVM_GETTEXTCOLOR = 0x1023,			kLVM_SETTEXTCOLOR = 0x1024,			kLVM_GETTEXTBKCOLOR = 0x1025,		kLVM_SETTEXTBKCOLOR = 0x1026,		kLVM_GETTOPINDEX = 0x1027,			kLVM_GETCOUNTPERPAGE = 0x1028,
	kLVM_GETORIGIN = 0x1029,			kLVM_UPDATE = 0x102A,				kLVM_SETITEMSTATE = 0x102B,			kLVM_GETITEMSTATE = 0x102C,			kLVM_GETITEMTEXT = 0x102D,			kLVM_SETITEMTEXT = 0x102E,			kLVM_SETITEMCOUNT = 0x102F,			kLVM_SORTITEMS = 0x1030,
	kLVM_SETITEMPOSITION32 = 0x1031,	kLVM_GETSELECTEDCOUNT = 0x1032,		kLVM_GETITEMSPACING = 0x1033,		kLVM_GETISEARCHSTRING = 0x1034,		kLVM_SETICONSPACING = 0x1035,		kLVM_SETEXTENDEDLISTVIEWSTYLE = 0x1036,kLVM_GETEXTENDEDLISTVIEWSTYLE = 0x1037,	kLVM_GETSUBITEMRECT = 0x1038,
	kLVM_SUBITEMHITTEST = 0x1039,		kLVM_SETCOLUMNORDERARRAY = 0x103A,	kLVM_GETCOLUMNORDERARRAY = 0x103B,	kLVM_SETHOTITEM = 0x103C,			kLVM_GETHOTITEM = 0x103D,			kLVM_SETHOTCURSOR = 0x103E,			kLVM_GETHOTCURSOR = 0x103F,			kLVM_APPROXIMATEVIEWRECT = 0x1040,
	kLVM_SETWORKAREAS = 0x1041,			kLVM_GETSELECTIONMARK = 0x1042,		kLVM_SETSELECTIONMARK = 0x1043,		kLVM_SETBKIMAGE = 0x1044,			kLVM_GETBKIMAGE = 0x1045,			kLVM_GETWORKAREAS = 0x1046,			kLVM_SETHOVERTIME = 0x1047,			kLVM_GETHOVERTIME = 0x1048,
	kLVM_GETNUMBEROFWORKAREAS = 0x1049,	kLVM_SETTOOLTIPS = 0x104A,			kLVM_GETTOOLTIPS = 0x104E,			kLVM_SORTITEMSEX = 0x1051,			kLVM_INSERTGROUP = 0x1091,			kLVM_SETGROUPINFO = 0x1093,			kLVM_GETGROUPINFO = 0x1095,			kLVM_REMOVEGROUP = 0x1096,
	kLVM_SETGROUPMETRICS = 0x109B,		kLVM_GETGROUPMETRICS = 0x109C,		kLVM_ENABLEGROUPVIEW = 0x109D,		kLVM_SORTGROUPS = 0x109E,			kLVM_INSERTGROUPSORTED = 0x109F,	kLVM_REMOVEALLGROUPS = 0x10A0,		kLVM_HASGROUP = 0x10A1,				kLVM_SETTILEVIEWINFO = 0x10A2,
	kLVM_GETTILEVIEWINFO = 0x10A3,		kLVM_SETTILEINFO = 0x10A4,			kLVM_GETTILEINFO = 0x10A5,			kLVM_SETINSERTMARK = 0x10A6,		kLVM_GETINSERTMARK = 0x10A7,		kLVM_INSERTMARKHITTEST = 0x10A8,	kLVM_GETINSERTMARKRECT = 0x10A9,	kLVM_SETINSERTMARKCOLOR = 0x10AA,
	kLVM_GETINSERTMARKCOLOR = 0x10AB,	

	//date time
	kDTM_GETSYSTEMTIME = 0x1001,		kDTM_SETSYSTEMTIME = 0x1002,		kDTM_GETRANGE = 0x1003,				kDTM_SETRANGE = 0x1004,				kDTM_SETFORMATA = 0x1005,			kDTM_SETMCCOLOR = 0x1006,			kDTM_GETMCCOLOR = 0x1007,			kDTM_GETMONTHCAL = 0x1008,
	kDTM_SETMCFONT = 0x1009,			kDTM_GETMCFONT = 0x100A,			kDTM_SETFORMATW = 0x1032,			

	//month calendar
	kMCM_GETCURSEL = 0x1001,			kMCM_SETCURSEL = 0x1002,			kMCM_GETMAXSELCOUNT = 0x1003,		kMCM_SETMAXSELCOUNT = 0x1004,		kMCM_GETSELRANGE = 0x1005,			kMCM_SETSELRANGE = 0x1006,			kMCM_GETMONTHRANGE = 0x1007,		kMCM_SETDAYSTATE = 0x1008,
	kMCM_GETMINREQRECT = 0x1009,		kMCM_SETCOLOR = 0x100A,				kMCM_GETCOLOR = 0x100B,				kMCM_SETTODAY = 0x100C,				kMCM_GETTODAY = 0x100D,				kMCM_HITTEST = 0x100E,				kMCM_SETFIRSTDAYOFWEEK = 0x100F,	kMCM_GETFIRSTDAYOFWEEK = 0x1010,
	kMCM_GETRANGE = 0x1011,				kMCM_SETRANGE = 0x1012,				kMCM_GETMONTHDELTA = 0x1013,		kMCM_SETMONTHDELTA = 0x1014,		kMCM_GETMAXTODAYWIDTH = 0x1015,		

	// tree control
	kTVM_INSERTITEM = 0x1100,			kTVM_DELETEITEM = 0x1101,			kTVM_EXPAND = 0x1102,				kTVM_GETITEMRECT = 0x1104,			kTVM_GETCOUNT = 0x1105,				kTVM_GETINDENT = 0x1106,			kTVM_SETINDENT = 0x1107,			kTVM_GETIMAGELIST = 0x1108,
	kTVM_SETIMAGELIST = 0x1109,			kTVM_GETNEXTITEM = 0x110A,			kTVM_SELECTITEM = 0x110B,			kTVM_GETITEM = 0x110C,				kTVM_SETITEM = 0x110D,				kTVM_EDITLABEL = 0x110E,			kTVM_GETEDITCONTROL = 0x110F,		kTVM_GETVISIBLECOUNT = 0x1110,
	kTVM_HITTEST = 0x1111,				kTVM_CREATEDRAGIMAGE = 0x1112,		kTVM_SORTCHILDREN = 0x1113,			kTVM_ENSUREVISIBLE = 0x1114,		kTVM_SORTCHILDRENCB = 0x1115,		kTVM_ENDEDITLABELNOW = 0x1116,		kTVM_GETISEARCHSTRING = 0x1117,		kTVM_SETTOOLTIPS = 0x1118,
	kTVM_GETTOOLTIPS = 0x1119,			kTVM_SETINSERTMARK = 0x111A,		kTVM_SETITEMHEIGHT = 0x111B,		kTVM_GETITEMHEIGHT = 0x111C,		kTVM_SETBKCOLOR = 0x111D,			kTVM_SETTEXTCOLOR = 0x111E,			kTVM_GETBKCOLOR = 0x111F,			kTVM_GETTEXTCOLOR = 0x1120,
	kTVM_SETSCROLLTIME = 0x1121,		kTVM_GETSCROLLTIME = 0x1122,		kTVM_SETINSERTMARKCOLOR = 0x1125,	kTVM_GETINSERTMARKCOLOR = 0x1126,	kTVM_GETITEMSTATE = 0x1127,			kTVM_SETLINECOLOR = 0x1128,			kTVM_GETLINECOLOR = 0x1129,			

	// header control
	kHDM_GETITEMCOUNT = 0x1200,			kHDM_INSERTITEM = 0x1201,			kHDM_DELETEITEM = 0x1202,			kHDM_GETITEM = 0x1203,				kHDM_SETITEM = 0x1204,				kHDM_LAYOUT = 0x1205,				kHDM_HITTEST = 0x1206,				kHDM_GETITEMRECT = 0x1207,
	kHDM_SETIMAGELIST = 0x1208,			kHDM_GETIMAGELIST = 0x1209,			kHDM_ORDERTOINDEX = 0x120F,			kHDM_CREATEDRAGIMAGE = 0x1210,		kHDM_GETORDERARRAY = 0x1211,		kHDM_SETORDERARRAY = 0x1212,		kHDM_SETHOTDIVIDER = 0x1213,		kHDM_SETBITMAPMARGIN = 0x1214,
	kHDM_GETBITMAPMARGIN = 0x1215,		kHDM_SETFILTERCHANGETIMEOUT = 0x1216,kHDM_EDITFILTER = 0x1217,			kHDM_CLEARFILTER = 0x1218,			

	// tab control
	kTCM_GETIMAGELIST = 0x1302,			kTCM_SETIMAGELIST = 0x1303,			kTCM_GETITEMCOUNT = 0x1304,			kTCM_GETITEM = 0x1305,				kTCM_SETITEM = 0x1306,				kTCM_INSERTITEM = 0x1307,			kTCM_DELETEITEM = 0x1308,			kTCM_DELETEALLITEMS = 0x1309,
	kTCM_GETITEMRECT = 0x130A,			kTCM_GETCURSEL = 0x130B,			kTCM_SETCURSEL = 0x130C,			kTCM_HITTEST = 0x130D,				kTCM_SETITEMEXTRA = 0x130E,			kTCM_ADJUSTRECT = 0x1328,			kTCM_SETITEMSIZE = 0x1329,			kTCM_REMOVEIMAGE = 0x132A,
	kTCM_SETPADDING = 0x132B,			kTCM_GETROWCOUNT = 0x132C,			kTCM_GETTOOLTIPS = 0x132D,			kTCM_SETTOOLTIPS = 0x132E,			kTCM_GETCURFOCUS = 0x132F,			kTCM_SETCURFOCUS = 0x1330,			kTCM_SETMINTABWIDTH = 0x1331,		kTCM_DESELECTALL = 0x1332,
	kTCM_HIGHLIGHTITEM = 0x1333,		kTCM_SETEXTENDEDSTYLE = 0x1334,		kTCM_GETEXTENDEDSTYLE = 0x1335,		

	//pager control
	kPGM_SETCHILD = 0x1401,				kPGM_RECALCSIZE = 0x1402,			kPGM_FORWARDMOUSE = 0x1403,			kPGM_SETBKCOLOR = 0x1404,			kPGM_GETBKCOLOR = 0x1405,			kPGM_SETBORDER = 0x1406,			kPGM_GETBORDER = 0x1407,			kPGM_SETPOS = 0x1408,
	kPGM_GETPOS = 0x1409,				kPGM_SETBUTTONSIZE = 0x140A,		kPGM_GETBUTTONSIZE = 0x140B,		kPGM_GETBUTTONSTATE = 0x140C,		

	//common controls
	kCCM_SETBKCOLOR = 0x2001,			kCCM_SETCOLORSCHEME = 0x2002,		kCCM_GETCOLORSCHEME = 0x2003,		kCCM_GETDROPTARGET = 0x2004,		kCCM_SETUNICODEFORMAT = 0x2005,		kCCM_GETUNICODEFORMAT = 0x2006,		kCCM_SETVERSION = 0x2007,			kCCM_GETVERSION = 0x2008,

	kOCM_DRAWITEM = 0x202B,				kOCM_MEASUREITEM = 0x202C,			kOCM_DELETEITEM = 0x202D,			kOCM_VKEYTOITEM = 0x202E,			kOCM_CHARTOITEM = 0x202F,			kOCM_COMPAREITEM = 0x2039,			kOCM_NOTIFY = 0x204E,				kOCM_COMMAND = 0x2111,
	kOCM_HSCROLL = 0x2114,				kOCM_VSCROLL = 0x2115,				kOCM_CTLCOLORMSGBOX = 0x2132,		kOCM_CTLCOLOREDIT = 0x2133,			kOCM_CTLCOLORLISTBOX = 0x2134,		kOCM_CTLCOLORBTN = 0x2135,			kOCM_CTLCOLORDLG = 0x2136,			kOCM_CTLCOLORSCROLLBAR = 0x2137,
	kOCM_CTLCOLORSTATIC = 0x2138,		kOCM_PARENTNOTIFY = 0x2210,			

	kWM_CHOOSEFONT_GETLOGFONT = 0x0401,	kWM_CHOOSEFONT_SETLOGFONT = 0x0465,	kWM_CHOOSEFONT_SETFLAGS = 0x0466,
};

typedef LRESULT (CALLBACK* WNDPROC2)(HWND, MSG_ID, WPARAM, LPARAM);

struct MessageRecord {
	UINT	message;
	WPARAM	wParam;
	LPARAM	lParam;
	MessageRecord(MSG_ID message, wparam wParam, lparam lParam) : message(message), wParam(wParam), lParam(lParam) {}
	bool operator==(const MessageRecord &b) const {
		return	message == b.message
		&&		wParam == b.wParam
		&&		lParam == b.lParam;
	}
};

//----------------------------------------------------------------------
//	Resource
//----------------------------------------------------------------------

struct ID {
	union {
		uintptr_t		i;
		const char		*s;
		const char16	*s16;
	};
	ID()						{ i = 0; }
	ID(uint16 id)				{ i = id; }
	ID(const char *id)			{ s = id; }
	ID(const char16 *id)		{ s16 = id; }
	template<typename B> ID(const string_base<B> &id) { s = id.begin(); }

	operator LPSTR()	const	{ return (LPSTR)s; }
	operator UINT_PTR()	const	{ return i; }
	operator wparam()	const	{ return i; }
	operator lparam()	const	{ return i; }
	bool	IsOrdinal()	const	{ return i < (1 << 16); }
	bool	operator!()	const	{ return !i; }

	friend bool	operator==(ID a, ID b)	{ return a.i == b.i; }
	friend bool	operator!=(ID a, ID b)	{ return a.i != b.i; }
};

class Resource : public const_memory_block {
	void Init(HINSTANCE hInst, ID id, ID type) {
		HGLOBAL		hGlobal;
		HRSRC		hRsrc;
		if (p = (hRsrc = FindResourceA(hInst, id, type)) && (hGlobal = LoadResource(hInst, hRsrc)) ? LockResource(hGlobal) : NULL)
			n = SizeofResource(hInst, hRsrc);
	}
public:
	Resource(HINSTANCE hInst, ID id, ID type)	{ Init(hInst, id, type); }
	Resource(ID id, ID type)					{ Init(GetDefaultInstance(), id, type); }
};

//-----------------------------------------------------------------------------
//	Clipboard
//-----------------------------------------------------------------------------

struct Clipboard {
	struct iterator {
		UINT i;
		iterator(UINT i) : i(i)	{}
		iterator&	operator++()					{ i = EnumClipboardFormats(i); return *this; }
		iterator	operator++(int)					{ UINT t = i; i = EnumClipboardFormats(i); return t; }
		operator UINT()						const	{ return i; }
		bool operator==(const iterator &b)	const	{ return i == b.i; }
		bool operator!=(const iterator &b)	const	{ return i != b.i; }
		fixed_string<256>	name()			const	{ fixed_string<256> b; GetClipboardFormatNameA(i, b, sizeof(b)); return b; }
		global_base			data()			const	{ return GetClipboardData(i); }
	};

	static bool	Available(UINT fmt)				{ return IsClipboardFormatAvailable(fmt); }
	static UINT	Register(const char *name)		{ return RegisterClipboardFormatA(name); }

	static int AvailableAny(UINT fmt)			{ return Available(fmt) ? fmt : 0; }
	template<typename...F> static int AvailableAny(UINT fmt, F...fmts)	{ return Available(fmt) ? fmt : AvailableAny(fmts...); }

	iterator	begin()							{ return EnumClipboardFormats(0); }
	iterator	end()							{ return 0; }

	Clipboard(HWND hWnd)						{ OpenClipboard(hWnd); }
	~Clipboard()								{ CloseClipboard(); }
	bool				Empty()					{ return !!EmptyClipboard(); }
	static bool			Set(const char *text)						{ return !!SetClipboardData(CF_TEXT, MakeGlobal(text, string_len(text) + 1, GMEM_MOVEABLE)); }
	static bool			Set(const char16 *text)						{ return !!SetClipboardData(CF_UNICODETEXT, MakeGlobal(text, string_len(text) + 1, GMEM_MOVEABLE)); }
	template<typename T> static bool Set(UINT fmt, const T &t)		{ return !!SetClipboardData(fmt, MakeGlobal(t)); }
	static global_base	Get(UINT fmt)								{ return GetClipboardData(fmt); }
	template<typename T> static global_ptr<T>	Get(UINT fmt)		{ return GetClipboardData(fmt); }
};

//-----------------------------------------------------------------------------
//	Point & Rect
//-----------------------------------------------------------------------------

struct LatchMouseButtons {
	static HHOOK	hook;
	static int		buttons;
	static LRESULT CALLBACK Proc(int nCode, WPARAM wParam, LPARAM lParam) {
		switch (wParam) {
			case WM_LBUTTONDOWN:	buttons |= MK_LBUTTON; break;
			case WM_RBUTTONDOWN:	buttons |= MK_RBUTTON; break;
			case WM_LBUTTONUP:		break;
			case WM_RBUTTONUP:		break;
		}
		return CallNextHookEx(hook, nCode, wParam, lParam);
	}

	LatchMouseButtons()  {
		hook = SetWindowsHookEx(WH_MOUSE, Proc, NULL, GetCurrentThreadId());
	}
	~LatchMouseButtons() {
		UnhookWindowsHookEx(hook);
	}
	static int	get_clear_buttons()	{ return exchange(buttons, 0); }
};

inline Point GetMousePos()			{ Point p; GetCursorPos(&p); return p; }
inline Point GetMessageMousePos()	{ return Point((LPARAM)GetMessagePos()); }
uint16 GetMouseButtons();

struct GestureInfo : GESTUREINFO {
	GestureInfo()		{ clear(*this); cbSize = sizeof(*this); }
	GestureInfo(HGESTUREINFO h)	{ clear(*this); cbSize = sizeof(*this); GetGestureInfo(h, this); }
	Point	Location()	{ return ptsLocation; }
	uint32	Distance()	{ return (uint32)ullArguments; }
};

struct WindowPos {
	Rect	rect;
	HWND    parent;
	HWND    after;

	WindowPos() : rect(CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT), parent(0), after(0) {}
	WindowPos(HWND parent, const Rect &r, HWND after = 0) : rect(r), parent(parent), after(after) {}

	WindowPos&			Parent(HWND h) {
		parent	= h;
		return *this;
	}
	inline Control		Parent() const;
	WindowPos&			After(HWND h) {
		after	= h;
		return *this;
	}
	inline Control		After() const;
	WindowPos&			Rect(const Rect &r) {
		rect	= r;
		return *this;
	}
	const win::Rect&	Rect() const {
		return rect;
	}
	WindowPos	Subbox(int x, int y, int w, int h) const {
		return WindowPos(parent, rect.Subbox(x, y, w, h));
	}
};

//-----------------------------------------------------------------------------
//	Metrics
//-----------------------------------------------------------------------------

inline Point GetCaptionSize()		{ return force_cast<Point>(GetNonClientMetrics().iCaptionWidth); }
inline Point GetSmallCaptionSize()	{ return force_cast<Point>(GetNonClientMetrics().iSmCaptionWidth); }
inline Point GetScrollSize()		{ return force_cast<Point>(GetNonClientMetrics().iScrollWidth); }
inline Point GetMenuSize()			{ return force_cast<Point>(GetNonClientMetrics().iMenuWidth); }


struct SystemMetrics {
	static int		Get(int i)				{ return GetSystemMetrics(i); }
	static int		ScreenWidth()			{ return Get(SM_CXSCREEN); }
	static int		ScreenHeight()			{ return Get(SM_CYSCREEN); }
	static int		VScrollWidth()			{ return Get(SM_CXVSCROLL); }
	static int		HScrollHeight()			{ return Get(SM_CYHSCROLL); }
	static int		CaptionHeight()			{ return Get(SM_CYCAPTION); }
	static int		BorderWidth()			{ return Get(SM_CXBORDER); }
	static int		BorderHeight()			{ return Get(SM_CYBORDER); }
	static int		DialogFrameWidth()		{ return Get(SM_CXDLGFRAME); }
	static int		DialogFrameHeight()		{ return Get(SM_CYDLGFRAME); }
	static int		VThumbHeight()			{ return Get(SM_CYVTHUMB); }
	static int		HThumbWidth()			{ return Get(SM_CXHTHUMB); }
	static int		IconWidth()				{ return Get(SM_CXICON); }
	static int		IconHeight()			{ return Get(SM_CYICON); }
	static int		CursorWidth()			{ return Get(SM_CXCURSOR); }
	static int		CursorHeight()			{ return Get(SM_CYCURSOR); }
	static int		MenuBarHeight()			{ return Get(SM_CYMENU); }
	static int		FullScreenWidth()		{ return Get(SM_CXFULLSCREEN); }
	static int		FullScreenHeight()		{ return Get(SM_CYFULLSCREEN); }
	static int		KanjiWindowHeight()		{ return Get(SM_CYKANJIWINDOW); }
	static int		MousePresent()			{ return Get(SM_MOUSEPRESENT); }
	static int		VScrollHeight()			{ return Get(SM_CYVSCROLL); }
	static int		HScrollWidth()			{ return Get(SM_CXHSCROLL); }
	static int		Debug()					{ return Get(SM_DEBUG); }
	static int		SwapButton()			{ return Get(SM_SWAPBUTTON); }
	static int		MinWidth()				{ return Get(SM_CXMIN); }
	static int		MinHeight()				{ return Get(SM_CYMIN); }
	static int		CaptionButtonWidth()	{ return Get(SM_CXSIZE); }
	static int		CaptionButtonHeight()	{ return Get(SM_CYSIZE); }
	static int		FrameWidth()			{ return Get(SM_CXFRAME); }
	static int		FrameHeight()			{ return Get(SM_CYFRAME); }
	static int		MinTrackWidth()			{ return Get(SM_CXMINTRACK); }
	static int		MinTrackHeight()		{ return Get(SM_CYMINTRACK); }
	static int		DoubleClickWidth()		{ return Get(SM_CXDOUBLECLK); }
	static int		DoubleClickHeight()		{ return Get(SM_CYDOUBLECLK); }
	static int		IconSpacingWidth()		{ return Get(SM_CXICONSPACING); }
	static int		IconSpacingHeight()		{ return Get(SM_CYICONSPACING); }
	static int		MenuDropAlignment()		{ return Get(SM_MENUDROPALIGNMENT); }
	static int		PenWindows()			{ return Get(SM_PENWINDOWS); }
	static int		DBCSEnabled()			{ return Get(SM_DBCSENABLED); }
	static int		CMouseButtons()			{ return Get(SM_CMOUSEBUTTONS); }
	static int		Secure()				{ return Get(SM_SECURE); }
	static int		EdgeWidth()				{ return Get(SM_CXEDGE); }
	static int		EdgeHeight()			{ return Get(SM_CYEDGE); }
	static int		MinSpacingWidth()		{ return Get(SM_CXMINSPACING); }
	static int		MinSpacingHeight()		{ return Get(SM_CYMINSPACING); }
	static int		SmallIconWidth()		{ return Get(SM_CXSMICON); }
	static int		SmallIconHeight()		{ return Get(SM_CYSMICON); }
	static int		SmallCaptionHeight()	{ return Get(SM_CYSMCAPTION); }
	static int		SmallWidth()			{ return Get(SM_CXSMSIZE); }
	static int		SmallHeight()			{ return Get(SM_CYSMSIZE); }
	static int		MenuButtonWidth()		{ return Get(SM_CXMENUSIZE); }
	static int		MenuButtonHeight()		{ return Get(SM_CYMENUSIZE); }
	static int		Arrange()				{ return Get(SM_ARRANGE); }
	static int		MinimizedWidth()		{ return Get(SM_CXMINIMIZED); }
	static int		MinimizedHeight()		{ return Get(SM_CYMINIMIZED); }
	static int		MaxTrackWidth()			{ return Get(SM_CXMAXTRACK); }
	static int		MaxTrackHeight()		{ return Get(SM_CYMAXTRACK); }
	static int		MaximizedWidth()		{ return Get(SM_CXMAXIMIZED); }
	static int		MaximizedHeight()		{ return Get(SM_CYMAXIMIZED); }
	static int		Network()				{ return Get(SM_NETWORK); }
	static int		CleanBoot()				{ return Get(SM_CLEANBOOT); }
	static int		DragWidth()				{ return Get(SM_CXDRAG); }
	static int		DragHeight()			{ return Get(SM_CYDRAG); }
	static int		ShowSounds()			{ return Get(SM_SHOWSOUNDS); }
	static int		MenuCheckWidth()		{ return Get(SM_CXMENUCHECK); }
	static int		MenuCheckHeight()		{ return Get(SM_CYMENUCHECK); }
	static int		SlowMachine()			{ return Get(SM_SLOWMACHINE); }
	static int		MideastEnabled()		{ return Get(SM_MIDEASTENABLED); }
	static int		MouseWheelPresent()		{ return Get(SM_MOUSEWHEELPRESENT); }
	static int		VirtualScreenX()		{ return Get(SM_XVIRTUALSCREEN); }
	static int		VirtualScreenY()		{ return Get(SM_YVIRTUALSCREEN); }
	static int		VirtualScreenWidth()	{ return Get(SM_CXVIRTUALSCREEN); }
	static int		VirtualScreenHeight()	{ return Get(SM_CYVIRTUALSCREEN); }
	static int		CMonitors()				{ return Get(SM_CMONITORS); }
	static int		SameDisplayFormat()		{ return Get(SM_SAMEDISPLAYFORMAT); }
	static int		ImmEnabled()			{ return Get(SM_IMMENABLED); }
	static int		FocusBorderWidth()		{ return Get(SM_CXFOCUSBORDER); }
	static int		FocusBorderHeight()		{ return Get(SM_CYFOCUSBORDER); }
	static int		TabletPC()				{ return Get(SM_TABLETPC); }
	static int		MediaCenter()			{ return Get(SM_MEDIACENTER); }
	static int		Starter()				{ return Get(SM_STARTER); }
	static int		ServerR2()				{ return Get(SM_SERVERR2); }
	static int		HorizontalWheelPresent(){ return Get(SM_MOUSEHORIZONTALWHEELPRESENT); }
	static int		PaddedBorderWidth()		{ return Get(SM_CXPADDEDBORDER); }
	static int		CMetrics()				{ return Get(SM_CMETRICS); }
	static int		RemoteSession()			{ return Get(SM_REMOTESESSION); }
	static int		ShuttingDown()			{ return Get(SM_SHUTTINGDOWN); }
	static int		RemoteControl()			{ return Get(SM_REMOTECONTROL); }
	static int		CaretBlinkingEnabled()	{ return Get(SM_CARETBLINKINGENABLED); }
#if WINVER >= 0x0601
	static int		Digitizer()				{ return Get(SM_DIGITIZER); }
	static int		MaximumTouches()		{ return Get(SM_MAXIMUMTOUCHES); }
	static int		ConvertibleSlateMode()	{ return Get(SM_CONVERTIBLESLATEMODE); }
	static int		SystemDocked()			{ return Get(SM_SYSTEMDOCKED); }
#endif
// Combos
	static Point	ScreenSize()			{ return Point(ScreenWidth(),		ScreenHeight()); }
	static Point	BorderSize()			{ return Point(BorderWidth(),		BorderHeight()); }
	static Point	DialogFrameSize()		{ return Point(DialogFrameWidth(),	DialogFrameHeight()); }
	static Point	IconSize()				{ return Point(IconWidth(),			IconHeight()); }
	static Point	CursorSize()			{ return Point(CursorWidth(),		CursorHeight()); }
	static Point	FullScreenSize()		{ return Point(FullScreenWidth(),	FullScreenHeight()); }
	static Point	VScrollSize()			{ return Point(VScrollWidth(),		VScrollHeight()); }
	static Point	HScrollSize()			{ return Point(HScrollWidth(),		HScrollHeight()); }
	static Point	MinSize()				{ return Point(MinWidth(),			MinHeight()); }
	static Point	CaptionButtonSize()		{ return Point(CaptionButtonWidth(),CaptionButtonHeight()); }
	static Point	FrameSize()				{ return Point(FrameWidth(),		FrameHeight()); }
	static Point	MinTrackSize()			{ return Point(MinTrackWidth(),		MinTrackHeight()); }
	static Point	DoubleClickSize()		{ return Point(DoubleClickWidth(),	DoubleClickHeight()); }
	static Point	IconSpacingSize()		{ return Point(IconSpacingWidth(),	IconSpacingHeight()); }
	static Point	EdgeSize()				{ return Point(EdgeWidth(),			EdgeHeight()); }
	static Point	MinSpacingSize()		{ return Point(MinSpacingWidth(),	MinSpacingHeight()); }
	static Point	SmallIconSize()			{ return Point(SmallIconWidth(),	SmallIconHeight()); }
	static Point	SmallSize()				{ return Point(SmallWidth(),		SmallHeight()); }
	static Point	MenuButtonSize()		{ return Point(MenuButtonWidth(),	MenuButtonHeight()); }
	static Point	MinimizedSize()			{ return Point(MinimizedWidth(),	MinimizedHeight()); }
	static Point	MaxTrackSize()			{ return Point(MaxTrackWidth(),		MaxTrackHeight()); }
	static Point	MaximizedSize()			{ return Point(MaximizedWidth(),	MaximizedHeight()); }
	static Point	MenuCheckSize()			{ return Point(MenuCheckWidth(),	MenuCheckHeight()); }
	static Point	VirtualScreenSize()		{ return Point(VirtualScreenWidth(),VirtualScreenHeight()); }
	static Point	FocusBorderSize()		{ return Point(FocusBorderWidth(),	FocusBorderHeight()); }
	static Point	DragSize()				{ return Point(DragWidth(),	DragHeight()); }

	static Point	VirtualScreenPos()		{ return Point(VirtualScreenX(),	VirtualScreenY()); }
};

//-----------------------------------------------------------------------------
//	ScrollInfo
//-----------------------------------------------------------------------------

struct ScrollInfo : SCROLLINFO {
	ScrollInfo(uint32 mask = 0) { clear(*this); cbSize = sizeof(SCROLLINFO); fMask = mask; }

	int	Pos()	const { return nPos; }
	int	Page()	const { return nPage; }
	int	Min()	const { return nMin; }
	int	Max()	const { return nMax; }

	ScrollInfo&	Pos(int pos)				{ nPos	= pos; fMask |= SIF_POS; return *this; }
	ScrollInfo&	Page(int page)				{ nPage	= page; fMask |= SIF_PAGE; return *this; }
	ScrollInfo& Range(int nmin, int nmax)	{ nMin = nmin; nMax = nmax; fMask |= SIF_RANGE; return *this; }

	int	MoveTo(int pos) {
		int	p	= nPos;
		nPos	= clamp(pos, nMin, max(nMax - int(nPage), 0));
		fMask	|= SIF_POS;
		return p - nPos;
	}
	int	MoveBy(int d) {
		return MoveTo(nPos + d);
	}
	int	ProcessScroll(WPARAM wParam, int line = 1) {
		int	p	= nPos;
		switch (LOWORD(wParam)) {
			case SB_PAGELEFT:		p -= nPage;			break;
			case SB_PAGERIGHT: 		p += nPage;			break;
			case SB_LINELEFT:		p -= line;			break;
			case SB_LINERIGHT:		p += line;			break;
//			case SB_THUMBPOSITION:
			case SB_THUMBTRACK:		p = short(HIWORD(wParam));	break;
		}
		return MoveTo(p);
	}
	int	ProcessKey(WPARAM wParam, int line = 1) {
		int	p	= nPos;
		switch (wParam) {
			case VK_PRIOR:		p -= nPage;			break;
			case VK_NEXT:		p += nPage;			break;
			case VK_UP:			p -= line;			break;
			case VK_DOWN:		p += line;			break;
			default: return 0;
		}
		return MoveTo(p);
	}
	int	SetPage(int page) {
		int	p	= nPos;
		nPage	= page;
		nPos	= clamp(nPos, nMin, max(nMax - int(nPage), 0));
		fMask	|= SIF_PAGE;
		return p - nPos;
	}
	int	Set(int nmin, int nmax, int page) {
		return Range(nmin, nmax).SetPage(page);
	}
};

//-----------------------------------------------------------------------------
//	Icon
//-----------------------------------------------------------------------------

class Bitmap;

class Icon : public H<HICON> {
public:
	struct Params : ICONINFO {
		Params()						{ clear(*this); }
		Params(HICON h)					{ GetIconInfo(h, this); }
		Params(Icon i)					{ GetIconInfo(i, this); }
		Point	Hotspot()	const		{ return Point(xHotspot, yHotspot); }
		bool	IsCursor()	const		{ return !fIcon; }
		Bitmap	Mask()		const;
		Bitmap	Color()		const;
		Point	Size()		const;
		Params&	Hotspot(const POINT &p)	{ xHotspot	= p.x; yHotspot = p.y; return *this; }
		Params&	IsCursor(bool cursor)	{ fIcon		= !cursor; return *this; }
		Params&	Mask(HBITMAP b)			{ hbmMask	= b; return *this; }
		Params&	Color(HBITMAP b)		{ hbmColor	= b; return *this; }
	};

	static Icon		Load(HINSTANCE hInst, ID id, int flags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, uint32 width = 0, uint32 height = 0) {
		return (HICON)LoadImageA(hInst, id, IMAGE_ICON, width, height, flags);
	}
	static Icon		Load(ID id, int flags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, uint32 width = 0, uint32 height = 0) {
		return Load(GetDefaultInstance(), id, flags, width, height);
	}
	static Icon		LoadSystem(ID id) {
		return LoadIconA(NULL, id);
	}
	static Icon		Create(HINSTANCE hInst, uint32 width, uint32 height, uint8 planes, uint8 bits, const uint8 *mask, const void *color) {
		return CreateIcon(hInst, width, height, planes, bits, mask, (const uint8*)color);
	}
	static Icon		Create(uint32 width, uint32 height, uint8 planes, uint8 bits, const uint8 *mask, const void *color) {
		return CreateIcon(NULL, width, height, planes, bits, mask, (const uint8*)color);
	}

	Icon()									{}
	Icon(HICON h)			: H<HICON>(h)	{}
	Icon(const ICONINFO &i)	: H<HICON>(CreateIconIndirect(const_cast<ICONINFO*>(&i)))	{}
	Params	GetParams()	const	{ return *this; }
};

//-----------------------------------------------------------------------------
//	Cursor
//-----------------------------------------------------------------------------

class Cursor : public H<HCURSOR> {
public:
	typedef Icon::Params	Params;
	static Cursor	Load(HINSTANCE hInst, ID id, int flags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, uint32 width = 0, uint32 height = 0) {
		return (HCURSOR)LoadImageA(hInst, id, IMAGE_CURSOR, width, height, flags);
	}
	static Cursor	Load(ID id, int flags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, uint32 width = 0, uint32 height = 0) {
		return Load(GetDefaultInstance(), id, flags, width, height);
	}
	static Cursor	LoadSystem(ID id) {
		return LoadCursorA(NULL, id);
	}
	static Icon		Create(HINSTANCE hInst, const POINT &hotspot, uint32 width, uint32 height, const uint8 *mask, const uint8 *_xor) {
		return CreateCursor(hInst, hotspot.x, hotspot.y, width, height, mask, _xor);
	}
	static Cursor	Current() {
		return GetCursor();
	}

	Cursor()									{}
	Cursor(HCURSOR h)			: H<HCURSOR>(h)	{}
	Cursor(const ICONINFO &i)	: H<HCURSOR>(CreateIconIndirect(const_cast<ICONINFO*>(&i)))	{}
	Params	GetParams()	const	{ return h; }
	void	Set()		const	{ SetCursor(h); }
};

class Busy {
	Cursor	old;
public:
	Busy() : old(GetCursor()) { SetCursor(LoadCursor(NULL, IDC_WAIT)); }
	~Busy()	{ old.Set();}
};


//-----------------------------------------------------------------------------
//	Bitmap
//-----------------------------------------------------------------------------

class Bitmap : public H<HBITMAP> {
public:
	struct Params : BITMAP {
		Params()									{ clear(*this); }
		Params(const BITMAP &bm) : BITMAP(bm)		{}
		Params(HBITMAP h)							{ if (!GetObjectA(h, sizeof(*this), this)) clear(*this); }
		//Params(Bitmap bm)							{ if (!GetObjectA(bm, sizeof(*this), this)) clear(*this); }
		uint32			Width()				const	{ return bmWidth; }
		uint32			Height()			const	{ return bmHeight; }
		uint32			Pitch()				const	{ return bmWidthBytes; }
		uint32			Planes()			const	{ return bmPlanes; }
		uint32			BitsPerPixel()		const	{ return bmBitsPixel; }
		Point			Size()				const	{ return Point(bmWidth, bmHeight); }
		arbitrary_ptr	Scanline(uint32 i)	const	{ return (char*)bmBits + bmWidthBytes * i; }
	};

	struct Info : BITMAPINFOHEADER {
		Info() { clear(*this); biSize = sizeof(BITMAPINFOHEADER); }
		RGBQUAD palette[256];
		uint32	Scan()	const { return ((biWidth * biBitCount * biPlanes + 31) >> 3) & ~3; }
	};

	static Bitmap	Load(HINSTANCE hInst, ID id)														{ return (HBITMAP)LoadBitmapA(hInst, id); }
	static Bitmap	Load(ID id)																			{ return Load(GetDefaultInstance(), id); }
	static Bitmap	LoadSystem(ID id)																	{ return Load(NULL, id); }
	static Bitmap	Load(HINSTANCE hInst, ID id, uint32 flags, uint32 width = 0, uint32 height = 0)		{ return (HBITMAP)LoadImageA(hInst, id, IMAGE_BITMAP, width, height, flags); }
	static Bitmap	Load(ID id, uint32 flags, uint32 width = 0, uint32 height = 0)						{ return Load(GetDefaultInstance(), id, flags, width, height); }
	static Bitmap	Load(HINSTANCE hInst, ID id, uint32 flags, const POINT &size)						{ return (HBITMAP)LoadImageA(hInst, id, IMAGE_BITMAP, size.x, size.y, flags); }
	static Bitmap	Load(ID id, uint32 flags, const POINT &size)										{ return Load(GetDefaultInstance(), id, flags, size.x, size.y);	}
	static Bitmap	CreateDIBSection(const BITMAPINFOHEADER &bi, void **data = 0)						{ return ::CreateDIBSection(0, (BITMAPINFO*)&bi, DIB_RGB_COLORS, data, 0, 0); }
	static Bitmap	CreateDIBSection(const POINT &size, int bits, uint32 planes = 1, void **data = 0)	{ return CreateDIBSection(size.x, size.y, bits, planes, data); }
	static Bitmap	CreateDIBSection(int w, int h, int bits, uint32 planes = 1, void **data = 0);

	Bitmap() {}
	Bitmap(HBITMAP h)					: H<HBITMAP>(h)	{}
	Bitmap(const BITMAPINFOHEADER &bi)	: H<HBITMAP>(CreateDIBSection(bi, 0)) {}
	Bitmap(const BITMAP &bm)			: H<HBITMAP>(CreateBitmapIndirect(&bm))	{}
	Bitmap(int w, int h, uint32 bits, uint32 planes = 1, const void *data = 0) : H<HBITMAP>(CreateBitmap(w, h, planes, bits, data)) {}
	Bitmap(HDC hdc, int w, int h, bool discardable = false) : H<HBITMAP>(discardable ? CreateDiscardableBitmap(hdc, w, h) : CreateCompatibleBitmap(hdc, w, h)) {}

	Params	GetParams()								const { return h; }
	Point	GetDimension()							const { SIZE size; GetBitmapDimensionEx(h, &size); return size; }
	bool	SetDimension(const POINT &p)			const { return !!SetBitmapDimensionEx(h, p.x, p.y, 0); }
	Point	GetSize()								const { return GetParams().Size(); }
	void	GetBits(uint32 *size, void *bits)		const { *size = GetBitmapBits(h, *size, bits); }
	void	SetBits(uint32 size, const void *bits)	const { SetBitmapBits(h, size, bits); }

	int				GetBits(HDC hdc, Info &bi, void *buffer, int y, int lines, int usage = DIB_RGB_COLORS) const {
		return GetDIBits(hdc, h, y, lines, buffer, (BITMAPINFO*)&bi, usage);
	}
	malloc_block	GetBits(HDC hdc, Info &bi, int y, int lines, int usage = DIB_RGB_COLORS) const {
		uint32			scan	= bi.Scan();
		malloc_block	mb(scan * lines);
		return GetBits(hdc, bi, mb, y, lines, usage) ? mb : malloc_block();
	}

	malloc_block	GetBits(HDC hdc, int y, int lines, int usage = DIB_RGB_COLORS) const {
		Info	bi;
		if (GetDIBits(hdc, h, y, lines, 0, (BITMAPINFO*)&bi, usage)) {
			bi.biCompression	= BI_RGB;
			bi.biHeight			= -abs(bi.biHeight);
			return GetBits(hdc, bi, y, lines, usage);
		}
		return malloc_block();
	}

	Bitmap	ScaledTo(const POINT &newsize) const;
};

inline Bitmap	Icon::Params::Mask()	const	{ return hbmMask; }
inline Bitmap	Icon::Params::Color()	const	{ return hbmColor; }
inline Point	Icon::Params::Size()	const	{
	if (hbmColor)
		return Color().GetSize();
	Point size	= Mask().GetSize();
	size.y /= 2;
	return size;
}

//-----------------------------------------------------------------------------
//	Brush
//-----------------------------------------------------------------------------

class Brush : public H<HBRUSH> {
public:
	enum HATCH {
		INVALID		= -1,
		HORIZONTAL	= HS_HORIZONTAL,
		VERTICAL	= HS_VERTICAL,
		FDIAGONAL	= HS_FDIAGONAL,
		BDIAGONAL	= HS_BDIAGONAL,
		CROSS		= HS_CROSS,
		DIAGCROSS	= HS_DIAGCROSS,
	};
	struct Params : LOGBRUSH {
		Params()								{ clear(*this); }
		Params(HBRUSH h)						{ if (!GetObjectA(h, sizeof(*this), this)) clear(*this); }
		Params(const LOGBRUSH &log) : LOGBRUSH(log)	{}
		Params(uint32 style, Colour col, ULONG_PTR hatch) { lbStyle = style; lbColor = col; lbHatch = hatch; }
		uint32			Style()			const	{ return lbStyle; }
		win::Colour		Colour()		const	{ return win::Colour(lbColor); }
		HATCH			Hatch()			const	{ return lbStyle == BS_HATCHED ? HATCH(lbHatch) : INVALID; }
		BITMAPINFO*		Bitmap()		const	{ return lbStyle == BS_DIBPATTERNPT ? (BITMAPINFO*)lbHatch : 0; }
		HBITMAP			BitmapHandle()	const	{ return lbStyle == BS_PATTERN ? (HBITMAP)lbHatch : 0; }
		operator const LOGBRUSH*()		const	{ return this; }
	};

	static Brush	SysColor(int i)	{ return GetSysColorBrush(i); }
	static Brush	Black()			{ return (HBRUSH)GetStockObject(BLACK_BRUSH	); }
	static Brush	DarkGrey()		{ return (HBRUSH)GetStockObject(DKGRAY_BRUSH); }
	static Brush	Dc()			{ return (HBRUSH)GetStockObject(DC_BRUSH	); }
	static Brush	Grey()			{ return (HBRUSH)GetStockObject(GRAY_BRUSH	); }
	static Brush	Hollow()		{ return (HBRUSH)GetStockObject(HOLLOW_BRUSH); }
	static Brush	LightGrey()		{ return (HBRUSH)GetStockObject(LTGRAY_BRUSH); }
	static Brush	Null()			{ return (HBRUSH)GetStockObject(NULL_BRUSH	); }
	static Brush	White()			{ return (HBRUSH)GetStockObject(WHITE_BRUSH	); }

	Brush(HBRUSH h)						: H<HBRUSH>(h)	{}
	Brush(Colour col)					: H<HBRUSH>(CreateSolidBrush(col))				{}
	Brush(uint8 r, uint8 g, uint8 b)	: H<HBRUSH>(CreateSolidBrush(Colour(r,g,b)))	{}
	Brush(Colour col, HATCH h)			: H<HBRUSH>(CreateHatchBrush(h, col))			{}
	Brush(HBITMAP h)					: H<HBRUSH>(CreatePatternBrush(h))				{}
	Brush(const BITMAPINFO *bi)			: H<HBRUSH>(CreateDIBPatternBrushPt(bi, DIB_RGB_COLORS)) {}
	Brush(const LOGBRUSH &lb)			: H<HBRUSH>(CreateBrushIndirect(&lb))			{}
	~Brush()	{ Destroy(); }
};

//-----------------------------------------------------------------------------
//	Pen
//-----------------------------------------------------------------------------

class Pen : public H<HPEN> {
public:
	struct Params : LOGPEN {
		Params()							{ clear(*this); }
		Params(HPEN h)						{ if (!GetObjectA(h, sizeof(*this), this)) clear(*this); }
		Params(const LOGPEN &log) : LOGPEN(log)	{}
		uint32		Style()			const	{ return lopnStyle; }
		int			Width()			const	{ return lopnWidth.x; }
		win::Colour	Colour()		const	{ return win::Colour(lopnColor); }
		operator const LOGPEN*()	const	{ return this; }
	};

	static Pen	Black()			{ return (HPEN)GetStockObject(BLACK_PEN); }
	static Pen	Dc()			{ return (HPEN)GetStockObject(DC_PEN); }
	static Pen	Null()			{ return (HPEN)GetStockObject(NULL_PEN); }
	static Pen	White()			{ return (HPEN)GetStockObject(WHITE_PEN); }

	Pen(HPEN h)			: H<HPEN>(h)		{}
	Pen(Colour col, uint32 width = 0, uint32 style = PS_SOLID) : H<HPEN>(CreatePen(style, width, col))	{}
};

class PenExt : public H<HPEN> {
public:
	struct Params : EXTLOGPEN {
		Params(const EXTLOGPEN &log) : EXTLOGPEN(log)	{}
		Params(PenExt h)					{ if (!GetObjectA(h, sizeof(*this), this)) clear(*this); }
		uint32		Style()			const	{ return elpPenStyle; }
		int			Width()			const	{ return elpWidth; }
		uint32		BrushStyle()	const	{ return elpBrushStyle; }
		win::Colour	Colour()		const	{ return win::Colour(elpColor); }
		ULONG_PTR   Hatch()			const	{ return elpHatch; }
		uint32		StyleCount()	const	{ return elpNumEntries; }
		uint32*		Styles()		const	{ return (uint32*)elpStyleEntry; }
		operator const EXTLOGPEN*()	const	{ return this; }
	};

	PenExt(HPEN h)			: H<HPEN>(h)		{}
	PenExt(Colour col, uint32 width, uint32 pen_style, uint32 brush_style, ULONG_PTR hatch, const uint32 *styles, uint32 num_styles) :
		H<HPEN>(ExtCreatePen(pen_style, width, Brush::Params(brush_style, col, hatch), num_styles, (DWORD*)styles)) {}
};

//-----------------------------------------------------------------------------
//	Region
//-----------------------------------------------------------------------------

class Region : public H<HRGN> {
	struct RegionOp {
		HRGN	a, b;
		int		mode;
		RegionOp(HRGN a, HRGN b, int mode) : a(a), b(b), mode(mode) {}
	};
	friend RegionOp operator&(Region a, HRGN b) { return RegionOp(a, b, RGN_AND); }
	friend RegionOp operator|(Region a, HRGN b) { return RegionOp(a, b, RGN_OR); }
	friend RegionOp operator^(Region a, HRGN b) { return RegionOp(a, b, RGN_XOR); }
	friend RegionOp operator-(Region a, HRGN b) { return RegionOp(a, b, RGN_DIFF); }
public:
	static Region Ellipse(const RECT &rect) {
		return CreateEllipticRgnIndirect(&rect);
	}
	static Region Poly(const Point *pts, int n, bool winding = true) {
		return CreatePolygonRgn(pts, n, winding ? WINDING : ALTERNATE);
	}
	static Region PolyPoly(const Point *pts, int *counts, int n, bool winding = true) {
		return CreatePolyPolygonRgn(pts, counts, n, winding ? WINDING : ALTERNATE);
	}
	static Region RoundRect(const RECT &rect, int rx, int ry) {
		return CreateRoundRectRgn(rect.left, rect.top, rect.right, rect.bottom, rx, ry);
	}
	Region(HRGN h)				: H<HRGN>(h)							{}
	Region(const RECT &r)		: H<HRGN>(CreateRectRgnIndirect(&r))	{}
	Region(const RegionOp &op)	: H<HRGN>(CreateRectRgn(0,0,0,0))		{ CombineRgn(h, op.a, op.b, op.mode); }
	Region(const RECT *r, int n);
	~Region()								{ Destroy(); }

	Region&	operator=(const RECT &rect)		{ SetRectRgn(h, rect.left, rect.top, rect.right, rect.bottom); return *this; }
	Region&	operator=(const RegionOp &op)	{ CombineRgn(h, op.a, op.b, op.mode); return *this; }
	Region&	operator+=(const POINT &pt)		{ OffsetRgn(h, pt.x, pt.y); return *this; }
	Region&	operator&=(const Region &b)		{ CombineRgn(h, h, b, RGN_AND); return *this; }
	Region&	operator|=(const Region &b)		{ CombineRgn(h, h, b, RGN_OR); return *this; }
	Region&	operator^=(const Region &b)		{ CombineRgn(h, h, b, RGN_XOR); return *this; }
	Region&	operator-=(const Region &b)		{ CombineRgn(h, h, b, RGN_DIFF); return *this; }

	bool	operator==(HRGN b)		const	{ return !!EqualRgn(h, b); }
	bool	Test(const POINT &pt)	const	{ return !!PtInRegion(h, pt.x, pt.y); }
	bool	Test(const RECT &r)		const	{ return !!RectInRegion(h, &r); }

	Rect	GetRect()				const	{ Rect r; GetRgnBox(h, &r); return r; }
	size_t	GetDataSize()			const	{ return GetRegionData(h, 0, NULL); }
	size_t	GetData(RGNDATA *d, uint32 size) const { return GetRegionData(h, size, d); }
	//ExtCreateRegion  Creates a region from the specified region and transformation data.
};

//-----------------------------------------------------------------------------
//	ImageList
//-----------------------------------------------------------------------------

class ImageList : public H<HIMAGELIST> {
public:
	static bool	Draw(IMAGELISTDRAWPARAMS *p)	{ return !!ImageList_DrawIndirect(p); }
	static ImageList	Load(const char *fn, int w, int grow = 0, Colour mask = Colour::none, uint32 flags = 0)				{ return ImageList_LoadImageA(0, fn, w, grow, mask, IMAGE_BITMAP, flags | LR_LOADFROMFILE); }
	static ImageList	Load(HINSTANCE hInst, ID id, int w, int grow = 0, Colour mask = Colour::none, uint32 flags = 0)		{ return ImageList_LoadImageA(hInst, id, w, grow, mask, IMAGE_BITMAP, flags); }
	static ImageList	Load(ID id, int w, int grow = 0, Colour mask = Colour::none, uint32 flags = 0)						{ return ImageList_LoadImageA(NULL, id, w, grow, mask, IMAGE_BITMAP, flags); }
	static ImageList	Create(int cx, int cy, uint32 flags, int n, int grow = 0)											{ return ImageList_Create(cx, cy, flags, n, grow); }
	static ImageList	Create(const POINT &size, uint32 flags, int n, int grow = 0)										{ return ImageList_Create(size.x, size.y, flags, n, grow); }
	static ImageList	CreateLargeIcons(uint32 flags, int n, int grow = 0)													{ return ImageList_Create(SystemMetrics::IconWidth(), SystemMetrics::IconHeight(), flags, n, grow); }
	static ImageList	CreateSmallIcons(uint32 flags, int n, int grow = 0)													{ return ImageList_Create(SystemMetrics::SmallIconWidth(), SystemMetrics::SmallIconHeight(), flags, n, grow); }

	ImageList()									{}
	ImageList(HIMAGELIST h) : H<HIMAGELIST>(h)	{}
	ImageList(HINSTANCE hInst, ID id, int w, UINT flags = 0, int grow = 0, Colour mask = Colour::none)	: H<HIMAGELIST>(ImageList_LoadImageA(GetInstance(hInst), id, w, grow, mask, IMAGE_BITMAP, flags))	{}
	ImageList(ID id, int w, UINT flags = 0, int grow = 0, Colour mask = Colour::none)					: H<HIMAGELIST>(ImageList_LoadImageA(GetDefaultInstance(), id, w, grow, mask, IMAGE_BITMAP, flags))	{}
	ImageList(const char *fn, int w, UINT flags = 0, int grow = 0, Colour mask = Colour::none)			: H<HIMAGELIST>(ImageList_LoadImageA(0, fn, w, grow, mask, IMAGE_BITMAP, flags | LR_LOADFROMFILE))	{}
	ImageList(int cx, int cy, uint32 flags, int n, int grow = 0)										: H<HIMAGELIST>(ImageList_Create(cx, cy, flags, n, grow))											{}
	ImageList(const POINT &size, uint32 flags, int n, int grow = 0)										: H<HIMAGELIST>(ImageList_Create(size.x, size.y, flags, n, grow))									{}

	void		Destroy()									{ ImageList_Destroy(h); h = 0; }
	ImageList	Dup()								const	{ return ImageList_Duplicate(h); }

	int			Count()								const	{ return ImageList_GetImageCount(h); }
	bool		SetCount(uint32 n)					const	{ return !!ImageList_SetImageCount(h, n); }
	Point		GetIconSize()						const	{ Point p; ImageList_GetIconSize(h, (int*)&p.x, (int*)&p.y); return p; }
	bool		SetIconSize(const POINT &p)			const	{ return !!ImageList_SetIconSize(h, p.x, p.y); }

	int			Add(HBITMAP hbm, HBITMAP hmask = 0)	const	{ return ImageList_Add(h, hbm, hmask); }
	int			Add(HBITMAP hbm, Colour mask)		const	{ return ImageList_AddMasked(h, hbm, mask); }
	int			Add(HICON hicon)					const	{ return ImageList_AddIcon(h, hicon); }
	int			ScaleAdd(const Bitmap &bm)			const	{ return Add(bm.ScaledTo(GetIconSize())); }

	int			Replace(int i, HICON hicon)			const	{ return ImageList_ReplaceIcon(h, i, hicon); }
	bool		Replace(int i, HBITMAP hbm, HBITMAP hmask = 0) const { return !!ImageList_Replace(h, i, hbm, hmask); }
	bool		Remove(int i)						const	{ return !!ImageList_Remove(h, i); }
	bool		RemoveAll()							const	{ return !!ImageList_Remove(h, -1); }
	Icon		GetIcon(int i, UINT style = 0)		const	{ return ImageList_GetIcon(h, i, style); }
	Rect		GetRect(int i)						const	{ IMAGEINFO p; ImageList_GetImageInfo(h, i, &p); return p.rcImage; }

	Colour		SetBackground(Colour c)				const	{ return Colour(ImageList_SetBkColor(h, c)); }
	Colour		GetBackground()						const	{ return Colour(ImageList_GetBkColor(h)); }
	bool		SetOverlay(int im, int ov)			const	{ return !!ImageList_SetOverlayImage(h, im, ov);}
/*
	bool		Draw(int i, HDC hdc, int x, int y, UINT style = 0) {
		return !!ImageList_Draw(h, i, hdc, x, y, style);
	}
	bool		Draw(int i, HDC hdc, int x, int y, int dx, int dy, COLORREF bg, COLORREF fg, UINT style = 0) {
		return !!ImageList_DrawEx(h, i, hdc, x, y, dx, dy, bg, fg, style);
	}
*/
	bool		Copy(int d, HIMAGELIST hIml2, int i, UINT flags = 0) const {
		return !!ImageList_Copy(h, d, hIml2, i, flags);
	}
	ImageList	Merge(int i1, HIMAGELIST hIml2, int i2, int x, int y) const {
		return ImageList_Merge(h, i1, hIml2, i2, x, y);
	}
	ImageList	ScaledTo(const POINT &newsize) const;

	bool		SetDragCursor(int i, const POINT &hotspot)	{ return !!ImageList_SetDragCursorImage(h, i, hotspot.x, hotspot.y); }
	bool		DragBegin(int i, const POINT &hotspot)		{ return !!ImageList_BeginDrag(h, i, hotspot.x, hotspot.y); }

	static void	DragEnd()									{ ImageList_EndDrag(); }
	static bool	DragMove(const POINT &pos)					{ return !!ImageList_DragMove(pos.x, pos.y); }
	static bool	DragEnter(HWND hWnd, const POINT &pos)		{ return !!ImageList_DragEnter(hWnd, pos.x, pos.y); }
	static bool	DragLeave(HWND hWnd)						{ return !!ImageList_DragLeave(hWnd); }
	static bool	DragShow(bool show)							{ return !!ImageList_DragShowNolock(show); }
	static ImageList GetDragImage(POINT *pt, POINT *hotspot) { return ImageList_GetDragImage(pt, hotspot); }
};

typedef int	ImageListBitmap;

//-----------------------------------------------------------------------------
//	DeviceContext
//-----------------------------------------------------------------------------

struct BlendFunction : BLENDFUNCTION {
	BlendFunction(uint8 alpha) {
		BlendOp				= AC_SRC_OVER;
		BlendFlags			= 0;
		SourceConstantAlpha	= alpha;
		AlphaFormat			= AC_SRC_ALPHA;
	}
};

struct TextMetric :	TEXTMETRIC {
	Point		AverageSize()	const { return Point(tmAveCharWidth, tmHeight); }
	uint32		Effects()		const { return (tmItalic ? CFE_ITALIC : 0) | (tmUnderlined ? CFE_UNDERLINE : 0) | (tmStruckOut ? CFE_STRIKEOUT : 0); }
};

class DeviceContextSave;

class DeviceContext {
protected:
	HDC	hDC;

	struct Getter {
		HDC			hDC;
		Getter(HDC hDC) : hDC(hDC) {}
		operator HBITMAP()	const { return (HBITMAP)GetCurrentObject(hDC, OBJ_BITMAP); }
		operator HBRUSH()	const { return (HBRUSH)GetCurrentObject(hDC, OBJ_BRUSH); }
		operator HFONT()	const { return (HFONT)GetCurrentObject(hDC, OBJ_FONT); }
		operator HPEN()		const { return (HPEN)GetCurrentObject(hDC, OBJ_PEN); }
	};

	struct Object {
		HGDIOBJ		h;
		Object(HGDIOBJ h) : h(h) {}
		operator HBITMAP()	const { return (HBITMAP)h; }
		operator HBRUSH()	const { return (HBRUSH)h; }
		operator HFONT()	const { return (HFONT)h; }
		operator HPEN()		const { return (HPEN)h; }
	};

	struct PathBracket {
		HDC			hDC;
		PathBracket(HDC hDC) : hDC(hDC)	{ ::BeginPath(hDC); }
		~PathBracket()						{ AbortPath(hDC); }
		bool		End()			const	{ return !!::EndPath(hDC); }
		bool		Close()			const	{ return !!CloseFigure(hDC); }
	};
	struct Path {
		HDC			hDC;
		Path(HDC hDC) : hDC(hDC) {}
		operator HRGN()				const	{ return PathToRegion(hDC); }
		PathBracket	Begin()			const	{ return hDC; }
//		bool		GetPath()		const	{ return !!GetPath(hDC); }
		bool		Flatten()		const	{ return !!FlattenPath(hDC); }
		bool		Widen()			const	{ return !!WidenPath(hDC); }
		bool		Fill()			const	{ return !!FillPath(hDC); }
		bool		Stroke()		const	{ return !!StrokePath(hDC); }
		bool		StrokeAndFill()	const	{ return !!StrokeAndFillPath(hDC); }
	};
	struct Clip {
		enum STATE {
			REGION_NULL		= NULLREGION,		// Region is empty.
			REGION_SIMPLE	= SIMPLEREGION,		//Region is a single rectangle.
			REGION_COMPLEX	= COMPLEXREGION,	//Region is more than one rectangle.
			REGION_ERROR	= ERROR,			// An error occurred.
		};
		HDC			hDC;
		Clip(HDC hDC) : hDC(hDC) {}
		STATE	operator&=(const RECT &r)	const	{ return (STATE)IntersectClipRect(hDC, r.left, r.top, r.right, r.bottom); }
		STATE	operator-=(const RECT &r)	const	{ return (STATE)ExcludeClipRect(hDC, r.left, r.top, r.right, r.bottom); }
		STATE	operator+=(const POINT &pt)	const	{ return (STATE)OffsetClipRgn(hDC, pt.x, pt.y); }

		STATE	operator=(Region hrgn)		const	{ return (STATE)ExtSelectClipRgn(hDC, hrgn, RGN_COPY); }
		STATE	operator&=(Region hrgn)		const	{ return (STATE)ExtSelectClipRgn(hDC, hrgn, RGN_AND); }
		STATE	operator|=(Region hrgn)		const	{ return (STATE)ExtSelectClipRgn(hDC, hrgn, RGN_OR); }
		STATE	operator^=(Region hrgn)		const	{ return (STATE)ExtSelectClipRgn(hDC, hrgn, RGN_XOR); }
		STATE	operator-=(Region hrgn)		const	{ return (STATE)ExtSelectClipRgn(hDC, hrgn, RGN_DIFF); }

		STATE	operator=(Path)				const	{ return (STATE)SelectClipPath(hDC, RGN_COPY); }
		STATE	operator&=(Path)			const	{ return (STATE)SelectClipPath(hDC, RGN_AND); }
		STATE	operator|=(Path)			const	{ return (STATE)SelectClipPath(hDC, RGN_OR); }
		STATE	operator^=(Path)			const	{ return (STATE)SelectClipPath(hDC, RGN_XOR); }
		STATE	operator-=(Path)			const	{ return (STATE)SelectClipPath(hDC, RGN_DIFF); }
	};
	struct Caps {
		HDC			hDC;
		Caps(HDC hDC) : hDC(hDC) {}
		int		Get(int i)			const { return GetDeviceCaps(hDC, i); }
		int		DriverVersion()		const { return Get(DRIVERVERSION); }
		int		Technology()		const { return Get(TECHNOLOGY); }
		int		HorzSize()			const { return Get(HORZSIZE); }
		int		VertSize()			const { return Get(VERTSIZE); }
		int		HorzRes()			const { return Get(HORZRES); }
		int		VertRes()			const { return Get(VERTRES); }
		int		BitsPixel()			const { return Get(BITSPIXEL); }
		int		Planes()			const { return Get(PLANES); }
		int		NumBrushes()		const { return Get(NUMBRUSHES); }
		int		NumPens()			const { return Get(NUMPENS); }
		int		NumMarkers()		const { return Get(NUMMARKERS); }
		int		NumFonts()			const { return Get(NUMFONTS); }
		int		NumColors()			const { return Get(NUMCOLORS); }
		int		PDeviceSize()		const { return Get(PDEVICESIZE); }
		int		CurveCaps()			const { return Get(CURVECAPS); }
		int		LineCaps()			const { return Get(LINECAPS); }
		int		PolygonalCaps()		const { return Get(POLYGONALCAPS); }
		int		TextCaps()			const { return Get(TEXTCAPS); }
		int		ClipCaps()			const { return Get(CLIPCAPS); }
		int		RasterCaps()		const { return Get(RASTERCAPS); }
		int		AspectX()			const { return Get(ASPECTX); }
		int		AspectY()			const { return Get(ASPECTY); }
		int		AspectXY()			const { return Get(ASPECTXY); }
		int		LogPixelsX()		const { return Get(LOGPIXELSX); }
		int		LogPixelsY()		const { return Get(LOGPIXELSY); }
		int		SizePalette()		const { return Get(SIZEPALETTE); }
		int		NumReserved()		const { return Get(NUMRESERVED); }
		int		ColorRes()			const { return Get(COLORRES); }
// Printing related DeviceCaps. These replace the appropriate Escapes
		int		PhysicalWidth()		const { return Get(PHYSICALWIDTH); }
		int		PhysicalHeight()	const { return Get(PHYSICALHEIGHT); }
		int		PhysicalOffsetX()	const { return Get(PHYSICALOFFSETX); }
		int		PhysicalOffsetY()	const { return Get(PHYSICALOFFSETY); }
		int		ScalingFactorX()	const { return Get(SCALINGFACTORX); }
		int		ScalingFactorY()	const { return Get(SCALINGFACTORY); }
// Display driver specific
		int		VRefresh()			const { return Get(VREFRESH); }
		int		DesktopVertRes()	const { return Get(DESKTOPVERTRES); }
		int		DesktopHorzRes()	const { return Get(DESKTOPHORZRES); }
		int		BltAlignment()		const { return Get(BLTALIGNMENT); }
// Combos
		Point	Size()				const { return Point(HorzSize(), VertSize()); }
		Point	LogPixels()			const { return Point(LogPixelsX(), LogPixelsY()); }
		Point	PhysicalSize()		const { return Point(PhysicalWidth(), PhysicalHeight()); }
		Point	PhysicalOffset()	const { return Point(PhysicalOffsetX(), PhysicalOffsetY()); }
		Point	ScalingFactor()		const { return Point(ScalingFactorX(), ScalingFactorY()); }
		Point	DesktopRes()		const { return Point(DesktopHorzRes(), DesktopVertRes()); }
// Scaling
		template<int I> int	PerInchX(int x)		const { return x * I / LogPixelsX(); }
		template<int I> int	PerInchY(int y)		const { return y * I / LogPixelsY(); }
		int		PixelScaleX(int x)				const { return x * LogPixelsX() / 96; }
		int		PixelScaleY(int y)				const { return y * LogPixelsY() / 96; }
		Point	PixelScale(const POINT &p)		const { return Point(PixelScaleX(p.x), PixelScaleY(p.y)); }
		Rect	PixelScale(const RECT &p)		const { return Rect(PixelScale(((POINT*)&p)[0]), PixelScale(((POINT*)&p)[1])); }
		int		PixelUnScaleX(int x)			const { return x * 96 / LogPixelsX(); }
		int		PixelUnScaleY(int y)			const { return y * 96 / LogPixelsY(); }
		Point	PixelUnScale(const POINT &p)	const { return Point(PixelUnScaleX(p.x), PixelUnScaleY(p.y)); }
		Rect	PixelUnScale(const RECT &p)		const { return Rect(PixelUnScale(((POINT*)&p)[0]), PixelUnScale(((POINT*)&p)[1])); }
	};

public:
	static DeviceContext	Screen()		{ return GetDC(0); }
	static Caps				ScreenCaps()	{ return GetDC(0); }

	DeviceContext()								: hDC(0)	{}
	DeviceContext(HDC hDC)						: hDC(hDC)	{}
	DeviceContext(HWND hWnd)					: hDC(GetDC(hWnd))	{}
	DeviceContext(HWND hWnd, PAINTSTRUCT &ps)	: hDC(BeginPaint(hWnd, &ps))	{}
	operator HDC() const	{ return hDC; }

	void			Destroy()						{ DeleteDC(hDC); hDC = 0; }

	Caps			Caps()							const { return hDC; }
	Getter			Current()						const { return hDC; }
	template<typename T> T	Current()				const { return (T)Current(); }
	template<typename T> T	Select(T t)				const { return (T)Object(SelectObject(hDC, t)); }
	template<typename T> const DeviceContext&	SelectContinue(T t)	const { SelectObject(hDC, t); return *this; }
	template<typename T> DeviceContextSave		SelectSave(T t)		const;

	int				Push()							const { return SaveDC(hDC); }
	bool			Pop()							const { return !!RestoreDC(hDC, -1); }
	bool			Restore(int i)					const { return !!RestoreDC(hDC, i); }
	DeviceContext	Compatible()					const { return CreateCompatibleDC(hDC); }
	Rect			GetClipBox()					const { Rect r; ::GetClipBox(hDC, &r); return r; }
	bool			SetAdvanced(bool a = true)		const { return SetGraphicsMode(hDC, a ? GM_ADVANCED : GM_COMPATIBLE) == GM_ADVANCED; }
	bool			ResetTransform()				const { return !!ModifyWorldTransform(hDC, 0, MWT_IDENTITY); }
	bool			SetTransform(const XFORM &x)	const { return !!SetWorldTransform(hDC, &x); }
	bool			PreTransform(const XFORM &x)	const { return !!ModifyWorldTransform(hDC, &x, MWT_LEFTMULTIPLY); }
	bool			PostTransform(const XFORM &x)	const { return !!ModifyWorldTransform(hDC, &x, MWT_RIGHTMULTIPLY); }
	Point			ToDeviceCoords(const POINT &p)	const { Point p2(p); LPtoDP(hDC, &p2, 1); return p2; }

	// rects
	bool	Fill(const RECT &rect, Brush hbr)		const { return !!::FillRect(hDC, &rect, hbr); }
	bool	Fill(const RECT &rect, DWORD syscol)	const { return !!::FillRect(hDC, &rect, (HBRUSH)intptr_t(syscol + 1)); }
	bool	Fill(const RECT &rect, Colour::col col)	const { return !!::FillRect(hDC, &rect, Brush(col)); }
	bool	Fill(const RECT &rect, Colour col)		const { return !!::FillRect(hDC, &rect, Brush(col)); }
	bool	FrameRect(const RECT &rect, HBRUSH hbr)	const { return !!::FrameRect(hDC, &rect, hbr); }
	bool	InvertRect(const RECT &rect)			const { return !!::InvertRect(hDC, &rect); }
	bool	FocusRect(const RECT &rect)				const { return !!::DrawFocusRect(hDC, &rect); }
	bool	DrawEdge(const RECT &rect, uint32 edge, uint32 flags) const {
		RECT rect2 = rect; return !!::DrawEdge(hDC, &rect2, edge, flags);
	}

	// lines/curves
	bool	MoveTo(int x, int y, Point *out = 0)	const { return !!::MoveToEx(hDC, x, y, out); }
	bool	MoveTo(const POINT &p, Point *out = 0)	const { return !!::MoveToEx(hDC, p.x, p.y, out); }
	bool	LineTo(int x, int y)					const { return !!::LineTo(hDC, x, y); }
	bool	LineTo(const POINT &p)					const { return !!::LineTo(hDC, p.x, p.y); }
	bool	PolyBezierTo(const POINT *pts, int n)	const { return !!::PolyBezierTo(hDC, pts, n); }
	bool	Chord(const RECT &rect, const POINT &start, const POINT &end) const {
		return !!::Chord(hDC, rect.left, rect.top, rect.right, rect.bottom, start.x, start.y, end.x, end.y);
	}

	// shapes
	bool Ellipse(const RECT &rect)										const { return !!::Ellipse(hDC, rect.left, rect.top, rect.right, rect.bottom); }
	bool Pie(const RECT &rect, const POINT &start, const POINT &end)	const { return !!::Pie(hDC, rect.left, rect.top, rect.right, rect.bottom, start.x, start.y, end.x, end.y); }
	bool Polygon(Point *pts, int n)										const { return !!::Polygon(hDC, pts, n); }
	bool PolyPolygon(Point *pts, int *counts, int n)					const { return !!::PolyPolygon(hDC, pts, counts, n); }
	bool Rectangle(const RECT &rect)									const { return !!::Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom); }
	bool RoundRect(const RECT &rect, const POINT &curve)				const { return !!::RoundRect(hDC, rect.left, rect.top, rect.right, rect.bottom, curve.x, curve.y); }

	// icons
	bool DrawIcon(HICON i, int x, int y)								const { return !!::DrawIcon(hDC, x, y, i); }
	bool DrawIcon(HICON i, const POINT &pt)								const { return !!::DrawIcon(hDC, pt.x, pt.y, i); }
	bool DrawIcon(HICON i, int x, int y, int w, int h, int frame = 0)	const { return !!::DrawIconEx(hDC, x, y, i, w, h, frame, NULL, 0); }
	bool DrawIcon(HICON i, const RECT &rect, int frame = 0)				const { return !!::DrawIconEx(hDC, rect.left, rect.top, i, rect.right - rect.left, rect.bottom - rect.top, frame, NULL, DI_NORMAL); }

	// imagelists
	bool DrawImage(HIMAGELIST h, int i, int x, int y, UINT style = 0) const {
		return !!ImageList_Draw(h, i, hDC, x, y, style);
	}
	bool DrawImage(HIMAGELIST h, int i, int x, int y, int dx, int dy, Colour bg, Colour fg, UINT style = 0) const {
		return !!ImageList_DrawEx(h, i, hDC, x, y, dx, dy, bg, fg, style);
	}

	// blits
	int StretchMode(int mode) const {
		return !!SetStretchBltMode(hDC, mode);
	}
	bool Blit(HDC hSrc, const RECT &src, const POINT &dest, DWORD rop = SRCCOPY) const {
		return !!BitBlt(hDC, dest.x, dest.y, src.right - src.left, src.bottom - src.top, hSrc, src.left, src.top, rop);
	}
	bool Blit(HDC hSrc, const POINT &src, const RECT &dest, DWORD rop = SRCCOPY) const {
		return !!BitBlt(hDC, dest.left, dest.top, dest.right - dest.left, dest.bottom - dest.top, hSrc, src.x, src.y, rop);
	}
	bool Blit(HDC hSrc, const RECT &src, const RECT &dest, DWORD rop = SRCCOPY) const {
		return !!StretchBlt(hDC, dest.left, dest.top, dest.right - dest.left, dest.bottom - dest.top, hSrc, src.left, src.top, src.right - src.left, src.bottom - src.top, rop);
	}
	bool BlitAlpha(HDC hSrc, const RECT &src, const RECT &dest, BlendFunction fn = 0xff) const {
		return !!GdiAlphaBlend(hDC, dest.left, dest.top, dest.right - dest.left, dest.bottom - dest.top, hSrc, src.left, src.top, src.right - src.left, src.bottom - src.top, fn);
	}
	bool BlitAlpha(HDC hSrc, const RECT &src, const POINT &dest, BlendFunction fn = 0xff) const {
		return !!GdiAlphaBlend(hDC, dest.x, dest.y, src.right - src.left, src.bottom - src.top, hSrc, src.left, src.top, src.right - src.left, src.bottom - src.top, fn);
	}
	bool BlitAlpha(HDC hSrc, const POINT &src, const RECT &dest, BlendFunction fn = 0xff) const {
		return !!GdiAlphaBlend(hDC, dest.left, dest.top, dest.right - dest.left, dest.bottom - dest.top, hSrc, src.x, src.y, dest.right - dest.left, dest.bottom - dest.top, fn);
	}
	// regions
	bool		SetWinding(bool winding)				const	{ return !!SetPolyFillMode(hDC, winding ? WINDING : ALTERNATE); }
	bool		GetWinding()							const	{ return GetPolyFillMode(hDC) == WINDING; }
	bool		Fill(HRGN r)							const	{ return !!PaintRgn(hDC, r); }
	bool		Fill(HRGN r, HBRUSH b)					const	{ return !!FillRgn(hDC, r, b); }
	bool		Frame(HRGN r, HBRUSH b, int rx, int ry)	const	{ return !!FrameRgn(hDC, r, b, rx, ry); }
	bool		Invert(HRGN r)							const	{ return !!InvertRgn(hDC, r); }

	// paths
	Path		Path()									const	{ return hDC; }
	float		GetMiterLimit()							const	{ float f; return ::GetMiterLimit(hDC, &f) ? f : 0; }
	float		SetMiterLimit(float f)					const	{ return ::SetMiterLimit(hDC, f, &f) ? f : 0; }

	// clipping
	Clip		Clip()									const	{ return hDC; }
	bool		Visible(const POINT &pt)				const	{ return !!PtVisible(hDC, pt.x, pt.y); }
	bool		Visible(const RECT &r)					const	{ return !!RectVisible(hDC, &r); }

	// text
	bool		SetOpaque(bool opaque)					const	{ return !!SetBkMode(hDC, opaque ? OPAQUE : TRANSPARENT); }
	Colour		SetBackground(Colour col)				const	{ return Colour(::SetBkColor(hDC, col)); }
	Colour		SetTextColour(Colour col)				const	{ return Colour(::SetTextColor(hDC, col)); }
	uint32		SetTextAlign(uint32 mode)				const	{ return ::SetTextAlign(hDC, mode); }
	Colour		GetBackground()							const	{ return Colour(::GetBkColor(hDC)); }
	Colour		GetTextColour()							const	{ return Colour(::GetTextColor(hDC)); }
	uint32		GetTextAlign()							const	{ return ::GetTextAlign(hDC); }
	TextMetric	GetTextMetrics()						const	{ TextMetric tm; ::GetTextMetrics(hDC, &tm); return tm; }

	bool TextOut(const char *s, size_t n)				const	{ return !!::TextOutA(hDC, 0, 0, s, int(n)); }
	bool TextOut(const wchar_t *s, size_t n)			const	{ return !!::TextOutW(hDC, 0, 0, s, int(n)); }
	bool TextOut(const string_param &s)					const	{ return !!::TextOutA(hDC, 0, 0, s, s.size32()); }
	bool TextOut16(const string_param16 &s)				const	{ return !!::TextOutW(hDC, 0, 0, s, s.size32()); }

	bool TextOut(const POINT &p, const char *s, size_t n)		{ return !!::TextOutA(hDC, p.x, p.y, s, int(n)); }
	bool TextOut(const POINT &p, const wchar_t *s, size_t n)	{ return !!::TextOutW(hDC, p.x, p.y, s, int(n)); }
	bool TextOut(const POINT &p, const string_param &s)			{ return !!::TextOutA(hDC, p.x, p.y, s, s.size32()); }
	bool TextOut16(const POINT &p, const string_param16 &s)		{ return !!::TextOutW(hDC, p.x, p.y, s, s.size32()); }

	bool DrawText(const RECT &rect, int format, const char *s, size_t n = -1) {
		return !!::DrawTextA(hDC, s, (int)n, const_cast<RECT*>(&rect), format);
	}
	bool DrawText(const RECT &rect, int format, const wchar_t *s, size_t n = -1) {
		return !!::DrawTextW(hDC, s, (int)n, const_cast<RECT*>(&rect), format);
	}
	Point		GetTextExtent(const char *s, size_t n) const {
		SIZE	size = {0, 0};
		GetTextExtentPoint32A(hDC, s, DWORD(n), &size);
		return size;
	}
	Point		GetTextExtent(const wchar_t *s, size_t n) const {
		SIZE	size = {0, 0};
		GetTextExtentPoint32W(hDC, s, DWORD(n), &size);
		return size;
	}
	Point		GetTextExtent(const char *s)		const	{ return GetTextExtent(s, string_len(s)); }
	Point		GetTextExtent(const wchar_t *s)		const	{ return GetTextExtent(s, string_len(s)); }
};

class DeviceContextSave : public DeviceContext {
	HGDIOBJ	save;
public:
	DeviceContextSave(DeviceContext dc, HGDIOBJ save) : DeviceContext(dc), save(save) {}
	~DeviceContextSave() { SelectObject(hDC, save); }
};

template<typename T> DeviceContextSave DeviceContext::SelectSave(T t) const {
	return DeviceContextSave(*this, SelectObject(hDC, t));
}

class DeviceContextPaint : public DeviceContext, public PAINTSTRUCT {
	HWND	hWnd;
public:
	DeviceContextPaint(HWND hWnd) : DeviceContext(hWnd, *this), hWnd(hWnd)	{}
	~DeviceContextPaint()				{ EndPaint(hWnd, this); }
	const Rect&	GetDirtyRect() const	{ return (const Rect&)rcPaint; }
};

struct BitmapScaler {
	Point			size1,	size2;
	void			*data1, *data2;
	DeviceContext	dc1,	dc2;
	Bitmap			old1,	old2;
	Bitmap			bm2;

	BitmapScaler(const Bitmap &bm1, void *data1, const POINT &size1, const Bitmap &bm2, void *data2, const POINT &size2);
	~BitmapScaler();
	void			Scale();
};

inline ImageList ImageList::ScaledTo(const POINT &newsize) const {
	if (!h)
		return *this;

	Point	oldsize	= GetIconSize();
	if (oldsize == newsize)
		return *this;

	void			*data1, *data2;
	Bitmap			bm1		= Bitmap::CreateDIBSection(oldsize, 32, 1, &data1);
	Bitmap			bm2		= Bitmap::CreateDIBSection(newsize, 32, 1, &data2);

	BitmapScaler	scaler(bm1, data1, oldsize, bm2, data2, newsize);

	int				n		= Count();
	ImageList		images2(newsize, LR_CREATEDIBSECTION, 0, n);

	for (int i = 0; i < n; i++) {
		scaler.dc1.DrawImage(*this, i, 0, 0);
		scaler.Scale();
		images2.Add(scaler.bm2);
	}

	bm1.Destroy();
	bm2.Destroy();
	return images2;
}

//-----------------------------------------------------------------------------
//	Font
//-----------------------------------------------------------------------------

class Font : public H<HFONT> {
	template<typename T, typename C> struct _Params : T {
		_Params()											{ clear(*this); }
		_Params(const T &log) : T(log)						{}
		_Params(string_paramT<C> &&facename, int height)	{ clear(*this); string_copy(T::lfFaceName, facename); T::lfHeight = height; }
		_Params(string_paramT<C> &&desc)					{ clear(*this); Description(desc); }
		_Params(string_paramT<C> &&facename, int height, uint32 effects)  {
			clear(*this);
			string_copy(T::lfFaceName, facename);
			T::lfHeight			= height;
			T::lfItalic			= !!(effects & ITALIC);
			T::lfUnderline		= !!(effects & UNDERLINE);
			T::lfStrikeOut		= !!(effects & STRIKEOUT);
			T::lfWeight			= effects & BOLD		? FW_BOLD : FW_NORMAL;
			T::lfOutPrecision	= effects & TRUETYPE	? OUT_TT_ONLY_PRECIS : OUT_DEFAULT_PRECIS;
		}

		int			Height()			const		{ return T::lfHeight; }
		int			Width()				const		{ return T::lfWidth; }
		int			Escapement()		const		{ return T::lfEscapement; }
		int			Orientation()		const		{ return T::lfOrientation; }
		int			Weight()			const		{ return T::lfWeight; }
		bool		Italic()			const		{ return !!T::lfItalic; }
		bool		Underline()			const		{ return !!T::lfUnderline; }
		bool		StrikeOut()			const		{ return !!T::lfStrikeOut; }
		int			CharSet()			const		{ return T::lfCharSet; }
		int			OutPrecision()		const		{ return T::lfOutPrecision; }
		int			ClipPrecision()		const		{ return T::lfClipPrecision; }
		int			Quality()			const		{ return T::lfQuality; }
		int			PitchAndFamily()	const		{ return T::lfPitchAndFamily; }
		const C*	Name()				const		{ return T::lfFaceName; }
		uint32		Effects()			const		{ return (T::lfItalic ? ITALIC : 0) | (T::lfUnderline ? UNDERLINE : 0) | (T::lfStrikeOut ? STRIKEOUT : 0); }
		int			LogicalHeight()		const		{ return T::lfHeight < 0 ? -T::lfHeight : T::lfHeight - DeviceContext::Screen().SelectContinue(Font(*this)).GetTextMetrics().tmInternalLeading; }
		int			PointSize()			const		{ return DeviceContext::ScreenCaps().PerInchY<72>(LogicalHeight()); }
		int			TwipSize()			const		{ return DeviceContext::ScreenCaps().PerInchY<72 * 20>(LogicalHeight()); }
		bool		Bold()				const		{ return T::lfWeight >= FW_BOLD; }
		fixed_string<256> Description() const;

		_Params&	Height(int height)					{ T::lfHeight			= height;			return *this; }
		_Params&	Width(int width)					{ T::lfWidth			= width;			return *this; }
		_Params&	Escapement(int escapement)			{ T::lfEscapement		= escapement;		return *this; }
		_Params&	Orientation(int orientation)		{ T::lfOrientation		= orientation;		return *this; }
		_Params&	Weight(int weight)					{ T::lfWeight			= weight;			return *this; }
		_Params&	Italic(bool italic)					{ T::lfItalic			= italic;			return *this; }
		_Params&	Underline(bool underline)			{ T::lfUnderline		= underline;		return *this; }
		_Params&	StrikeOut(bool strikeout)			{ T::lfStrikeOut		= strikeout;		return *this; }
		_Params&	CharSet(int charset)				{ T::lfCharSet			= charset;			return *this; }
		_Params&	OutPrecision(int outprecision)		{ T::lfOutPrecision		= outprecision;		return *this; }
		_Params&	ClipPrecision(int clipprecision)	{ T::lfClipPrecision	= clipprecision;	return *this; }
		_Params&	Quality(int quality)				{ T::lfQuality			= quality;			return *this; }
		_Params&	PitchAndFamily(int pitchandfamily)	{ T::lfPitchAndFamily	= pitchandfamily;	return *this; }
		_Params&	Name(const C *name)					{ strcpy(T::lfFaceName, name);				return *this; }
		_Params&	Effects(uint32 e)					{ T::lfItalic = !!(e & ITALIC); T::lfUnderline = !!(e & UNDERLINE); T::lfStrikeOut = !!(e & STRIKEOUT); return *this; }
		_Params&	PointSize(int s)					{ return Height(s * DeviceContext::ScreenCaps().LogPixelsY() / 72); }
		_Params&	TwipSize(int s)						{ return Height(s * DeviceContext::ScreenCaps().LogPixelsY() / (72 * 20)); }
		_Params&	Bold(bool bold)						{ return Weight(bold ? FW_BOLD : FW_NORMAL); }
		_Params&	Description(const C *desc);
	};
public:
	enum {
		BOLD		= CFE_BOLD,
		ITALIC		= CFE_ITALIC,
		UNDERLINE	= CFE_UNDERLINE,
		STRIKEOUT	= CFE_STRIKEOUT,
		//
		TRUETYPE	= 0x100,
	};
	typedef _Params<LOGFONTA, char>		Params;
	typedef _Params<LOGFONTW, char16>	Params16;

	static int	Add(const char *filename, bool priv = false)	{ return AddFontResourceExA(filename, priv ? FR_PRIVATE : 0, 0); }
	static bool	Remove(const char *filename, bool priv = false)	{ return RemoveFontResourceExA(filename, priv ? FR_PRIVATE : 0, 0); }

	static Font		AnsiFixed()		{ return (HFONT)GetStockObject(ANSI_FIXED_FONT); }
	static Font		AnsiVar()		{ return (HFONT)GetStockObject(ANSI_VAR_FONT); }
	static Font		DeviceDefault()	{ return (HFONT)GetStockObject(DEVICE_DEFAULT_FONT); }
	static Font		DefaultGui()	{ return (HFONT)GetStockObject(DEFAULT_GUI_FONT); }	//not recc.
	static Font		OemFixed()		{ return (HFONT)GetStockObject(OEM_FIXED_FONT); }
	static Font		System()		{ return (HFONT)GetStockObject(SYSTEM_FONT); }	//not recc.
	static Params	Caption()		{ return GetNonClientMetrics().lfCaptionFont; }
	static Params	SmallCaption()	{ return GetNonClientMetrics().lfSmCaptionFont; }
	static Params	Menu()			{ return GetNonClientMetrics().lfMenuFont; }
	static Params	Status()		{ return GetNonClientMetrics().lfStatusFont; }
	static Params	Message()		{ return GetNonClientMetrics().lfMessageFont; }

	Font()						{}
	Font(HFONT h)				: H<HFONT>(h)			{}
	Font(const LOGFONTA &log)	: H<HFONT>(CreateFontIndirectA(&log)) {}
	Font(const LOGFONTW &log)	: H<HFONT>(CreateFontIndirectW(&log)) {}
	Font(const char *face, int size, uint32 effects = 0) : H<HFONT>(CreateFontA(-size, 0, 0, 0,
		effects & BOLD		? FW_BOLD	: FW_NORMAL,
		effects & ITALIC	? TRUE		: FALSE,
		effects & UNDERLINE	? TRUE		: FALSE,
		effects & STRIKEOUT	? TRUE		: FALSE,
		DEFAULT_CHARSET,
		effects & TRUETYPE	? OUT_TT_ONLY_PRECIS : OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY,
		FF_DONTCARE,
		face
	)) {}
	Params		GetParams()		const	{ LOGFONTA log; if (!GetObjectA(h, sizeof(LOGFONTA), &log)) clear(log); return log; }
	Params16	GetParams16()	const	{ LOGFONTW log; if (!GetObjectW(h, sizeof(LOGFONTW), &log)) clear(log); return log; }
};

//-----------------------------------------------------------------------------
//	Menu
//-----------------------------------------------------------------------------

class Menu : public H<HMENU> {
	struct _string_getter {
		HMENU	hMenu;
		int		i;
		bool	pos;
		_string_getter(HMENU hMenu, int i, bool pos) : hMenu(hMenu), i(i), pos(pos) {}
		size_t	string_len()						const	{ Item item; return item.Text(nullptr)._Get(hMenu, i, pos) ? (size_t)item.cch + 1 : 0; }
		size_t	string_get(char *s, size_t len)		const	{ Item item; return item.Text(s, uint32(len))._Get(hMenu, i, pos) ? (size_t)item.cch : 0; }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
	uint32			pos(int i)	const				{ return i < 0 ? Count() + 1 + i : i; }

public:
	static const uint32 MIIM_ALL = MIIM_STATE|MIIM_ID|MIIM_SUBMENU|MIIM_CHECKMARKS|MIIM_DATA|MIIM_STRING|MIIM_BITMAP|MIIM_FTYPE;

	class Item : public MENUITEMINFOA {
	public:
		static	Item Separator()					{ return Item().Type(MFT_SEPARATOR); }
		Item()										{ clear(*this); cbSize = sizeof(*this); }
		explicit Item(uint32 mask)					{ clear(*this); cbSize = sizeof(*this); fMask = mask; }
		Item(const char *s, int id)					{ clear(*this); cbSize = sizeof(*this); dwTypeData = const_cast<char*>(s); wID = id; fMask = MIIM_STRING | MIIM_ID; }
		Item(const char *s, int id, uint32 state)	{ clear(*this); cbSize = sizeof(*this); dwTypeData = const_cast<char*>(s); wID = id; fState = state; fMask = MIIM_STRING | MIIM_ID | MIIM_STATE; }
		Item(const char *s, HMENU hMenu)			{ clear(*this); cbSize = sizeof(*this); dwTypeData = const_cast<char*>(s); hSubMenu = hMenu; fMask = MIIM_STRING | MIIM_SUBMENU; }
		Item&	Text(const char *s)					{ dwTypeData = const_cast<char*>(s); fMask |= MIIM_STRING; return *this; }
		Item&	Text(char *s, int len)				{ dwTypeData = s; cch = len; fMask |= MIIM_STRING; return *this; }
		Item&	SubMenu(HMENU hMenu)				{ hSubMenu = hMenu; fMask |= MIIM_SUBMENU; return *this; }
		Item&	Param(const arbitrary &p)			{ dwItemData = p; fMask |= MIIM_DATA; return *this; }
		Item&	Bitmap(Bitmap bm)					{ hbmpChecked = hbmpUnchecked = bm; fMask |= MIIM_CHECKMARKS; return *this; }
		Item&	ID(int id)							{ wID = id; fMask |= MIIM_ID; return *this; }
		Item&	Type(int type)						{ fType = type; fMask |= MIIM_FTYPE; return *this; }
		Item&	State(int state)					{ fState = state; fMask |= MIIM_STATE; return *this; }
		Item&	Check(bool check)					{ return State(check ? (fState | MFS_CHECKED) : (fState & ~MFS_CHECKED)); }

		char*	Text()						const	{ ISO_ASSERT(fMask & MIIM_STRING); return (char*)dwTypeData; }
		HMENU	SubMenu()					const	{ return hSubMenu; }
		arbitrary&	Param()					const	{ return (arbitrary&)dwItemData; }
		int		ID()						const	{ return wID; }
		int		Type()						const	{ return fType; }
		int		State()						const	{ return fState; }

		bool	_Get(HMENU h, int i, bool pos)		{ return !!GetMenuItemInfoA(h, i, pos, this); }
		bool	_GetByID(Menu m, int id)			{ return _Get(m, id, false); }
		bool	_GetByPos(Menu m, int i)			{ return _Get(m, m.pos(i), true); }
		Item&	GetByID(Menu m, int id)				{ _GetByID(m, id); return *this; }
		Item&	GetByPos(Menu m, int i)				{ _GetByPos(m, m.pos(i)); return *this; }
		bool	SetByID(Menu m, int id)		const	{ return !!SetMenuItemInfoA(m, (UINT)id, FALSE, this); }
		bool	SetByPos(Menu m, int i)		const	{ return !!SetMenuItemInfoA(m, m.pos(i), TRUE, this); }
		bool	InsertByID(Menu m, int id)	const	{ return !!InsertMenuItemA(m, (UINT)id, FALSE, this); }
		bool	InsertByPos(Menu m, int i)	const	{ return !!InsertMenuItemA(m, m.pos(i), TRUE, this); }
		bool	AppendTo(Menu m)			const	{ return !!InsertMenuItemA(m, (UINT)-1, TRUE, this); }
	};
	struct Info : MENUINFO {
				Info(uint32 mask = 0)				{ cbSize = sizeof(MENUINFO); fMask = mask; }
		Info&	Get(Menu m)							{ GetMenuInfo(m, this); return *this; }
		bool	Set(Menu m)					const	{ return !!SetMenuInfo(m, this); }
		Info&	Param(const arbitrary &p)			{ dwMenuData = p; fMask |= MIM_MENUDATA; return *this; }
		arbitrary&	Param()					const	{ return (arbitrary&)dwMenuData; }
		Info&	SetStyle(int i)						{ dwStyle |= i; return *this; }
		Info&	ClearStyle(int i)					{ dwStyle &= ~i; return *this; }
	};

	static Menu		Load(HINSTANCE hInst, ID id)	{ return LoadMenuA(hInst, id); }
	static Menu		Load(ID id)						{ return LoadMenuA(NULL, id); }
	static Menu		Create()						{ return CreateMenu(); }
	static Menu		Popup()							{ return CreatePopupMenu(); }

	Menu()							{}
	Menu(HMENU hMenu)			:  H<HMENU>(hMenu)	{}
	Menu(HINSTANCE hInst,ID id)	:  H<HMENU>(LoadMenuA(hInst, id))	{}
	Menu(ID id)					:  H<HMENU>(LoadMenuA(NULL, id))	{}
	template<typename I0, typename I1, typename...I> Menu(I0 i0, I1 i1, I...i)	:  H<HMENU>(CreateMenu()) { AppendMulti(i0, i1, i...); }

	void			Destroy()													{ DestroyMenu(h); h = 0; }
	void			SetStyle(int s)										const	{ Info(MIM_STYLE).Get(*this).SetStyle(s).Set(*this); }
	void			ClearStyle(int s)									const	{ Info(MIM_STYLE).Get(*this).ClearStyle(s).Set(*this); }

	Item			GetItemByID(int id, uint32 mask)					const	{ return Item(mask).GetByID(*this, id); }
	Item			GetItemByPos(int i, uint32 mask)					const	{ return Item(mask).GetByPos(*this, i); }

	string_getter<_string_getter> GetItemTextByID(int id)				const	{ return _string_getter(h, id, false); }
	string_getter<_string_getter> GetItemTextByPos(int i)				const	{ return _string_getter(h, pos(i), true); }

	arbitrary		GetItemParamByID(int id)							const	{ return Item(MIIM_DATA).GetByID(*this, id).Param(); }
	arbitrary		GetItemParamByPos(int i)							const	{ return Item(MIIM_DATA).GetByPos(*this, i).Param(); }
	bool			SetItemParamByID(int id, const arbitrary &p)		const	{ return Item().Param(p).SetByID(*this, id); }
	bool			SetItemParamByPos(int i, const arbitrary &p)		const	{ return Item().Param(p).SetByPos(*this, i); }

	int				GetItemStateByID(int id)							const	{ return GetMenuState(h, id, MF_BYCOMMAND); }
	int				GetItemStateByPos(int i)							const	{ return GetMenuState(h, pos(i), MF_BYPOSITION); }
	int				GetItemID(int i)									const	{ return GetMenuItemID(h, i); }
	Rect			GetItemRect(int i, HWND hWnd = 0)					const	{ Rect r; GetMenuItemRect(hWnd, h, i, &r); return r; }

	Menu			GetSubMenuByPos(int i)								const	{ return ::GetSubMenu(h, i); }
	iso_export Menu	GetSubMenuByID(int id)								const;
	iso_export Menu	GetSubMenuByName(const char *name)					const;

	bool			Separator()											const	{ return !!AppendMenu(h, MF_SEPARATOR, 0, 0); }
	bool			Append(const Item &item)							const	{ return item.AppendTo(*this); }
	bool			Append(text s, int id, uint32 flags = 0)			const	{ return !!AppendMenuA(h, flags | MF_STRING, id, s); }
	bool			Append(text s, HMENU sub, uint32 flags = 0)			const	{ return !!AppendMenuA(h, flags | MF_STRING | MF_POPUP, UINT_PTR(sub), s); }
	bool			Append(HBITMAP b, int id, uint32 flags = 0)			const	{ return !!AppendMenu(h, flags | MF_BITMAP, id, (LPCTSTR)b); }
	iso_export void	Append(const Menu &m)								const;

	const Menu&		AppendMulti()										const	{ return *this; }
	template<typename...I> const Menu& AppendMulti(const Item &i, const I&...items)		const { Append(i); return AppendMulti(items...); }
	template<typename...I> const Menu& AppendMulti(const _none&, const I&...items)		const { Separator(); return AppendMulti(items...); }
	template<typename...I> const Menu& AppendMulti(const Menu &m, const I&...items)		const { Append(m); return AppendMulti(items...); }
	template<typename T, typename...I> const Menu& AppendMulti(const char *s, T t, const I&...items)				const { Append(s, t); return AppendMulti(items...); }
	template<typename T, typename...I> const Menu& AppendMulti(const char *s, T t, long flags, const I&...items)	const { Append(s, t, flags); return AppendMulti(items...); }
	template<typename A, typename B, typename...I> const Menu& AppendMulti(const pair<A, B> &item, const I&...items)const { Append(item.a, item.b); return AppendMulti(items...); }

	bool			InsertByPos(int i, const char *s, int id, uint32 state)			const	{ return Item(s, id, state).InsertByPos(*this, i); }
	bool			InsertByID(int afterid, const char *s, int id, uint32 state)	const	{ return Item(s, id, state).InsertByID(*this, afterid); }
	bool			InsertByPos(int i, const char *s, int id)			const	{ return Item(s, id).InsertByPos(*this, i); }
	bool			InsertByID(int afterid, const char *s, int id)		const	{ return Item(s, id).InsertByID(*this, afterid); }
	bool			InsertByPos(int i, const Item &item)				const	{ return item.InsertByPos(*this, i); }
	bool			InsertByID(int afterid, const Item &item)			const	{ return item.InsertByID(*this, afterid); }
	bool			InsertByPos(int i, const char *s, HMENU sub)		const	{ return Item(s, sub).InsertByPos(*this, i); }
	bool			RemoveByID(int id)									const	{ return !!DeleteMenu(h, id, MF_BYCOMMAND); }
	bool			RemoveByPos(int i)									const	{ return !!DeleteMenu(h, pos(i), MF_BYPOSITION); }
	DWORD			CheckByID(int id, bool check = true)				const	{ return CheckMenuItem(h, id, (check ? MF_CHECKED : MF_UNCHECKED) | MF_BYCOMMAND); }
	DWORD			CheckByPos(int i, bool check = true)				const	{ return CheckMenuItem(h, pos(i),  (check ? MF_CHECKED : MF_UNCHECKED) | MF_BYPOSITION); }
	bool			EnableByID(int id, bool enable = true)				const	{ return !!EnableMenuItem(h, id, (enable ? MF_ENABLED : MF_GRAYED) | MF_BYCOMMAND); }
	bool			EnableByPos(int i, bool enable = true)				const	{ return !!EnableMenuItem(h, pos(i), (enable ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);}

	int				Count()												const	{ return GetMenuItemCount(h); }
	int				Track(HWND hWnd, const POINT &pt, int flags = TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, TPMPARAMS *tpm = NULL) const {
		return TrackPopupMenuEx(h, flags, pt.x, pt.y, hWnd, tpm);
	}

	iso_export int	FindPosition(int id)					const;
	iso_export int	FindPosition(const char *name)			const;
	iso_export int	FindPosition(Menu m)					const;
	iso_export Menu	FindSubMenu(int id)						const;
	iso_export Menu	FindSubMenu(const char *name)			const;
	iso_export void	Radio(int id)							const;
	iso_export void Radio(int id, int id0, int id1)			const;
	iso_export void RadioDirect(int id, int id0, int id1)	const;
	iso_export void RadioByPos(int i, int i0, int i1)		const;

	struct iterator : int_iterator<int> {
		HMENU	h;
		Item	*item;
		int		text_len;

		Item*		get() const {
			if (!item->cch) {
				item->cch = text_len;
				GetMenuItemInfoA(h, i, TRUE, item);
			}
			return item;
		}

		iterator(HMENU h, Item *item, int i) : int_iterator<int>(i), h(h), item(item) { text_len = item->cch; item->cch = 0; }
		iterator&	operator++()	{ item->cch = 0; ++i; return *this; }
		iterator&	operator--()	{ item->cch = 0; --i; return *this; }
		Item*		operator->()	{ return get(); }
		Item&		operator*()		{ return *get(); }
	};
	struct _Items : Item {
		HMENU	h;
		char	text[256];
		_Items(HMENU _h, uint32 mask) : Item(mask), h(_h) { Text(text, 256); }
		iterator begin()	{ return iterator(h, this, 0); }
		iterator end()		{ return iterator(h, this, GetMenuItemCount(h)); }
	};
	_Items	Items(uint32 mask = MIIM_ALL)		const	{ return _Items(h, mask); }
};

inline Menu CheckByID(Menu m, int id, bool check = true) {
	m.CheckByID(id, check);
	return m;
}

typedef virtfunc<void(Control,Menu)>		MenuCallback;
typedef virtfunc<void(Control,Menu::Item)>	MenuItemCallback;

template<typename T> struct MenuCallbackT		: MenuCallback		{ MenuCallbackT()		: MenuCallback(static_cast<T*>(this))		{} };
template<typename T> struct MenuItemCallbackT	: MenuItemCallback	{ MenuItemCallbackT()	: MenuItemCallback(static_cast<T*>(this))	{} };

//-----------------------------------------------------------------------------
//	Keyboard Accelerator
//-----------------------------------------------------------------------------

class Accelerator : public H<HACCEL> {
public:
	struct Key {
		enum FLAG : uint8 {
			VK		= 0,
			ASCII	= 1,
			NOINVERT= 2,
			SHIFT	= 4,
			CTRL	= 8,
			ALT		= 16,
		};
		friend FLAG	operator|(FLAG a, FLAG b) { return (FLAG)(uint8(a) | uint8(b)); }
		uint16	k;
		FLAG	f;
		Key(uint16 k, FLAG f = VK) : k(k), f(f) {}
		explicit operator bool() const { return !!k; }
		friend string_accum& operator<<(string_accum &a, Key v);
	};
	struct Entry : ACCEL {
		Entry(int id, Key key) : ACCEL{key.f ^ Key::ASCII, key.k, id} {}
	};

	struct Builder : dynamic_array<Entry> {
		void		Append(Menu m, const char *s, int id, Accelerator::Key key = 0) {
			if (key) {
				emplace_back(id, key);
				m.Append(format_string(s) << '\t' << key, id);
			} else {
				m.Append(s, id);
			}
		}
		void		Append(int id, Accelerator::Key key) {
			emplace_back(id, key);
		}
		operator range<const Entry*>()	const { return {begin(), end()}; }
	};

	static Accelerator	Load(HINSTANCE hInst, ID id)	{ return LoadAcceleratorsA(hInst, id); }
	static Accelerator	Load(ID id)						{ return LoadAcceleratorsA(NULL, id); }

	Accelerator()							{}
	Accelerator(HACCEL h)	: H<HACCEL>(h)	{}
	Accelerator(HINSTANCE hInst, ID id)		: H<HACCEL>(LoadAcceleratorsA(hInst, id))	{}
	Accelerator(ID id)						: H<HACCEL>(LoadAcceleratorsA(NULL, id))	{}
	Accelerator(HINSTANCE hInst, int id)	: H<HACCEL>(LoadAccelerators(hInst, MAKEINTRESOURCE(id)))	{}
	Accelerator(int id)						: H<HACCEL>(Load(id))	{}
	Accelerator(const char *id)				: H<HACCEL>(Load(id))	{}
	Accelerator(const ACCEL *a, int n)		: H<HACCEL>(CreateAcceleratorTable(unconst(a), n))	{}
	Accelerator(const range<const ACCEL*> &a)			: Accelerator(a.begin(), a.size32())	{}
//	Accelerator(const range<const Entry*> &a)			: Accelerator(a.begin(), a.size32())	{}
	template<int N> Accelerator(const ACCEL (&a)[N])	: Accelerator(a, N)	{}
	template<int N> Accelerator(const Entry (&a)[N])	: Accelerator(a, N)	{}

	void		Add(const ACCEL &a);
	void		Add(const ACCEL *a, int n);
	void		Add(const range<const ACCEL*> &a)			{ Add(a.begin(), a.size32()); }
//	void		Add(const range<const Entry*> &a)			{ Add(a.begin(), a.size32()); }
	template<int N> void	Add(const ACCEL (&a)[N])		{ Add(a, N); }
	template<int N> void	Add(const Entry (&a)[N])		{ Add(a, N); }
	void		Add(uint16 key, uint8 flags, uint16 cmd)	{ Add(ACCEL {flags, key, cmd}); }
	Key			GetKey(uint16 cmd) const;

	string_param KeyText(const char *text, uint16 cmd);
	auto		Command(const char *text, uint16 cmd) { return make_pair(KeyText(text, cmd), move(cmd)); }
};

iso_export void SetAccelerator(HWND hWnd, Accelerator a);

//-----------------------------------------------------------------------------
//	Control
//-----------------------------------------------------------------------------

template<typename T> T*	CastByProc(Control c);

class Control {
	struct _extra {
		struct value {
			HWND		hWnd;
			int			i;
			value(HWND hWnd, int i) : hWnd(hWnd), i(i) {}
			template<typename T> operator T()					const { ISO_COMPILEASSERT(sizeof(T) <= sizeof(void*)); return (T)GetWindowLongPtr(hWnd, i); }
			template<typename T> const T& operator=(const T &t)	const { ISO_COMPILEASSERT(sizeof(T) <= sizeof(void*)); SetWindowLongPtr(hWnd, i, (LONG_PTR)t); return t; }
		};
		HWND		hWnd;
		value		operator[](int i)		const	{ return value(hWnd, i); }
	};
	template<int I> struct arb_ptr {
		HWND	hWnd;
		template<typename T> operator T*()	const	{ return (T*)GetWindowLongPtr(hWnd, I); }
		void operator=(const void *t)		const	{ SetWindowLongPtr(hWnd, I, (LONG_PTR)t); }
	};
	struct _class {
		template<int I, typename T> struct value {
			HWND	hWnd;
			T		get()					const	{ return (T)GetClassLongPtr(hWnd, I); }
			operator T()					const	{ return get(); }
			void	operator=(const T &t)	const	{ SetClassLongPtr(hWnd, I, (LONG_PTR)t); }
			void	operator|=(const T &t)	const	{ *this = get() | t; }
			void	operator&=(const T &t)	const	{ *this = get() & t; }
			void	operator^=(const T &t)	const	{ *this = get() ^ t; }
			bool	operator!()				const	{ return !get(); }
		};
		union {
		HWND								hWnd;
		value<GCW_ATOM,			ATOM>		atom;
		value<GCL_CBCLSEXTRA,	uint32>		cextra;
		value<GCL_CBWNDEXTRA,	uint32>		wextra;
		value<GCLP_HBRBACKGROUND,HBRUSH>	background;
		value<GCLP_HCURSOR,		HCURSOR>	cursor;
		value<GCLP_HICON,		HICON>		icon;
		value<GCLP_HICONSM,		HICON>		small_icon;
		value<GCLP_HMODULE,		HMODULE>	hmodule;
		value<GCLP_MENUNAME,	ID>			menu;
		value<GCL_STYLE,		uint32>		style;
		value<GCLP_WNDPROC,		WNDPROC>	wndproc;
		};
		fixed_string<256>	name()	const	{ fixed_string<256> cls; RealGetWindowClassA(hWnd, cls, 256); return cls; }
	};

protected:
	typedef Control Base;

public:
	// Window Styles
	enum Style {
		NOSTYLE				= 0x00000000L,
		OVERLAPPED			= 0x00000000L,
		POPUP				= 0x80000000L,
		CHILD				= 0x40000000L,
		MINIMIZE			= 0x20000000L,
		VISIBLE				= 0x10000000L,
		DISABLED			= 0x08000000L,
		CLIPSIBLINGS		= 0x04000000L,
		CLIPCHILDREN		= 0x02000000L,
		MAXIMIZE			= 0x01000000L,
		CAPTION				= 0x00C00000L,
		BORDER				= 0x00800000L,
		DLGFRAME			= 0x00400000L,
		VSCROLL				= 0x00200000L,
		HSCROLL				= 0x00100000L,
		SYSMENU				= 0x00080000L,
		THICKFRAME			= 0x00040000L,
		GROUP				= 0x00020000L,
		TABSTOP				= 0x00010000L,
		MINIMIZEBOX			= 0x00020000L,
		MAXIMIZEBOX			= 0x00010000L,
		OVERLAPPEDWINDOW	= OVERLAPPED | CAPTION | SYSMENU | THICKFRAME | MINIMIZEBOX | MAXIMIZEBOX,
		POPUPWINDOW			= POPUP | BORDER | SYSMENU,
	};
	friend nodebug_inline constexpr Style operator|(Style a, Style b)	{ return Style((int)a | (int)b); }
	friend nodebug_inline constexpr Style operator&(Style a, Style b)	{ return Style((int)a & (int)b); }
	friend nodebug_inline constexpr Style operator^(Style a, Style b)	{ return Style((int)a ^ (int)b); }
	friend nodebug_inline constexpr Style operator-(Style a, Style b)	{ return Style((int)a & ~(int)b); }
	friend nodebug_inline constexpr Style operator*(bool a, Style b)	{ return a ? b : NOSTYLE; }

	// Extended Window Styles
	enum StyleEx {
		NOEX				= 0x00000000L,
		DLGMODALFRAME		= 0x00000001L,
		NOPARENTNOTIFY		= 0x00000004L,
		TOPMOST				= 0x00000008L,
		ACCEPTFILES			= 0x00000010L,
		TRNSPARENT			= 0x00000020L,
		MDICHILD			= 0x00000040L,
		TOOLWINDOW			= 0x00000080L,
		WINDOWEDGE			= 0x00000100L,
		CLIENTEDGE			= 0x00000200L,
		CONTEXTHELP			= 0x00000400L,
		RIGHT				= 0x00001000L,
		LEFT				= 0x00000000L,
		RTLREADING			= 0x00002000L,
		LTRREADING			= 0x00000000L,
		LEFTSCROLLBAR		= 0x00004000L,
		CONTROLPARENT		= 0x00010000L,
		STATICEDGE			= 0x00020000L,
		APPWINDOW			= 0x00040000L,
		LAYERED				= 0x00080000,
		NOINHERITLAYOUT		= 0x00100000L,
		NOREDIRECTIONBITMAP	= 0x00200000L,
		LAYOUTRTL			= 0x00400000L,
		COMPOSITED			= 0x02000000L,
		NOACTIVATE			= 0x08000000L,
		OVERLAPPEDWINDOWEX	= WINDOWEDGE | CLIENTEDGE,
		PALETTEWINDOW		= WINDOWEDGE | TOOLWINDOW | TOPMOST,
	};
	friend nodebug_inline constexpr StyleEx operator|(StyleEx a, StyleEx b)	{ return StyleEx((int)a | (int)b); }
	friend nodebug_inline constexpr StyleEx operator&(StyleEx a, StyleEx b)	{ return StyleEx((int)a & (int)b); }
	friend nodebug_inline constexpr StyleEx operator^(StyleEx a, StyleEx b)	{ return StyleEx((int)a ^ (int)b); }
	friend nodebug_inline constexpr StyleEx operator-(StyleEx a, StyleEx b)	{ return StyleEx((int)a & ~(int)b); }
	friend nodebug_inline constexpr StyleEx operator*(bool a, StyleEx b)	{ return a ? b : NOEX; }

	template<int I, typename T> struct value {
		HWND	hWnd;
		T		get()						const	{ return force_cast<T>(GetWindowLongPtr(hWnd, I)); }
		operator T()						const	{ return get(); }
		void	operator=(const value &v)	const	{ SetWindowLongPtr(hWnd, I, v.get()); }
		void	operator=(const T &t)		const	{ SetWindowLongPtr(hWnd, I, (const LONG_PTR&)t); }
		void	operator|=(const T &t)		const	{ *this = get() | t; }
		void	operator&=(const T &t)		const	{ *this = get() & t; }
		void	operator^=(const T &t)		const	{ *this = get() ^ t; }
		bool	operator!()					const	{ return !get(); }
		T		operator++()				const	{ auto r = get(); *this = ++r; return r; }
		T		operator--()				const	{ auto r = get(); *this = --r; return r; }
		T		operator++(int)				const	{ auto r = get(); *this = r + 1; return r; }
		T		operator--(int)				const	{ auto r = get(); *this = r - 1; return r; }
	};
	union {
		HWND								hWnd;
		value<GWL_ID,			ID>			id;
		value<GWL_STYLE,		Style>		style;
		value<GWL_EXSTYLE,		StyleEx>	exstyle;
		value<GWLP_WNDPROC,		WNDPROC>	winproc;
		value<GWLP_HINSTANCE,	HINSTANCE>	hinstance;
		value<GWLP_USERDATA,	uint64>		iuser;
		arb_ptr<GWLP_USERDATA>				user;
		_extra								extra;
	};

	static Control	Desktop()	{ return GetDesktopWindow(); }
protected:
	HWND _Create(const char *classname, HWND hWndParent, const char *caption, ID id, Style style, StyleEx styleEx = StyleEx(0), int width = CW_USEDEFAULT, int height = CW_USEDEFAULT, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT) {
		return hWnd = CreateWindowExA(styleEx, classname, caption, style, x, y, width, height, hWndParent, (HMENU)id.i, GetDefaultInstance(), 0);
	}
	HWND _Create(const char16 *classname, HWND hWndParent, const char16 *caption, ID id, Style style, StyleEx styleEx = StyleEx(0), int width = CW_USEDEFAULT, int height = CW_USEDEFAULT, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT) {
		return hWnd = CreateWindowExW(styleEx, classname, caption, style, x, y, width, height, hWndParent, (HMENU)id.i, GetDefaultInstance(), 0);
	}
	HWND _Create(const char16 *classname, HWND hWndParent, const char *caption, ID id, Style style, StyleEx styleEx = StyleEx(0), int width = CW_USEDEFAULT, int height = CW_USEDEFAULT, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT) {
		return hWnd = CreateWindowExW(styleEx, classname, str16(caption), style, x, y, width, height, hWndParent, (HMENU)id.i, GetDefaultInstance(), 0);
	}

	static uint32		get_class_style()		{ return CS_DBLCLKS; }
	static uint32		get_class_cextra()		{ return 0; }
	static uint32		get_class_wextra()		{ return sizeof(void*); }
	static HBRUSH		get_class_background()	{ return 0; }
	static HCURSOR		get_class_cursor()		{ return LoadCursor(NULL, IDC_ARROW); }

public:
	Control()			: hWnd(NULL)	{}
	Control(HWND hWnd)	: hWnd(hWnd)	{}
	Control(LPARAM lp)	: hWnd((HWND)lp){}
	Control& operator=(const Control &b)	{ hWnd = b.hWnd; return *this; }
	Control&		control()			{ return *this; }

	operator		HWND()		const	{ return hWnd; }
	_class&			Class()		const	{ return *(_class*)this; }

	LRESULT			Proc(MSG_ID message, WPARAM wParam = 0, LPARAM lParam = 0) {
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	bool			Destroy()																	const	{ return !!DestroyWindow(hWnd); }

	bool			Move(const RECT &rect, uint32 flags = 0)									const	{ return !!SetWindowPos(hWnd, 0, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, flags | SWP_NOZORDER); }
	bool			Move(const WindowPos &wp, uint32 flags = 0)									const	{ SetParent(wp.parent); return !!SetWindowPos(hWnd, wp.after, wp.rect.left, wp.rect.top, wp.rect.Width(), wp.rect.Height(), flags);}
	bool			Move(const WINDOWPOS &wp, uint32 flags = 0)									const	{ return !!SetWindowPos(hWnd, wp.hwndInsertAfter, wp.x, wp.y, wp.cx, wp.cy, flags | wp.flags);}
	bool			Move(const POINT &p)														const	{ return !!SetWindowPos(hWnd, 0, p.x, p.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);}
	bool			MoveBefore(HWND hWnd2)														const	{ return !!SetWindowPos(hWnd2, hWnd, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE); }
	bool			MoveAfter(HWND hWnd2)														const	{ return !!SetWindowPos(hWnd, hWnd2, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE); }
	bool			Resize(const POINT &size)													const	{ return !!SetWindowPos(hWnd, 0, 0, 0, size.x, size.y, SWP_NOMOVE | SWP_NOZORDER); }
	bool			Show(int show = SW_SHOW)													const	{ return !!ShowWindow(hWnd, show); }
	bool			Hide()																		const	{ return Show(SW_HIDE); }
	bool			IsVisible()																	const	{ return !!IsWindowVisible(hWnd); }
	bool			IsMinimised()																const	{ return !!IsIconic(hWnd); }
	bool			IsMaximised()																const	{ return !!IsZoomed(hWnd); }
	WINDOWPLACEMENT	GetPlacement()																const	{ WINDOWPLACEMENT wp = {sizeof(WINDOWPLACEMENT)}; GetWindowPlacement(hWnd, &wp); return wp; }
	bool			SetPlacement(const WINDOWPLACEMENT &wp)										const	{ return !!SetWindowPlacement(hWnd, &wp); }
	bool			Update()																	const	{ return !!UpdateWindow(hWnd); }
	bool			Invalidate(RECT *p = NULL, bool erase = true)								const	{ return !!InvalidateRect(hWnd, p, erase); }
	bool			Invalidate(const RECT &rect, bool erase = true)								const	{ return !!InvalidateRect(hWnd, &rect, erase); }
	bool			Invalidate(const Region &r, bool erase = true)								const	{ return !!InvalidateRgn(hWnd, r, erase); }
	bool			Validate(const RECT &rect)													const	{ return !!ValidateRect(hWnd, &rect); }
	bool			Validate(const Region &r)													const	{ return !!ValidateRgn(hWnd, r); }
	HWND			SetFocus()																	const	{ return ::SetFocus(hWnd); }
	LRESULT			SendMessage(UINT msg)														const	{ return ::SendMessage(hWnd, msg, 0, 0); }
	LRESULT			SendMessage(UINT msg, wparam wParam)										const	{ return ::SendMessage(hWnd, msg, wParam, 0); }
	LRESULT			SendMessage(UINT msg, wparam wParam, lparam lParam)							const	{ return ::SendMessage(hWnd, msg, wParam, lParam); }
	LRESULT			SendMessageL(UINT msg, lparam lParam)										const	{ return ::SendMessage(hWnd, msg, 0, lParam); }
	bool			PostMessage(UINT msg)														const	{ return !!::PostMessage(hWnd, msg, 0, 0); }
	bool			PostMessage(UINT msg, wparam wParam)										const	{ return !!::PostMessage(hWnd, msg, wParam, 0); }
	bool			PostMessage(UINT msg, wparam wParam, lparam lParam)							const	{ return !!::PostMessage(hWnd, msg, wParam, lParam); }
	bool			PostMessageL(UINT msg, lparam lParam)										const	{ return !!::PostMessage(hWnd, msg, 0, lParam); }
	LRESULT			operator()(UINT msg)														const	{ return ::SendMessage(hWnd, msg, 0, 0); }
	LRESULT			operator()(UINT msg, wparam wParam)											const	{ return ::SendMessage(hWnd, msg, wParam, 0); }
	LRESULT			operator()(UINT msg, wparam wParam, lparam lParam)							const	{ return ::SendMessage(hWnd, msg, wParam, lParam); }
	LRESULT			Notify(Control from, UINT code, ID id, wparam wParam = wparam())			const	{ NMHDR nmh = {from, id, code}; return SendMessage(WM_NOTIFY, wParam, &nmh); }
	LRESULT			Notify(Control from, UINT code)												const	{ return Notify(from, code, from.id.get(), from.id.get()); }
	bool			EnableInput(bool enable = true)												const	{ return !!EnableWindow(hWnd, enable); }
	void			EnableRedraws(bool enable = true)											const	{ SendMessage(WM_SETREDRAW, enable); }
	bool			SetTimer(uint32 id, float rate)												const	{ return !!::SetTimer(hWnd, id, uint32(rate * 1000), 0);}
	bool			KillTimer(int id)															const	{ return !!::KillTimer(hWnd, id); }

	string_getter<HWND> GetText()																const	{ return hWnd; }
	bool			SetText(text s)																const	{ return !!SetWindowTextA(hWnd, s); }

	Rect			GetRect()																	const	{ Rect rect; GetWindowRect(hWnd, &rect); return rect; }
	Rect			GetClientRect()																const	{ Rect rect; ::GetClientRect(hWnd, &rect); return rect; }
	Rect			GetRelativeRect()															const	{ return Parent().ToClient(GetRect()); }
	Point			ToScreen(const POINT &p)													const	{ Point p2 = p; ClientToScreen(hWnd, &p2); return p2; }
	Rect			ToScreen(const RECT &r)														const	{ Rect r2 = r; ClientToScreen(hWnd, &r2.TopLeft()); ClientToScreen(hWnd, &r2.BottomRight()); return r2; }
	Point			ToClient(const POINT &p)													const	{ Point p2 = p; ScreenToClient(hWnd, &p2); return p2; }
	Rect			ToClient(const RECT &r)														const	{ Rect r2 = r; ScreenToClient(hWnd, &r2.TopLeft()); ScreenToClient(hWnd, &r2.BottomRight()); return r2; }
	Rect			GetChildRect()																const	{ Rect r; return SendMessageL(WM_ISO_CHILDRECT, &r) ? r : GetClientRect(); }
	WindowPos		GetRelativeWindowPos()														const	{ return WindowPos(Parent(), GetRelativeRect()); }
	WindowPos		GetChildWindowPos()															const	{ return WindowPos(*this, GetChildRect()); }

	arbitrary		GetValue(int i)																const	{ return GetWindowLong(hWnd, i); }
	arbitrary		SetValue(int i, const arbitrary &v)											const	{ return SetWindowLong(hWnd, i, (LONG)v); }
	arbitrary_ptr	GetPtr(int i)																const	{ return (void*)GetWindowLongPtr(hWnd, i); }
	arbitrary_ptr	SetPtr(int i, void *p)														const	{ return (void*)SetWindowLongPtr(hWnd, i, (LONG_PTR)p); }

	arbitrary		GetClassValue(int i)														const	{ return GetClassLong(hWnd, i); }
	arbitrary		SetClassValue(int i, const arbitrary &v)									const	{ return SetClassLong(hWnd, i, (LONG)v); }
	arbitrary_ptr	GetClassPtr(int i)															const	{ return (void*)GetClassLongPtr(hWnd, i); }
	arbitrary_ptr	SetClassPtr(int i, void *p)													const	{ return (void*)SetClassLongPtr(hWnd, i, (LONG_PTR)p); }

	Menu			GetMenu()																	const	{ return ::GetMenu(hWnd); }
	Menu			GetMenu(int i)																const	{ return GetMenu().GetSubMenuByPos(i); }
	Menu			GetMenu(const char *name)													const	{ return GetMenu().GetSubMenuByName(name); }
	bool			SetMenu(HMENU hMenu)														const	{ return !!::SetMenu(hWnd, hMenu); }
	Font			GetFont()																	const	{ return (HFONT)SendMessage(WM_GETFONT); }
	void			SetFont(const Font &font, bool redraw = false)								const	{ SendMessage(WM_SETFONT, (HFONT)font, redraw); }

	bool			GetScroll(SCROLLINFO &si, int which)										const	{ return !!::GetScrollInfo(hWnd, which, &si); }
	int				SetScroll(const SCROLLINFO &si, int which, bool redraw = true)				const	{ return ::SetScrollInfo(hWnd, which, &si, redraw); }
	bool			GetScroll(SCROLLINFO &si, bool vert = true)									const	{ return !!::GetScrollInfo(hWnd, vert ? SB_VERT : SB_HORZ, &si); }
	int				SetScroll(const SCROLLINFO &si, bool vert = true, bool redraw = true)		const	{ return ::SetScrollInfo(hWnd, vert ? SB_VERT : SB_HORZ, &si, redraw); }
	ScrollInfo		GetScroll(uint32 mask = SIF_ALL, bool vert = true)							const	{ ScrollInfo si(mask); GetScroll(si, vert); return si; }

	bool			Scroll(int x, int y, uint32 flags = SW_INVALIDATE | SW_SCROLLCHILDREN, const RECT *rect = NULL, const RECT *clip = NULL) const	{
		return !!::ScrollWindowEx(hWnd, x, y, rect, clip, NULL, NULL, flags);
	}
	bool			Scroll(const POINT &p, uint32 flags = SW_INVALIDATE | SW_SCROLLCHILDREN, const RECT *rect = NULL, const RECT *clip = NULL) const {
		return !!::ScrollWindowEx(hWnd, p.x, p.y, rect, clip, NULL, NULL, flags);
	}

	DWORD			ThreadID()																	const	{ return GetWindowThreadProcessId(*this, NULL); }
	DWORD			ProcessID()																	const	{ DWORD id; GetWindowThreadProcessId(*this, &id); return id; }
	Control			Owner()																		const	{ return GetWindow(hWnd, GW_OWNER); }
	Control			SetOwner(HWND owner)														const	{ return (HWND)SetWindowLongPtr(hWnd, GWLP_HWNDPARENT, (LONG_PTR)owner); }
	Control			Parent()																	const	{ return ::GetParent(hWnd); }
	Control			SetParent(HWND parent)														const	{ return ::SetParent(hWnd, parent); }
	Control			Child()																		const	{ return ::GetWindow(hWnd, GW_CHILD); }

	Control			ChildByID(int id)															const	{ return GetDlgItem(hWnd, id); }
	Control			ChildAtClient(const POINT &p)												const	{ return RealChildWindowFromPoint(hWnd, p); }
	Control			ChildAt(const POINT &p)														const	{ return ChildAtClient(ToClient(p)); }
	iso_export Control	DescendantByID(ID id)													const;
	iso_export Control	DescendantAt(const POINT &p)											const;

	bool			TrackMouse(uint32 flags) {
		TRACKMOUSEEVENT	t = {sizeof(TRACKMOUSEEVENT), flags, hWnd, HOVER_DEFAULT};
		return !!TrackMouseEvent(&t);
	}
	bool			TrackMouse(uint32 flags, float hover) {
		TRACKMOUSEEVENT	t = {sizeof(TRACKMOUSEEVENT), flags, hWnd, DWORD(hover * 1000)};
		return !!TrackMouseEvent(&t);
	}
	uint32			GetMouseTracking(float *hover = 0) {
		TRACKMOUSEEVENT	t = {sizeof(TRACKMOUSEEVENT), TME_QUERY, hWnd, HOVER_DEFAULT};
		if (TrackMouseEvent(&t)) {
			if (hover)
				*hover = t.dwHoverTime / 1000.f;
			return t.dwFlags;
		}
		return 0;
	}
	template<typename T> T*	FindAncestor() {
		for (Control c = *this; c; c = c.Parent()) {
			if (T *s = T::Cast(c))
				return s;
		}
		return 0;
	}
	template<typename T> T*	FindAncestorByProc() {
		for (Control c = *this; c; c = c.Parent()) {
			if (T *s = CastByProc<T>(c))
				return s;
		}
		return 0;
	}

	struct child_iterator;
	struct descendant_iterator;
	range<child_iterator>		Children() const;
	range<descendant_iterator>	Descendants() const;
};

struct Control::child_iterator {
	Control	c;

	child_iterator(Control c) : c(c) {}
	Control			operator*()	const	{ return c; }
	const Control*	operator->() const	{ return &c; }
	child_iterator	operator++()		{ c = GetWindow(c, GW_HWNDNEXT); return *this; }
	child_iterator	operator--()		{ c = GetWindow(c, GW_HWNDPREV); return *this; }
	child_iterator	operator++(int)		{ Control p = c; operator++(); return p; }
	child_iterator	operator--(int)		{ Control p = c; operator--(); return p; }
	explicit operator bool() const		{ return c; }
	bool	operator==(const child_iterator &b) const { return c == b.c; }
	bool	operator!=(const child_iterator &b) const { return c != b.c; }
};

struct Control::descendant_iterator : child_iterator {
	using child_iterator::child_iterator;
	descendant_iterator	operator++()		{
		if (Control c2 = GetWindow(c, GW_CHILD)) {
			c = c2;

		} else {
			while (c) {
				if (Control c2 = GetWindow(c, GW_HWNDNEXT)) {
					c = c2;
					break;
				}
				c = c.Parent();
			}
		}
		return *this;
	}
};

inline range<Control::child_iterator> Control::Children() const {
	return {(Control)GetWindow(*this, GW_CHILD), Control()};
}

inline range<Control::descendant_iterator> Control::Descendants() const {
	Control	begin = GetWindow(*this, GW_CHILD);
	Control	end;
	if (begin) {
		for (Control c = *this; !end && c; c = c.Parent())
			end = GetWindow(c, GW_HWNDNEXT);
	}
	return {begin, end};
}

inline Control WindowPos::Parent()	const {	return parent; }
inline Control WindowPos::After()	const {	return after; }

inline Rect &AdjustRect(Rect &rect, Control::Style style, bool menu = false) {
	::AdjustWindowRect(&rect, style, menu);
	return rect;
}
inline Rect AdjustRect(const Rect &rect, Control::Style style, bool menu = false) {
	Rect	rect2 = rect;
	::AdjustWindowRect(&rect2, style, menu);
	return rect2;
}
inline Rect FrameRect(Control::Style style, bool menu = false) {
	Rect	rect(0,0,0,0);
	return AdjustRect(rect, style, menu);
}

template<typename T, typename B> struct create_mixin : B {
	typedef create_mixin	Base;
	using typename B::Style;
	using typename B::StyleEx;

	HWND Create(HWND hWndParent, text caption, Style style, StyleEx styleEx, const RECT &rect, ID id = ID())	{ return Control::_Create(T::ClassName(), hWndParent, caption, id, style, styleEx, rect.right - rect.left, rect.bottom - rect.top, rect.left, rect.top); }
	HWND Create(HWND hWndParent, text caption, Style style, StyleEx styleEx, const POINT &size, ID id = ID())	{ return Control::_Create(T::ClassName(), hWndParent, caption, id, style, styleEx, size.x, size.y); }
	HWND Create(HWND hWndParent, text caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID())			{ return Control::_Create(T::ClassName(), hWndParent, caption, id, style, styleEx); }
	HWND Create(const WindowPos &pos, text caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID())		{ return Create(pos.Parent(), caption, style, styleEx, pos.rect, id); }

	create_mixin()						{}
	create_mixin(Control c) : B(c)		{}
	create_mixin(HWND hWnd) : B(hWnd)	{}
	template<typename P0, typename P1, typename...P>	create_mixin(P0&& p0, P1&& p1, P&&...p) { static_cast<T*>(this)->Create(forward<P0>(p0), forward<P1>(p1), forward<P>(p)...); }
//	create_mixin(HWND hWndParent, text caption, Style style, StyleEx styleEx, const RECT &rect, ID id = ID())	{ static_cast<T*>(this)->Create(hWndParent, caption, style, styleEx, rect, id); }
//	create_mixin(HWND hWndParent, text caption, Style style, StyleEx styleEx, const POINT &size, ID id = ID())	{ static_cast<T*>(this)->Create(hWndParent, caption, style, styleEx, size, id); }
//	create_mixin(HWND hWndParent, text caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID())			{ static_cast<T*>(this)->Create(hWndParent, caption, style, styleEx, id); }
//	create_mixin(const WindowPos &pos, text caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID())		{ static_cast<T*>(this)->Create(pos, caption, style, styleEx, id); }
};

template<typename T, typename B = Control> struct control_mixin : create_mixin<T, B> {
	typedef control_mixin	Base;
	using create_mixin<T, B>::create_mixin;
//	LRESULT	Proc(MSG_ID message, WPARAM wParam = 0, LPARAM lParam = 0) { return DefWindowProc(hWnd, message, wParam, lParam); }
};

inline void InitNotification(NMHDR &nmh, Control from, uint32 code) {
	nmh.hwndFrom	= from;
	nmh.idFrom		= from.id.get().i;
	nmh.code		= code;
}

inline int SendNotification(NMHDR &nmh, Control to) {
	return to.SendMessage(WM_NOTIFY, nmh.idFrom, &nmh);
}

inline int SendNotification(NMHDR &nmh, Control from, uint32 code) {
	InitNotification(nmh, from, code);
	return from.Parent().SendMessage(WM_NOTIFY, nmh.idFrom, &nmh);
}

struct Notification : NMHDR {
	Notification(Control from, uint32 _code, uint32 id)	{ hwndFrom = from; idFrom = id; code = _code; }
	Notification(Control from, uint32 _code)			{ hwndFrom = from; idFrom = from.id.get(); code = _code; }
	void	Send(Control to)							{ to(WM_NOTIFY, idFrom, this); }
	void	Send(Control to, WPARAM wParam)				{ to(WM_NOTIFY, wParam, this); }
};

template<typename T> int ReflectNotification(Control from, WPARAM wParam, T *notification) {
	Control		to		= ((NMHDR*)notification)->hwndFrom;
	ISO_ASSERT(from != to);
	T			copy	= *notification;
	((NMHDR*)&copy)->hwndFrom	= from;
	return to(WM_NOTIFY, wParam, &copy);
}

inline Control GetControlAt(const POINT &p) { return WindowFromPoint(p); }

struct WithControl : Control {
	WithControl(Control &c) : Control(c)			{}
//	Control	*operator->()							{ return this; }
};
struct WithHidden : WithControl {
	WithHidden(Control &c) : WithControl(c)			{ Show(SW_HIDE); }
	~WithHidden()									{ Show(SW_SHOW); }
};
struct WithDisabledInput : WithControl {
	WithDisabledInput(Control &c) : WithControl(c)	{ EnableInput(false); }
	~WithDisabledInput()							{ EnableInput(true); }
};
struct WithDisabledRedraw : WithControl {
	WithDisabledRedraw(Control &c) : WithControl(c)	{ EnableRedraws(false); }
	~WithDisabledRedraw()							{ EnableRedraws(true); RedrawWindow(hWnd, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN); }
};

template<typename C> struct RefControl : C {
	RefControl()			{}
	RefControl(C c) : C(c)	{ addref(); }
	~RefControl()			{ if (*this) release(); }
	void	operator=(C c)	{ if (*this) release(); *(C*)this = c; addref(); }
	void	addref()		{ ++this->iuser; }
	void	release()		{ ISO_ASSERT(this->iuser); if (!--this->iuser) this->Destroy(); }
};
/*
template<typename T> class RefControl : public T {
	uint32		nrefs;
public:
	RefControl() : nrefs(0)			{}
	~RefControl()					{ ISO_ASSERT(nrefs == 0); }

	void	operator=(const T &t)	{ T::operator=(t); ++nrefs; }
	void	Destroy()				{ if (!--nrefs) T::Destroy(); }
};

template<typename C> struct rc<C, enable_if_t<T_is_base_of<Control, C>::value>> : C {
	rc()					{}
	rc(C c) : C(c)			{ addref(); }
	~rc()					{ if (*this) release(); }
	void	operator=(C c)	{ if (*this) release(); *(C*)this = c; addref(); }
	void	addref()		{ ++iuser; }
	void	release()		{ ISO_ASSERT(iuser); if (!--iuser) Destroy(); }
};
*/

//-----------------------------------------------------------------------------
//	Static Control
//-----------------------------------------------------------------------------

class StaticControl : public control_mixin<StaticControl> {
public:
	static const char *ClassName()	{ return WC_STATICA; }
	static const Style
		LEFT			= Style(0x0000),
		CENTER			= Style(0x0001),
		RIGHT			= Style(0x0002),
		ICON			= Style(0x0003),
		BLACKRECT		= Style(0x0004),
		GRAYRECT		= Style(0x0005),
		WHITERECT		= Style(0x0006),
		BLACKFRAME		= Style(0x0007),
		GRAYFRAME		= Style(0x0008),
		WHITEFRAME		= Style(0x0009),
		USERITEM		= Style(0x000A),
		SIMPLE			= Style(0x000B),
		LEFTNOWORDWRAP	= Style(0x000C),
		OWNERDRAW		= Style(0x000D),
		BITMAP			= Style(0x000E),
		ENHMETAFILE		= Style(0x000F),
		ETCHEDHORZ		= Style(0x0010),
		ETCHEDVERT		= Style(0x0011),
		ETCHEDFRAME		= Style(0x0012),
		TYPEMASK		= Style(0x001F),
		REALSIZECONTROL	= Style(0x0040),
		NOPREFIX		= Style(0x0080),
		NOTIFY			= Style(0x0100),
		CENTERIMAGE		= Style(0x0200),
		RIGHTJUST		= Style(0x0400),
		REALSIZEIMAGE	= Style(0x0800),
		SUNKEN			= Style(0x1000),
		EDITCONTROL		= Style(0x2000),
		ENDELLIPSIS		= Style(0x4000),
		PATHELLIPSIS	= Style(0x8000),
		WORDELLIPSIS	= Style(0xC000),
		ELLIPSISMASK	= Style(0xC000);

	using Base::Base;
};

//-----------------------------------------------------------------------------
//	Button Control
//-----------------------------------------------------------------------------

class Button : public control_mixin<Button> {
public:
	static const char *ClassName()	{ return "BUTTON"; }
	static const Style
		PUSHBUTTON		= Style(0x0000),
		DEFPUSHBUTTON	= Style(0x0001),
		CHECKBOX		= Style(0x0002),
		AUTOCHECKBOX	= Style(0x0003),
		RADIOBUTTON		= Style(0x0004),
		THREESTATE		= Style(0x0005),
		AUTO3STATE		= Style(0x0006),
		GROUPBOX		= Style(0x0007),
		USERBUTTON		= Style(0x0008),
		AUTORADIOBUTTON	= Style(0x0009),
		PUSHBOX			= Style(0x000A),
		OWNERDRAW		= Style(0x000B),
		SPLITBUTTON		= Style(0x000C),
		DEFSPLITBUTTON	= Style(0x000D),
		COMMANDLINK		= Style(0x000E),
		DEFCOMMANDLINK	= Style(0x000F),
		TYPEMASK		= Style(0x000F),
		LEFTTEXT		= Style(0x0020),
		TEXT			= Style(0x0000),
		ICON			= Style(0x0040),
		BITMAP			= Style(0x0080),
		LEFT			= Style(0x0100),
		RIGHT			= Style(0x0200),
		CENTER			= Style(0x0300),
		TOP				= Style(0x0400),
		BOTTOM			= Style(0x0800),
		VCENTER			= Style(0x0C00),
		PUSHLIKE		= Style(0x1000),
		MULTILINE		= Style(0x2000),
		NOTIFY			= Style(0x4000),
		FLAT			= Style(0x8000);

	using Base::Base;

	static Button PushButton(	HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | PUSHBUTTON,	NOEX, rect, id); }
	static Button Checkbox(		HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | CHECKBOX,		NOEX, rect, id); }
	static Button RadioButton(	HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | (style & DEFPUSHBUTTON ? AUTORADIOBUTTON: RADIOBUTTON), NOEX, rect, id); }
	static Button TriSState(	HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style ^ THREESTATE,	NOEX, rect, id); }
	static Button Groupbox(		HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | GROUPBOX,		NOEX, rect, id); }
	static Button UserButton(	HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | USERBUTTON,	NOEX, rect, id); }
	static Button Pushbox(		HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | PUSHBOX,		NOEX, rect, id); }
	static Button OwnerDraw(	HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID())	{ return Button(hWndParent, caption, style | OWNERDRAW,		NOEX, rect, id); }

	bool		Click()										const	{ return !!SendMessage(BM_CLICK); }
	Point		GetIdealSize()								const	{ SIZE s; SendMessageL(BCM_GETIDEALSIZE, &s); return s; }
	Rect		GetMargin()									const	{ RECT r; SendMessageL(BCM_GETTEXTMARGIN, &r); return r; }
	bool		SetMargin(const RECT & r)					const	{ return !!SendMessageL(BCM_SETTEXTMARGIN, &r); }
	bool		SetStyle(uint32 style, bool redraw)			const	{ return !!SendMessage(BM_SETSTYLE, style, redraw); }

	ImageList	GetImageList(Rect &r, uint32 &align)		const	{ BUTTON_IMAGELIST b; SendMessageL(BCM_GETIMAGELIST, &b); r = b.margin; align = b.uAlign; return b.himl; }
	bool		SetImagelist(HIMAGELIST h, const RECT &r, uint32 align)	const { BUTTON_IMAGELIST b = {h, r, align}; return !!SendMessageL(BCM_SETIMAGELIST, &b); }
	Icon		GetImageIcon()								const	{ return (HICON)SendMessage(BM_GETIMAGE, IMAGE_ICON); }
	Bitmap		GetImageBitmap()							const	{ return (HBITMAP)SendMessage(BM_GETIMAGE, IMAGE_BITMAP); }
	bool		SetImage(HICON h)							const	{ return !!SendMessage(BM_SETIMAGE, IMAGE_ICON, h); }
	bool		SetImage(HBITMAP h)							const	{ return !!SendMessage(BM_SETIMAGE, IMAGE_BITMAP, h); }

	int			GetCheck()									const	{ return SendMessage(BM_GETCHECK); }
	int			GetState()									const	{ return SendMessage(BM_GETSTATE); }
	bool		SetCheck(int check)							const	{ return !!SendMessage(BM_SETCHECK, check); }
	bool		SetState(bool highlight)					const	{ return !!SendMessage(BM_SETSTATE, highlight); }

#if _WIN32_WINNT >= 0x0600
	bool		SetElevated(bool on)						const	{ return !!SendMessageL(BCM_SETSHIELD, on); }
	bool		SetDontClick(bool on)						const	{ return !!SendMessage(BM_SETDONTCLICK, on); }
#endif
};

#if _WIN32_WINNT >= 0x0600
class SplitButton : public Button {
public:
	HWND Create(HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID()) {
		return Button::Create(hWndParent, caption, style | SPLITBUTTON, NOEX, rect, id);
	}
	SplitButton(HWND hWnd) : Button(hWnd) {}
	SplitButton(HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID()) {
		Create(hWndParent, caption, style, rect, id);
	}
	bool		GetSplit()									const	{ BUTTON_SPLITINFO s; return !!SendMessageL(BCM_GETSPLITINFO, &s); }
	bool		SetSplit(const BUTTON_SPLITINFO &b)			const	{ return !!SendMessageL(BCM_SETSPLITINFO, &b); }
	bool		SetDropdownState(bool state)				const	{ return !!SendMessage(BCM_SETDROPDOWNSTATE, state); }
};

class LinkButton : public Button {
	HWND Create(HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID()) {
		return Button::Create(hWndParent, caption, style | COMMANDLINK, NOEX, rect, id);
	}
	LinkButton(HWND hWnd) : Button(hWnd) {}
	LinkButton(HWND hWndParent, const char *caption, Style style, const RECT &rect, ID id = ID()) {
		Create(hWndParent, caption, style, rect, id);
	}
	size_t		GetNotelength()								const	{ return SendMessage(BCM_GETNOTELENGTH); }
	template<int N> fixed_string<N> GetNote()				const	{ fixed_string<N> note; size_t len = N; SendMessage(BCM_GETNOTE, &len, note); return note; }
	bool		SetNote(const char *note)					const	{ return !!SendMessageL(BCM_SETNOTE, str16(note)); }
	bool		SetNote(const wchar_t *note)				const	{ return !!SendMessageL(BCM_SETNOTE, note); }
};
#endif

//-----------------------------------------------------------------------------
//	TextControl
//-----------------------------------------------------------------------------

struct CharRange : CHARRANGE {
	CharRange()						{}
	CharRange(int a)				{ cpMin = cpMax = a; }
	CharRange(int a, int b)			{ cpMin = a; cpMax = b; }
	CharRange(interval<uint32> i)	{ cpMin = i.a; cpMax = i.b; }

	CharRange&	to_end()		{ cpMax = -1; return *this; }

	static CharRange all()		{ return CharRange(0, -1); }
	static CharRange begin()	{ return CharRange(0); }
	static CharRange end()		{ return CharRange(-1); }

	operator interval<uint32>()		const { return interval<uint32>(cpMin, cpMax); }
};

class EditControl : public control_mixin<EditControl> {
	struct _line_getter {
		Control		c;
		LONG		offset;
		_line_getter(Control c, LONG offset) : c(c), offset(offset) {}
		size_t	string_len()						const	{ return c(EM_LINELENGTH, offset); }
		size_t	string_get(char *s, size_t len)		const	{ return c(EM_GETLINE, c(EM_LINEFROMCHAR, offset), s); }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
public:
	static const char *ClassName()	{ return WC_EDITA; }
	static const Style
		LEFT			= Style(0x0000),
		CENTER			= Style(0x0001),
		RIGHT			= Style(0x0002),
		MULTILINE		= Style(0x0004),
		UPPERCASE		= Style(0x0008),
		LOWERCASE		= Style(0x0010),
		PASSWORD		= Style(0x0020),
		AUTOVSCROLL		= Style(0x0040),
		AUTOHSCROLL		= Style(0x0080),
		NOHIDESEL		= Style(0x0100),
		OEMCONVERT		= Style(0x0400),
		READONLY		= Style(0x0800),
		WANTRETURN		= Style(0x1000),
		NUMBER			= Style(0x2000);

	using Base::Base;
	using Control::SetText;
	bool		SetText(const char *text, size_t len)		const	{ return SetText(string(str(text, len))); }
	bool		SetText(const wchar_t *text, size_t len)	const	{ return SetText(string(str(text, len))); }
	bool		SetTabs(int n, uint32 *p)					const	{ return !!SendMessage(EM_SETTABSTOPS, n, p); }
	bool		SetTabs(int n)								const	{ return !!SendMessage(EM_SETTABSTOPS, 1, &n); }
	void		HideSelection(bool hide = true)				const	{ SendMessage(EM_HIDESELECTION, hide); }
	void		ReadOnly(bool readonly = true)				const	{ SendMessage(EM_SETREADONLY, readonly); }

	CharRange	GetSelection()								const	{ CharRange cr; SendMessage(EM_GETSEL, &cr.cpMin, &cr.cpMax); return cr; }
	CharRange	GetLineRange(int i)							const	{ return CharRange(GetLineStart(i), GetLineStart(i + 1) - 1); }
	bool		SetSelection(const CharRange &cr)			const	{ return !!SendMessage(EM_SETSEL, cr.cpMin, cr.cpMax); }
	bool		ReplaceSelection(text s, bool undo = true)	const	{ return !!SendMessage(EM_REPLACESEL, int(undo), (const char*)s); }
	int			NumLines()									const	{ return SendMessage(EM_GETLINECOUNT); }
	int			GetLine(LONG offset)						const	{ return SendMessage(EM_LINEFROMCHAR, offset); }
	int			GetLineStart(int i)							const	{ return SendMessage(EM_LINEINDEX, i); }
	int			GetCurrentLineStart()						const	{ return SendMessage(EM_LINEINDEX, -1); }
	uint16		GetCharLineLength(LONG offset)				const	{ return SendMessage(EM_LINELENGTH, offset); }
	string_getter<_line_getter> GetLineText(LONG offset)	const	{ return _line_getter(*this, offset); }
	bool		EnsureVisible()								const	{ return !!SendMessage(EM_SCROLLCARET); }
	bool		SetCueBanner(const char *banner, bool always = true) const	{ return !!SendMessage(EM_SETCUEBANNER, int(always), banner); }
	void		SetMargins(uint32 left, uint32 right)		const	{ SendMessage(EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELPARAM(left, right)); }

	Rect		GetEditRect()								const	{ Rect r; SendMessageL(EM_GETRECT, &r); return r; }
	void		SetEditRect(const RECT &r, bool rel=false)	const	{ SendMessage(EM_SETRECT, rel, &r); }
	Point		GetCharPos(LONG c)							const	{ return Point(SendMessage(EM_POSFROMCHAR, c)); }
	uint16		GetChar(const POINT &pt)					const	{ return LOWORD(SendMessageL(EM_CHARFROMPOS, &pt)); }
	bool		LineScroll(int y)							const	{ return !!SendMessageL(EM_LINESCROLL, y); }

	template<typename T> T		GetValue()					const	{ return from_string<T>(GetText()); }
	template<typename T> void	SetValue(const T &t)		const	{ SetText(to_string(t)); }
};

struct CharFormat : CHARFORMAT2A {
	CharFormat() { cbSize = sizeof(CHARFORMAT2); dwMask = 0; dwEffects = 0; }
	CharFormat(win::Font font)							{ cbSize = sizeof(CHARFORMAT2); dwMask = 0; dwEffects = 0; Font(font); }
	CharFormat&	SetEffects(uint32 effects, bool on)		{ dwEffects = (dwEffects & ~effects) + int(on) * effects; dwMask |= effects & 0xff; return *this; }
	//CharFormat&	SetEffects(uint32 effects)			{ dwEffects = effects; dwMask |= effects & 0xff; return *this; }
	//CharFormat&	ClearEffects(uint32 effects)		{ dwEffects = ~effects & 0xff; dwMask |= effects & 0xff; return *this; }
	CharFormat&		Size(int height)					{ yHeight = height;		dwMask |= CFM_SIZE;			return *this; }
	CharFormat&		Offset(int y)						{ yOffset = y;			dwMask |= CFM_OFFSET;		return *this; }
	CharFormat&		Colour(win::Colour col)				{ crTextColor = col;	dwMask |= CFM_COLOR;		return *this; }
	CharFormat&		Weight(WORD w)						{ wWeight = w;			dwMask |= CFM_WEIGHT;		return *this; }
	CharFormat&		Spacing(SHORT s)					{ sSpacing = s;			dwMask |= CFM_SPACING;		return *this; }
	CharFormat&		BgColor(win::Colour col)			{ crBackColor = col;	dwMask |= CFM_BACKCOLOR;	return *this; }
	CharFormat&		Locale(LCID id)						{ lcid = id;			dwMask |= CFM_LCID;			return *this; }
	CharFormat&		Style(SHORT s)						{ sStyle = s;			dwMask |= CFM_STYLE;		return *this; }
	CharFormat&		Kerning(WORD k)						{ wKerning = k;			dwMask |= CFM_KERNING;		return *this; }
	CharFormat&		UnderlineType(uint8 u)				{ bUnderlineType = u;	dwMask |= CFM_UNDERLINETYPE;return *this; }
	CharFormat&		RevAuthor(uint8 a)					{ bRevAuthor = a;		dwMask |= CFM_REVAUTHOR;	return *this; }

	win::Colour&	SetColour()							{ dwMask |= CFM_COLOR;	return (win::Colour&)crTextColor; }
	win::Colour&	SetBgColor()						{ dwMask |= CFM_COLOR;	return (win::Colour&)crBackColor; }

	CharFormat&		Colour(uint8 r, uint8 g, uint8 b)	{ return Colour(win::Colour(r, g, b)); }
	CharFormat&		BgColor(uint8 r, uint8 g, uint8 b)	{ return BgColor(win::Colour(r, g, b)); }
	CharFormat&		Bold(bool on = true)				{ return SetEffects(CFE_BOLD, on); }
	CharFormat&		Italic(bool on = true)				{ return SetEffects(CFE_ITALIC, on); }
	CharFormat&		Underline(bool on = true)			{ return SetEffects(CFE_UNDERLINE, on); }
	CharFormat&		Strikeout(bool on = true)			{ return SetEffects(CFE_STRIKEOUT, on); }
	CharFormat&		Protected(bool on = true)			{ return SetEffects(CFE_PROTECTED, on); }
	CharFormat&		Link(bool on = true)				{ return SetEffects(CFE_LINK, on); }
	CharFormat&		Autocolor(bool on = true)			{ return SetEffects(CFE_AUTOCOLOR, on); }
	CharFormat&		Smallcaps(bool on = true)			{ return SetEffects(CFM_SMALLCAPS, on); }
	CharFormat&		Allcaps(bool on = true) 			{ return SetEffects(CFM_ALLCAPS, on); }
	CharFormat&		Hidden(bool on = true)				{ return SetEffects(CFM_HIDDEN, on); }
	CharFormat&		Outline(bool on = true) 			{ return SetEffects(CFM_OUTLINE, on); }
	CharFormat&		Shadow(bool on = true)				{ return SetEffects(CFM_SHADOW, on); }
	CharFormat&		Emboss(bool on = true)				{ return SetEffects(CFM_EMBOSS, on); }
	CharFormat&		Imprint(bool on = true) 			{ return SetEffects(CFM_IMPRINT, on); }
	CharFormat&		Disabled(bool on = true)			{ return SetEffects(CFM_DISABLED, on); }
	CharFormat&		Revised(bool on = true)				{ return SetEffects(CFM_REVISED, on); }

	CharFormat&	Font(const char *font, uint8 set = 0, uint8 family = 0)	{
		strcpy(szFaceName, font);
		bCharSet		= set;
		bPitchAndFamily = family;
		dwMask			|= CFM_FACE;
		return *this;
	}
	CharFormat&	Font(const Font::Params &font) {
		yHeight			= abs(font.Height());
		wWeight			= font.Weight();
		dwEffects		= font.Effects();
		dwMask			|= CFM_SIZE | CFM_WEIGHT | CFE_ITALIC | CFE_STRIKEOUT | CFE_UNDERLINE;
		return Font(font.Name(), font.CharSet(), font.PitchAndFamily());
	}
	CharFormat&	Font(win::Font font) {
		return Font(font.GetParams());
	}
};

class RichEditControl : public create_mixin<RichEditControl, EditControl> {
	template<typename T> struct stream_thunk {
		static DWORD CALLBACK f(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb) {
			*pcb = (*(T*)dwCookie)(pbBuff, cb);
			return 0;
		}
	};
	struct _range_getter {
		Control		c;
		CHARRANGE	r;
		_range_getter(Control c, const CHARRANGE &r) : c(c), r(r) {}
		size_t	string_len() const	{
			LONG	end = r.cpMax;
			if (end == -1) {
				GETTEXTLENGTHEX t = {GTL_DEFAULT, CP_ACP};
				end = c.SendMessageL(EM_GETTEXTLENGTHEX, &t);
			}
			return end - r.cpMin;
		}
		size_t	string_get(char *s, size_t len)		const	{ TEXTRANGEA t = {{r.cpMin, r.cpMin + LONG(len)}, s}; return c(EM_GETTEXTRANGE, 0, &t); }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
public:
	struct Paragraph : PARAFORMAT2 {
		Paragraph() { cbSize = sizeof(*this); dwMask = 0; }
		Paragraph&	Bullets(bool on)						{ wNumbering = on ? PFN_BULLET : 0; dwMask |= PFM_NUMBERING; return *this; }
		Paragraph&	Indent(int i, int i0 = 0, int r = 0)	{ dxStartIndent = i0; dxRightIndent = r; dxOffset = i; dwMask |= PFM_OFFSET | PFM_OFFSETINDENT | PFM_RIGHTINDENT; return *this; }
		Paragraph&	Align(int a)							{ wAlignment = a; dwMask |= PFM_ALIGNMENT; return *this; }
		Paragraph&	Tabs(int t)								{ cTabCount = 1; rgxTabs[0] = t; dwMask |= PFM_TABSTOPS; return *this; }
		Paragraph&	Tabs(int n, uint32 *p)					{ cTabCount = min(n, MAX_TAB_STOPS); memcpy(rgxTabs, p, cTabCount * sizeof(uint32)); dwMask |= PFM_TABSTOPS; return *this; }

		Paragraph&	Get(RichEditControl c)					{ c(EM_GETPARAFORMAT, 0, this); return *this; }
		bool		Set(RichEditControl c)			const	{ return !!c(EM_SETPARAFORMAT, 0, this); }
	};

	static const char *ClassName()	{ return RICHEDIT_CLASSA; }
	static const Style
		SAVESEL				= Style(0x00008000),
		SUNKEN				= Style(0x00004000),
		DISABLENOSCROLL		= Style(0x00002000),
		SELECTIONBAR 		= Style(0x01000000),
		NOOLEDRAGDROP		= Style(0x00000008),
		VERTICAL 			= Style(0x00400000),		// Not supported in RE 2.0/3.0
		NOIME				= Style(0x00080000),
		SELFIME				= Style(0x00040000);

	using Base::Base;
	using Control::GetText;

	CharRange	GetSelection()							const	{ CharRange cr; SendMessageL(EM_EXGETSEL, LPARAM(&cr)); return cr; }
	void		SetSelection(const CharRange &cr)		const	{ SendMessageL(EM_EXSETSEL, LPARAM(&cr)); }
	void		SetFormat(const CHARFORMATA &cf, uint32 flags = SCF_SELECTION) const	{ SendMessage(EM_SETCHARFORMAT, flags, LPARAM(&cf)); }
	bool		SetParagraph(const Paragraph &p)		const	{ return !!SendMessageL(EM_SETPARAFORMAT, &p); }
	Colour		SetBackground(Colour col)				const	{ return Colour(SendMessageL(EM_SETBKGNDCOLOR, LPARAM(col))); }
	int			SetEventMask(int mask)					const	{ return SendMessageL(EM_SETEVENTMASK, mask); }
	bool		SetUndoLimit(int n = 100)				const	{ return SendMessage(EM_SETUNDOLIMIT, n); }
	Point		GetCharPos(LONG c)						const	{ POINT p; SendMessage(EM_POSFROMCHAR, &p, c); return p; }
	uint32		GetChar(const POINT &pt)				const	{ POINTL ptl = {pt.x, pt.y}; return SendMessageL(EM_CHARFROMPOS, &ptl); }
	string_getter<_range_getter> GetText(const CHARRANGE &r)	const	{ return _range_getter(*this, r); }

	uint32		GetTextLength(uint32 page = CP_ACP, uint32 flags = 0) const	{
		GETTEXTLENGTHEX t = {flags, page};
		return SendMessageL(EM_GETTEXTLENGTHEX, &t);
	}
	int			SetText2(const char *text, uint32 flags = ST_DEFAULT, uint32 cp = CP_UTF8) const {
		SETTEXTEX set = {flags, cp};
		return SendMessage(EM_SETTEXTEX, &set, text);
	}

	template<typename T> int StreamIn(int fmt, T t) const {
		EDITSTREAM es;
		es.dwCookie		= (DWORD_PTR)&t;
		es.pfnCallback	= stream_thunk<T>::f;
		return SendMessage(EM_STREAMIN, fmt, &es);
	}
	template<typename T> int StreamOut(int fmt, T t) const {
		EDITSTREAM es;
		es.dwCookie		= (DWORD_PTR)&t;
		es.pfnCallback	= stream_thunk<T>::f;
		return SendMessage(EM_STREAMOUT, fmt, &es);
	}
};

//-----------------------------------------------------------------------------
//	ListBoxControl
//-----------------------------------------------------------------------------

class ListBoxControl : public control_mixin<ListBoxControl> {
	struct _string_getter {
		Control		c;
		int			i;
		_string_getter(Control c, int i) : c(c), i(i) {}
		size_t	string_len()						const	{ return c(LB_GETTEXTLEN, i); }
#ifdef UNICODE
		size_t	string_get(char16 *s, size_t len)	const	{ return c(LB_GETTEXT, i, s); }
		size_t	string_get(char *s, size_t len)		const	{
			char16 *t = alloc_auto(char16, len + 1);
			s[len = to_utf8(t, c(LB_GETTEXT, i, t), s, len)] = 0;
			return len;
		}
#else
		size_t	string_get(char *s, size_t len)		const	{ return c(LB_GETTEXT, i, s); }
		size_t	string_get(char16 *s, size_t len)	const	{
			char	*t = alloc_auto(char, len + 1);
			s[len = chars_copy(s, t, c(LB_GETTEXT, i, t), len)] = 0;
			return len;
		}
#endif
	};
public:
	static const char *ClassName()	{ return "LISTBOX"; }

	using Base::Base;

	void		Reset()									const	{ SendMessage(LB_RESETCONTENT); }
	int			Count()									const	{ return (int)SendMessage(LB_GETCOUNT); }
	bool		SetCount(int n)							const	{ return SendMessage(LB_SETCOUNT, n) != LB_ERR; }
	int			Add(text s)								const	{ return (int)SendMessageL(LB_ADDSTRING, s); }
	int			AddFile(text s)							const	{ return (int)SendMessageL(LB_ADDFILE, s); }
	int			Insert(int i, text s)					const	{ return SendMessage(LB_INSERTSTRING, i, s); }
	int			AddData(arbitrary p)					const	{ return SendMessageL(LB_ADDSTRING, p); }
	int			InsertData(int i, arbitrary p)			const	{ return SendMessage(LB_INSERTSTRING, i, p); }
	arbitrary	GetItemData(int i)						const	{ return SendMessage(LB_GETITEMDATA, i); }
	int			SetItemData(int i, arbitrary p)			const	{ return SendMessage(LB_SETITEMDATA, i, p); }
	int			Remove(int i)							const	{ return (int)SendMessage(LB_DELETESTRING, i); }
	int			ItemHeight()							const	{ return SendMessage(LB_GETITEMHEIGHT); }
	bool		ItemHeight(int i, int height)			const	{ return SendMessage(LB_SETITEMHEIGHT, i, height) == LB_OKAY; }
	Rect		ItemRect(int i)							const	{ Rect rect; SendMessage(LB_GETITEMRECT, i, &rect); return rect; }
	uint16		GetItem(const POINT &pt)				const	{ return LOWORD(SendMessageL(LB_ITEMFROMPOINT, lparam(pt))); }
	int			GetScrollWidth()						const	{ return SendMessage(LB_GETHORIZONTALEXTENT); }
	int			SetScrollWidth(int width)				const	{ return SendMessage(LB_SETHORIZONTALEXTENT, width); }
	int			SetColumnWidth(int width)				const	{ return SendMessage(LB_SETCOLUMNWIDTH, width); }
	int			ItemsPerColumn()						const	{ return SendMessage(LB_GETLISTBOXINFO); }

	int			FindText(text s, int from = -1)			const	{ return (int)SendMessage(LB_FINDSTRING, from, s); }
	int			FindTextExact(text s, int from = -1)	const	{ return (int)SendMessage(LB_FINDSTRINGEXACT, from, s); }
	int			FindData(arbitrary p, int from = -1)	const	{ return SendMessage(LB_FINDSTRING, from, p); }
	string_getter<_string_getter>	GetItemText(int i)	const	{ return _string_getter(*this, i); }
	bool		SetTabs(int n, uint32 *p)				const	{ return !!SendMessage(LB_SETTABSTOPS, n, p); }
	bool		SetTabs(int n)							const	{ return !!SendMessage(LB_SETTABSTOPS, 1, &n); }

	// single-select
	int			Selected()								const	{ return (int)SendMessage(LB_GETCURSEL); }
	bool		Select(int i)							const	{ return SendMessage(LB_SETCURSEL, i) != LB_ERR; }
	int			SelectString(text s, int from = -1)		const	{ return SendMessage(LB_SELECTSTRING, from, s); }
	int			SelectData(arbitrary p, int from = -1)	const	{ return SendMessage(LB_SELECTSTRING, from, p); }

	// multi-select
	bool		IsSelected(int i)						const	{ return SendMessage(LB_GETSEL, i) > 0; }
	bool		Select(int i, bool sel)					const	{ return SendMessage(LB_SETSEL, i) != LB_ERR; }
	bool		SelectRange(int a, int b, bool sel)		const	{ if (sel ^ (a < b)) swap(a, b); return SendMessage(LB_SELITEMRANGEEX, a, b) != LB_ERR; }
	int			SelectedCount()							const	{ return (int)SendMessage(LB_GETSELCOUNT); }
	int			Selected(int *array, int max)			const	{ return (int)SendMessage(LB_GETSELITEMS, max, array); }
	dynamic_array<int>	SelectedArray()					const	{ dynamic_array<int> array(SelectedCount()); Selected(array.begin(), array.size32()); return array; }

	bool		EnsureVisible(int i)					const	{ return !!SendMessage(LB_SETTOPINDEX, i); }
	int			GetMinVisible()							const	{ return SendMessage(LB_GETTOPINDEX); }
	int			Dir(text spec, int attrs)				const	{ return SendMessage(LB_DIR, attrs, spec) == LB_OKAY; }
};

//-----------------------------------------------------------------------------
//	CommonControl
//-----------------------------------------------------------------------------

class CommonControl : public Control {
public:
	CommonControl() {}
	CommonControl(HWND hWnd) : Control(hWnd) {}
	bool			SetUnicodeFormat(bool use)			const	{ return !!SendMessage(CCM_SETUNICODEFORMAT, use); }
	bool			GetUnicodeFormat()					const	{ return !!SendMessage(CCM_GETUNICODEFORMAT); }
	int				SetVersion(int v)					const	{ return SendMessage(CCM_SETVERSION, v); }
	int				GetVersion()						const	{ return SendMessage(CCM_GETVERSION); }
	bool			SetNotifyWindow(Control c)			const	{ return !!SendMessage(CCM_SETNOTIFYWINDOW, (HWND)c); }
	void			SetWindowTheme(const char16 *theme)	const	{ SendMessageL(CCM_SETWINDOWTHEME, theme); }
	void			DpiScale()							const	{ SendMessage(CCM_DPISCALE, true); }
};

//-----------------------------------------------------------------------------
//	UpDownControl
//-----------------------------------------------------------------------------

class UpDownControl : public control_mixin<UpDownControl, CommonControl> {
public:
	static const char *ClassName()	{ return UPDOWN_CLASSA; }
	static const Style
		WRAP			= Style(0x0001),
		SETBUDDYINT		= Style(0x0002),
		ALIGNRIGHT		= Style(0x0004),
		ALIGNLEFT		= Style(0x0008),
		AUTOBUDDY		= Style(0x0010),
		ARROWKEYS		= Style(0x0020),
		HORZ			= Style(0x0040),
		NOTHOUSANDS		= Style(0x0080),
		HOTTRACK		= Style(0x0100);

	using Base::Base;

	void		SetRange(int a, int b)						const { SendMessage(UDM_SETRANGE32, a, b); }
	Point		GetRange()									const { Point r; SendMessage(UDM_GETRANGE32, &r.x, &r.y); return r; }
	void		SetPos(int x)								const { SendMessage(UDM_SETPOS32, x); }
	int			GetPos()									const { return SendMessage(UDM_GETPOS32); }
	Control		SetBuddy(Control c)							const { return (HWND)SendMessage(UDM_SETBUDDY, (HWND)c); }
	Control		GetBuddy()									const { return (HWND)SendMessage(UDM_GETBUDDY); }
	bool		SetAccelerator(UDACCEL *p, int n)			const { return !!SendMessage(UDM_SETACCEL, n, p); }
	int			GetAccelerator(UDACCEL *p, int n)			const { return !!SendMessage(UDM_GETACCEL, n, p); }
	int			SetBase(int n)								const { return !!SendMessage(UDM_SETBASE, n); }
	int			GetBase()									const { return !!SendMessage(UDM_GETBASE); }
};

//-----------------------------------------------------------------------------
//	PagerControl (stub)
//-----------------------------------------------------------------------------

class PagerControl : public control_mixin<PagerControl, CommonControl> {
public:
	static const char *ClassName()	{ return WC_PAGESCROLLERA; }
	static const Style
		VERT			= Style(0x0000),
		HORZ			= Style(0x0001),
		AUTOSCROLL		= Style(0x0002),
		DRAGNDROP		= Style(0x0004);

	using Base::Base;
	IDropTarget*	GetDropTarget()		const	{ IDropTarget *p; return SendMessageL(PGM_GETDROPTARGET, &p) ? p : 0; }
};

//-----------------------------------------------------------------------------
//	SysLinkControl
//-----------------------------------------------------------------------------

class SysLinkControl : public control_mixin<SysLinkControl, CommonControl> {
public:
	struct Item : LITEM {
		Item(uint32 _mask = 0)					{ mask = _mask; stateMask = 0; }
		Item(int i, uint32 _mask = 0)			{ mask = _mask | LIF_ITEMINDEX; stateMask = 0; }
		Item&	Index(int i)					{ iLink = i; mask |= LIF_ITEMINDEX; return *this; }
		Item&	ID(const char *s)				{ string_copy(szID, s); mask |= LIF_ITEMID; return *this; }
		Item&	URL(const char *s)				{ string_copy(szUrl, s); mask |= LIF_URL; return *this; }
		Item&	ChangeState(uint32 v, uint32 m)	{ state = (state & ~m) | v; stateMask |= m; mask |= LIF_STATE; return *this; }
		Item&	SetState(uint32 i)				{ return ChangeState(i, i); }
		Item&	ClearState(uint32 i)			{ return ChangeState(0, i); }
		int				Index()					{ return  iLink; }
		const char16*	ID()					{ return szID; }
		const char16*	URL()					{ return szUrl; }
		int				State()					{ return state; }

		Item&	Get(SysLinkControl c)			{ c(LVM_GETITEMA, 0, this); return *this; }
		Item&	Get(SysLinkControl c, int i)	{ Index(i); return Get(c); }
		bool	Set(SysLinkControl c)	const	{ return !!c(LM_SETITEM, 0, this); }
		bool	Set(SysLinkControl c, int i)	{ Index(i); return Set(c); }
	};

	static const char16 *ClassName()	{ return WC_LINK; }
	static const Style
		TRNSPARENT		= Style(0x0001),
		IGNORERETURN	= Style(0x0002),
		NOPREFIX		= Style(0x0004),
		USEVISUALSTYLE	= Style(0x0008),
		USECUSTOMTEXT	= Style(0x0010),
		RIGHT			= Style(0x0020);

	using Base::Base;

	Item			GetItem(int i, uint32 mask = 0)	const	{ return Item(i, mask).Get(*this); }
	int				GetIdealHeight()				const	{ return int(SendMessage(LM_GETIDEALHEIGHT)); }
	Item			HitTest(const POINT &pt, int &column) const {
		LHITTESTINFO	hti;
		hti.pt = pt;
		if (!SendMessageL(LM_HITTEST, &hti))
			hti.item.mask = 0;
		return (Item&)hti.item;
	}
};

//-----------------------------------------------------------------------------
//	AnimationControl (stub)
//-----------------------------------------------------------------------------

class AnimationControl : public control_mixin<AnimationControl, CommonControl> {
public:
	static const char *ClassName()	{ return ANIMATE_CLASSA; }
	static const Style
		CENTER			= Style(0x0001),
		TRNSPARENT		= Style(0x0002),
		AUTOPLAY		= Style(0x0004),
		TIMER			= Style(0x0008);

	using Base::Base;
};

//-----------------------------------------------------------------------------
//	MonthCalenderControl (stub)
//-----------------------------------------------------------------------------

class MonthCalenderControl : public control_mixin<MonthCalenderControl, CommonControl> {
public:
	static const char *ClassName()	{ return ANIMATE_CLASSA; }
	static const Style
		DAYSTATE				= Style(0x0001),
		MULTISELECT				= Style(0x0002),
		WEEKNUMBERS				= Style(0x0004),
		NOTODAYCIRCLE			= Style(0x0008),
		NOTODAY					= Style(0x0010),
		NOTRAILINGDATES			= Style(0x0040),
		SHORTDAYSOFWEEK			= Style(0x0080),
		NOSELCHANGEONNAV		= Style(0x0100);

	using Base::Base;
};

//-----------------------------------------------------------------------------
//	DateTimeControl (stub)
//-----------------------------------------------------------------------------
class DateTimeControl : public control_mixin<DateTimeControl, CommonControl> {
public:
	static const char *ClassName()	{ return DATETIMEPICK_CLASSA; }
	static const Style
		UPDOWN					= Style(0x0001),
		SHOWNONE				= Style(0x0002),
		SHORTDATEFORMAT			= Style(0x0000),
		LONGDATEFORMAT			= Style(0x0004),
		SHORTDATECENTURYFORMAT	= Style(0x000C),
		TIMEFORMAT				= Style(0x0009),
		APPCANPARSE				= Style(0x0010),
		RIGHTALIGN				= Style(0x0020);

	using Base::Base;
};

//-----------------------------------------------------------------------------
//	ToolTipControl
//-----------------------------------------------------------------------------

class ToolTipControl : public control_mixin<ToolTipControl, CommonControl> {
public:
	static const char *ClassName()	{ return TOOLTIPS_CLASSA; }
	static const Style
		ALWAYSTIP		= Style(0x0001),
		NOPREFIX		= Style(0x0002),
		NOANIMATE		= Style(0x0010),
		NOFADE			= Style(0x0020),
		BALLOON			= Style(0x0040),
		CLOSE			= Style(0x0080),
		USEVISUALSTYLE	= Style(0x0100);

	using Base::Base;

	bool		Add(HWND hContainer, HWND hTool, char *text = LPSTR_TEXTCALLBACKA) {
		TTTOOLINFOA		ti;
		clear(ti);
		ti.cbSize		= sizeof(ti);
		ti.uFlags		= TTF_IDISHWND | TTF_TRACK | TTF_ABSOLUTE;
		ti.hwnd			= hContainer;
		ti.uId			= (UINT_PTR)hTool;
		ti.lpszText		= text;
		return !!SendMessageL(TTM_ADDTOOLA, &ti);
	}
	bool		Remove(HWND hContainer, HWND hTool) {
		TTTOOLINFOA		ti;
		clear(ti);
		ti.cbSize		= sizeof(ti);
		ti.uFlags		= TTF_IDISHWND;
		ti.hwnd			= hContainer;
		ti.uId			= (UINT_PTR)hTool;
		return !!SendMessageL(TTM_DELTOOLA, &ti);
	}
	void		Activate(HWND hContainer, HWND hTool, bool on = true) {
		TTTOOLINFOA		ti;
		clear(ti);
		ti.cbSize		= sizeof(ti);
		ti.uFlags		= TTF_IDISHWND;
		ti.hwnd			= hContainer;
		ti.uId			= (UINT_PTR)hTool;
		SendMessage(TTM_TRACKACTIVATE, on, &ti);
	}
	void		Update(HWND hContainer, HWND hTool, const char *text = LPSTR_TEXTCALLBACKA) {
		TTTOOLINFOA		ti;
		clear(ti);
		ti.cbSize		= sizeof(ti);
		ti.uFlags		= TTF_IDISHWND | TTF_TRACK | TTF_ABSOLUTE;
		ti.hwnd			= hContainer;
		ti.uId			= (UINT_PTR)hTool;
		ti.lpszText		= (char*)text;
		SendMessageL(TTM_UPDATETIPTEXTA, &ti);
	}

	void		Activate(bool on = true)									{ SendMessage(TTM_ACTIVATE, on); }
	void		Track(const POINT &pt)										{ SendMessageL(TTM_TRACKPOSITION, MAKELPARAM(pt.x, pt.y));	}
	void		Track()														{ Track(GetMousePos() + SystemMetrics::CursorSize()); }
	bool		Add(HWND hTool, char *text = LPSTR_TEXTCALLBACKA)			{ return Add(hTool, hTool, text); }
	bool		Remove(HWND hTool)											{ return Remove(hTool, hTool); }
	void		Activate(HWND hTool, bool on = true)						{ Activate(hTool, hTool, on); }
	void		Update(HWND hTool, const char *text = LPSTR_TEXTCALLBACKA)	{ Update(hTool, hTool, text); }
};

//-----------------------------------------------------------------------------
//	TrackBarControl
//-----------------------------------------------------------------------------

class TrackBarControl : public control_mixin<TrackBarControl, CommonControl> {
public:
	static const char *ClassName()	{ return TRACKBAR_CLASSA; }
	static const Style
		AUTOTICKS			= Style(0x0001),
		RIGHT				= Style(0x0000),
		BOTTOM				= Style(0x0002),
		LEFT				= Style(0x0004),
		TOP					= Style(0x0006),
		BOTH				= Style(0x0008),
		NOTICKS				= Style(0x0010),
		ENABLESELRANGE		= Style(0x0020),
		FIXEDLENGTH			= Style(0x0040),
		NOTHUMB				= Style(0x0080),
		TOOLTIPS			= Style(0x0100),
		REVERSED			= Style(0x0200),
		DOWNISLEFT			= Style(0x0400),
		NOTIFYBEFOREMOVE	= Style(0x0800),
		TRANSPARENTBKGND	= Style(0x1000);

	using Base::Base;

	void		SetRange(int a, int b, bool redraw = true)	const { SendMessage(TBM_SETRANGE, redraw, MAKELONG(a, b));  }
	void		SetRangeMin(int a, bool redraw = true)		const { SendMessage(TBM_SETRANGEMIN, redraw, a);  }
	void		SetRangeMax(int b, bool redraw = true)		const { SendMessage(TBM_SETRANGEMAX, redraw, b);  }
	void		SetPos(int x, bool redraw = true)			const { SendMessage(TBM_SETPOS, redraw, x); }
	int			GetPos()									const { return SendMessage(TBM_GETPOS); }

	//Ticks
	void		ClearTicks(bool redraw = true)				const { SendMessage(TBM_CLEARTICS, redraw); }
	bool		SetTick(int x)								const { return !!SendMessageL(TBM_SETTIC, x); }
	void		SetTickFreq(int x)							const { SendMessage(TBM_SETTICFREQ, x); }
	int			GetTick(int i)								const { return SendMessage(TBM_GETTIC, i); }
	int			GetTickPos(int i)							const { return SendMessage(TBM_GETTICPOS, i); }
	uint32*		GetTicks()									const { return (uint32*)SendMessage(TBM_GETPTICS); }
	int			GetNumTicks()								const { return SendMessage(TBM_GETNUMTICS); }

	//Selection Range
	void		ClearSelection()							const { SendMessage(TBM_CLEARSEL); }
	int			GetSelectionEnd()							const { return SendMessage(TBM_GETSELEND); }
	int			GetSelectionStart()							const { return SendMessage(TBM_GETSELSTART); }
	bool		SetSelection(int a, int b, bool redraw = true) const { return !!SendMessage(TBM_SETSEL, redraw, MAKELONG(a, b)); }
	bool		SetSelectionStart(int a, bool redraw = true)const { return !!SendMessage(TBM_SETSELSTART, redraw, a); }
	bool		SetSelectionEnd(int b, bool redraw = true)	const { return !!SendMessage(TBM_SETSELEND, redraw, b); }
	Rect		GetChannelRect()							const { Rect r; SendMessageL(TBM_GETCHANNELRECT, &r); return r; }

	ToolTipControl	GetToolTipControl()						const	{ return (HWND)SendMessage(TBM_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)	const	{ return (HWND)SendMessage(TBM_SETTOOLTIPS, (HWND)tt); }
};

//-----------------------------------------------------------------------------
//	ProgressBarControl
//-----------------------------------------------------------------------------

class ProgressBarControl : public control_mixin<ProgressBarControl, CommonControl> {
public:
	static const char *ClassName()	{ return PROGRESS_CLASSA; }
	static const Style
		SMOOTH				= Style(0x0001),
		VERTICAL			= Style(0x0004),
		MARQUEE				= Style(0x0008),
		SMOOTHREVERSE		= Style(0x0010);

	using Base::Base;

	void		SetRange(int a, int b)						const { SendMessage(PBM_SETRANGE32, a, b); }
	Point		GetRange()									const { PBRANGE r; SendMessage(PBM_GETRANGE, FALSE, &r); return Point(r.iLow, r.iHigh); }
	void		SetStep(int s)								const { SendMessage(PBM_SETSTEP, s); }
//	int			GetStep()									const { return SendMessage(PBM_GETSTEP); }
	void		SetPos(int x)								const { SendMessage(PBM_SETPOS, x); }
	int			GetPos()									const { return SendMessage(PBM_GETPOS); }
	int			AddPos(int x)								const { return SendMessage(PBM_DELTAPOS, x); }
	void		Step()										const { SendMessage(PBM_STEPIT); }
	Colour		SetBarColour(Colour c)						const { return Colour(SendMessageL(PBM_SETBARCOLOR, c)); }
	Colour		SetBackground(Colour c)						const { return Colour(SendMessageL(PBM_SETBKCOLOR, c)); }
	void		SetMarquee(bool enable = true, float rate=0)const { SendMessage(PBM_SETMARQUEE, enable, int(rate * 1000)); }
//	Colour		GetBarColour()								const { return SendMessage(PBM_GETBARCOLOR); }
//	Colour		GetBackgroundColour()						const { return SendMessage(PBM_GETBKCOLOR); }
};

//-----------------------------------------------------------------------------
//	HeaderControl
//-----------------------------------------------------------------------------

template<typename C, typename I> struct ItemContainer : I {
	C		c;
	int		n;
	char	text[256];

	struct iterator : int_iterator<int> {
		typedef I element, &reference;
		C		c;
		I		*item;
		iterator(C c, I *item, int i) : c(c), item(item), int_iterator<int>(i) {}
		I&	get() const		{ return item->Get(c, i); }
		I*	operator->()	{ return &get(); }
		I&	operator*()		{ return get(); }
	};
	ItemContainer(C c, int n, uint32 mask) : I(mask), c(c), n(n) { I::Text(text, 256); }
	iterator begin()	{ return iterator(c, this, 0); }
	iterator end()		{ return iterator(c, this, n); }
};

template<typename C, typename I> struct FilteredItemContainer {
	C			c;
	uint32		mask;
	I			init;
	I			term;

	struct iterator {
		C			c;
		uint32		mask;
		I			item;
		iterator(C c, uint32 mask, I item) : c(c), mask(mask), item(item) {}
		I			operator*()				const	{ return item; }
		iterator&	operator++()					{ item = c.GetNextItem(item, mask); return *this; }
		iterator	operator++(int)					{ auto old = *this; item = c.GetNextItem(item, mask); return old; }
		bool	operator!=(const iterator &b) const	{ return item != b.item; }
	};

	FilteredItemContainer(C c, uint32 mask, I init, I term) : c(c), mask(mask), init(init), term(term) {}
	iterator	begin()	const	{ return iterator(c, mask, init); }
	iterator	end()	const	{ return iterator(c, mask, term); }
	I			front()	const	{ return *begin(); }
	I			back()	const	{ return *last(begin(), end()); }
	I			operator[](int i) const { return *nth(begin(), i); }
};


class HeaderControl : public control_mixin<HeaderControl, CommonControl> {
public:
	struct Item : HDITEMA {
		static const uint32 ALL = HDI_WIDTH | HDI_TEXT | HDI_FORMAT | HDI_LPARAM|HDI_IMAGE;
		Item(uint32 _mask = 0)							{ mask = _mask; }
		Item(const char *s)								{ mask = HDI_TEXT; pszText = const_cast<char*>(s); }
		Item&	Text(const char *s)						{ pszText = const_cast<char*>(s); mask |= HDI_TEXT; return *this; }
		Item&	Text(char *s, int len)					{ pszText = s; cchTextMax = len; mask |= HDI_TEXT; return *this; }
		template<int N> Item& Text(fixed_string<N> &s)	{ return Text(s, N); }
		Item&	Width(int w)							{ cxy = w; mask |= HDI_WIDTH; return *this; }
		Item&	Format(int f)							{ fmt = f; mask |= HDI_FORMAT; return *this; }
		Item&	Image(int i)							{ iImage = i; mask |= HDI_IMAGE; return *this; }
		Item&	Param(const arbitrary &p)				{ lParam = p; mask |= HDI_LPARAM; return *this; }
		Item&	Bitmap(Bitmap bm)						{ hbm = bm; mask |= HDI_BITMAP; return *this; }

		char*	Text()							const	{ return pszText; }
		int		Width()							const	{ return cxy; }
		int		Format()						const	{ return fmt; }
		int		Image()							const	{ return iImage; }
		arbitrary&	Param()						const	{ return (arbitrary&)lParam;}
		win::Bitmap	Bitmap()					const	{ return hbm; }
		bool	_Get(HeaderControl hc, int i)			{ return !!hc(HDM_GETITEMA, i, this); }
		Item&	Get(HeaderControl hc, int i)			{ _Get(hc, i); return *this; }
		bool	Set(HeaderControl hc, int i)	const	{ return !!hc(HDM_SETITEMA, i, this); }
		int		Insert(HeaderControl hc, int i = 0x7fffffff) const	{ return int(hc(HDM_INSERTITEMA, i, this)); }
	};
	static const char *ClassName()	{ return WC_HEADERA; }
	static const Style
		BUTTONS			= Style(0x0002),
		HOTTRACK		= Style(0x0004),
		HIDDEN			= Style(0x0008),
		DRAGDROP		= Style(0x0040),
		FULLDRAG		= Style(0x0080),
		FILTERBAR		= Style(0x0100),
		FLAT			= Style(0x0200),
		CHECKBOXES		= Style(0x0400),
		NOSIZING		= Style(0x0800),
		OVERFLOW		= Style(0x1000);

	using Base::Base;

	Item		GetItem(int i, int mask = 0)			const	{ return Item(mask).Get(*this, i); }
	int			DeleteItem(int i)						const	{ return SendMessage(HDM_DELETEITEM, i); }
	int			Count()									const	{ return (INT)SendMessage(HDM_GETITEMCOUNT);}
	Rect		GetItemRect(int index)					const	{ Rect rect; SendMessage(HDM_GETITEMRECT, index, &rect); return rect;}
	const char*	GetItemText(int i, char *s, int len)	const	{ Item().Text(s, len).Get(*this, i); return s; }
	template<int N> fixed_string<N>  GetItemText(int i)	const	{ fixed_string<N> s; Item().Text(s).Get(*this, i); return s; }

	WINDOWPOS	GetLayout(Rect &rect)	const {
		WINDOWPOS		wp;
		HDLAYOUT		layout;
		layout.prc		= &rect;
		layout.pwpos	= &wp;
		SendMessageL(HDM_LAYOUT, &layout);
		return wp;
	}

	ImageList	SetImageList(HIMAGELIST h)				const	{ return (HIMAGELIST)SendMessage(HDM_SETIMAGELIST, HDSIL_NORMAL, h); }
	ImageList	SetStateImageList(HIMAGELIST h)			const	{ return (HIMAGELIST)SendMessage(HDM_SETIMAGELIST, HDSIL_STATE, h); }
	ImageList	GetImageList()							const	{ return (HIMAGELIST)SendMessage(HDM_GETIMAGELIST, HDSIL_NORMAL); }
	ImageList	GetStateImageList()						const	{ return (HIMAGELIST)SendMessage(HDM_GETIMAGELIST, HDSIL_STATE); }
	ImageList	CreateDragImage(int i)					const	{ return (HIMAGELIST)SendMessage(HDM_CREATEDRAGIMAGE, i); }

	int			OrderToIndex(int i)						const	{ return SendMessage(HDM_ORDERTOINDEX, i); }
	bool		GetOrderArray(int n, int *array)		const	{ return !!SendMessage(HDM_GETORDERARRAY, n, array); }
	bool		SetOrderArray(int n, const int *array)	const	{ return !!SendMessage(HDM_SETORDERARRAY, n, array); }
	int			SetHotDivider(uint32 i)					const	{ return SendMessageL(HDM_SETHOTDIVIDER, i); }
	int			SetHotDivider(const POINT &pt)			const	{ return SendMessage(HDM_SETHOTDIVIDER, 1, &pt); }
	int			SetBitmapMargin(int width)				const	{ return SendMessage(HDM_SETBITMAPMARGIN, width); }
	int			GetBitmapMargin()						const	{ return SendMessage(HDM_GETBITMAPMARGIN); }
	int			SetFilterChangeTimeout(float t)			const	{ return SendMessageL(HDM_SETFILTERCHANGETIMEOUT, t * 1000); }
	int			EditFilter(int i, bool discard = false)	const	{ return SendMessage(HDM_EDITFILTER, i, LPARAM(discard)); }
	int			ClearFilter(int i = -1)					const	{ return SendMessage(HDM_CLEARFILTER, i); }

#if _WIN32_WINNT >= 0x0600
	Rect		GetItemDropDownRect(int i)				const	{ Rect r; SendMessage(HDM_GETITEMDROPDOWNRECT, i, &r); return r; }
	Rect		GetOverflowRect()						const	{ Rect r; SendMessageL(HDM_GETOVERFLOWRECT, &r); return r; }
	int			GetFocusedItem()						const	{ return SendMessage(HDM_GETFOCUSEDITEM); }
	bool		SetFocusedItem(int i)					const	{ return !!SendMessageL(HDM_SETFOCUSEDITEM, i); }
#endif

	int			Remaining() const { return GetClientRect().Width() - GetItemRect(Count() - 1).right; }

	auto	Items(uint32 mask = Item::ALL)	const	{ return ItemContainer<HeaderControl,Item>(*this, Count(), mask); }

	void	AddItems() const {}
	template<typename...I> void AddItems(const char *s, int w, I...i) const {
		Item(s).Width(w).Insert(*this);
		AddItems(i...);
	}
};

//-----------------------------------------------------------------------------
//	ListViewControl
//-----------------------------------------------------------------------------

class ListViewControl0 : public CommonControl {
public:
	static const Style
		REPORT					= Style(0x0001),
		SMALLICON				= Style(0x0002),
		LIST					= Style(0x0003),
		SINGLESEL				= Style(0x0004),
		SHOWSELALWAYS			= Style(0x0008),
		SORTASCENDING			= Style(0x0010),
		SORTDESCENDING			= Style(0x0020),
		SHAREIMAGELISTS			= Style(0x0040),
		NOLABELWRAP				= Style(0x0080),
		AUTOARRANGE				= Style(0x0100),
		EDITLABELS				= Style(0x0200),
		OWNERDATA				= Style(0x1000),
		NOSCROLL				= Style(0x2000),
		ALIGNTOP				= Style(0x0000),
		ALIGNLEFT				= Style(0x0800),
		ALIGNMASK				= Style(0x0c00),
		OWNERDRAWFIXED			= Style(0x0400),
		NOCOLUMNHEADER			= Style(0x4000),
		NOSORTHEADER			= Style(0x8000);
	enum ListStyle {
		GRIDLINES				= 0x0001,
		SUBITEMIMAGES			= 0x0002,
		CHECKBOXES				= 0x0004,
		TRACKSELECT				= 0x0008,
		HEADERDRAGDROP			= 0x0010,
		FULLROWSELECT			= 0x0020,
		ONECLICKACTIVATE		= 0x0040,
		TWOCLICKACTIVATE		= 0x0080,
		FLATSB					= 0x0100,
		REGIONAL				= 0x0200,
		INFOTIP					= 0x0400,
		UNDERLINEHOT			= 0x0800,
		UNDERLINECOLD			= 0x1000,
		MULTIWORKAREAS			= 0x2000,
		LABELTIP				= 0x4000,
		BORDERSELECT			= 0x8000,
		DOUBLEBUFFER			= 0x00010000,
		HIDELABELS				= 0x00020000,
		SINGLEROW				= 0x00040000,
		SNAPTOGRID				= 0x00080000,
		SIMPLESELECT			= 0x00100000,
		JUSTIFYCOLUMNS			= 0x00200000,
		TRANSPARENTBKGND		= 0x00400000,
		TRANSPARENTSHADOWTEXT	= 0x00800000,
		AUTOAUTOARRANGE			= 0x01000000,
		HEADERINALLVIEWS		= 0x02000000,
		AUTOCHECKSELECT			= 0x08000000,
		AUTOSIZECOLUMNS			= 0x10000000,
		COLUMNSNAPPOINTS		= 0x40000000,
		COLUMNOVERFLOW			= 0x80000000,
	};
	friend nodebug_inline constexpr ListStyle operator|(ListStyle a, ListStyle b)	{ return ListStyle((int)a | (int)b); }
	enum REGION {
		BOUNDS			= LVIR_BOUNDS,		// Returns the bounding rectangle of the entire item, including the icon and label.
		ICON			= LVIR_ICON,		// Returns the bounding rectangle of the icon or small icon.
		LABEL			= LVIR_LABEL,		// Returns the bounding rectangle of the item text.
		SELECTBOUNDS	= LVIR_SELECTBOUNDS,// Returns the union of the LVIR_ICON and LVIR_LABEL rectangles, but excludes columns in report view.
	};
	enum VIEW {
		ICON_VIEW		= LV_VIEW_ICON,
		DETAIL_VIEW		= LV_VIEW_DETAILS,
		SMALLICON_VIEW	= LV_VIEW_SMALLICON,
		LIST_VIEW		= LV_VIEW_LIST,
		TILE_VIEW		= LV_VIEW_TILE,
	};

	//	Column
	template<typename C, typename S> struct ColumnT0 : S {
		static const uint32 ALL = LVCF_WIDTH | LVCF_TEXT | LVCF_FMT | LVCF_IMAGE | LVCF_SUBITEM | LVCF_ORDER;
		ColumnT0(uint32 _mask = 0)								{ clear(*this); mask = _mask; }
		ColumnT0(textT<C> s)									{ clear(*this); mask = LVCF_TEXT; pszText = unconst((const C*)s); }
		ColumnT0&		Text(const C *s)						{ pszText = const_cast<char*>(s); mask |= LVCF_TEXT; return *this; }
		ColumnT0&		Text(C *s, int len)						{ pszText = s; cchTextMax = len; mask |= LVCF_TEXT; return *this; }
		template<int N> ColumnT0& Text(fixed_string<N> &s)		{ return Text(s, N); }
		ColumnT0&		Width(int w)							{ cx = w; mask |= LVCF_WIDTH; return *this; }
		ColumnT0&		Format(int f)							{ fmt = f; mask |= LVCF_FMT; return *this; }

		C*			Text()							const		{ return pszText; }
		int			Format()						const		{ return fmt; }
		int			Width()							const		{ return cx; }
#if _WIN32_WINNT >= 0x0600
		ColumnT0&		Snap(int min, int def)						{ cxMin = min; cxDefault = def; mask |= LVCF_MINWIDTH | LVCF_DEFAULTWIDTH; return *this; }
#endif
		bool		_Get(ListViewControl0 list, int i)			{ return !!list(LVM_GETCOLUMNA, i, this); }
		ColumnT0&	Get(ListViewControl0 list, int i)			{ _Get(list, i); return *this; }
		bool		Set(ListViewControl0 list, int i)	const	{ return !!list(LVM_SETCOLUMNA, i, this); }
		int			Insert(ListViewControl0 list, int i = 0x7fffffff) const	{ return list(LVM_INSERTCOLUMNA, i, this); }
	};

	template<typename C> struct ColumnT1;
	template<> struct ColumnT1<char>	: T_type<ColumnT0<char, LVCOLUMNA>> {};
	template<> struct ColumnT1<char16>	: T_type<ColumnT0<char16, LVCOLUMNW>> {};
	template<typename C> using ColumnT = typename ColumnT1<C>::type;

	//	Item
	template<typename C, typename S> struct ItemT0 : S {
		static const uint32 ALL = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE | LVIF_INDENT | LVIF_GROUPID;
		ItemT0(uint32 _mask = 0)								{ iSubItem = 0; mask = _mask; stateMask = 0; }
		ItemT0(textT<C> s)										{ iSubItem = 0; pszText = unconst((const C*)s); mask = LVIF_TEXT; stateMask = 0; }
		template<int N> ItemT0(fixed_string<N> &s)				{ iSubItem = 0; pszText = s; cchTextMax = N; mask = LVIF_TEXT; stateMask = 0; }
		ItemT0&		Index(int i)								{ iItem = i; return *this; }
		ItemT0&		Column(int i)								{ iSubItem = i; mask &= ~(LVIF_PARAM | LVIF_GROUPID); return *this; }
		ItemT0&		NextColumn()								{ ++iSubItem; mask &= ~(LVIF_PARAM | LVIF_GROUPID); return *this; }
		ItemT0&		Text(textT<C> s)							{ const C *s0 = s; pszText = unconst(s0 ? s0 : ""); mask |= LVIF_TEXT; return *this; }
		ItemT0&		Text(C *s, int len)							{ pszText = s; cchTextMax = len; mask |= LVIF_TEXT; return *this; }
		template<int N> ItemT0& Text(fixed_string<N> &s)		{ return Text(s, N); }
		ItemT0&		Image(int i)								{ iImage = i; mask |= LVIF_IMAGE; return *this; }
		ItemT0&		Param(const arbitrary &p)					{ lParam = p; mask |= LVIF_PARAM; return *this; }
		ItemT0&		ChangeState(uint32 v, uint32 m)				{ state = (state & ~m) | v; stateMask |= m; mask |= LVIF_STATE; return *this; }
		ItemT0&		SetState(uint32 i)							{ return ChangeState(i, i); }
		ItemT0&		ClearState(uint32 i)						{ return ChangeState(0, i); }
		ItemT0&		GroupId(uint32 i)							{ iGroupId = i; mask |= LVIF_GROUPID; return *this; }
		ItemT0&		TileInfo(const uint32 *p, uint32 n)			{ puColumns = const_cast<uint32*>(p); cColumns = n; mask |= LVIF_COLUMNS; return *this; }
		template<int N> ItemT0& TileInfo(const uint32 (&p)[N])	{ return TileInfo(p, N); }

		C*			Text()								const	{ return pszText; }
		auto		TextBuffer()						const	{ return string_bufferT<C>(pszText, cchTextMax); }
		int			Index()								const	{ return iItem; }
		int			Column()							const	{ return iSubItem; }
		arbitrary&	Param()								const	{ return (arbitrary&)lParam; }
		uint32		State()								const	{ return state; }
		int			Image()								const	{ return iImage; }
		uint32		GroupId()							const	{ return iGroupId; }

		bool		_Get(ListViewControl0 list, int i)			{ iItem = i; return !!list(LVM_GETITEMA, 0, this); }
		ItemT0&		Get(ListViewControl0 list, int i)			{ if (!_Get(list, i)) clear(*this); return *this; }
		bool		Set(ListViewControl0 list, int i)			{ iItem = i; return !!list(LVM_SETITEMA, 0, this); }
		bool		Set(ListViewControl0 list)			const	{ return !!list(LVM_SETITEMA, 0, this); }
		int			Insert(ListViewControl0 list, int i = 0x7fffffff) { iItem = i; return iItem = list(LVM_INSERTITEMA, 0, this); }
		bool		Delete(ListViewControl0 list)		const	{ return !!list.SendMessage(LVM_DELETEITEM, iItem); }
	};

	template<typename C> struct ItemT1;
	template<> struct ItemT1<char>		: T_type<ItemT0<char, LVITEMA>> {};
	template<> struct ItemT1<char16>	: T_type<ItemT0<char16, LVITEMW>> {};
	template<typename C> using ItemT = typename ItemT1<C>::type;

	//	Group
	struct Group : LVGROUP {
		Group(uint32 _mask = 0)									{ clear(*this); cbSize = sizeof(*this); mask = _mask; }
		Group(const char16 *s)									{ clear(*this); cbSize = sizeof(*this); mask = LVGF_HEADER; pszHeader = unconst(s); }
		Group&		ID(int i)									{ iGroupId = i; mask |= LVGF_GROUPID; return *this; }
		Group&		Image(int i)								{ iTitleImage = i; mask |= LVGF_TITLEIMAGE; return *this; }
		Group&		ChangeState(uint32 v, uint32 m)				{ state = (state & ~m) | v; stateMask |= m; mask |= LVGF_STATE; return *this; }
		Group&		SetState(uint32 i)							{ return ChangeState(i, i); }
		Group&		ClearState(uint32 i)						{ return ChangeState(0, i); }

		char16*		Text()								const	{ return pszHeader; }
		int			ID()								const	{ return iGroupId; }
		uint32		State()								const	{ return state; }
		int			Image()								const	{ return iTitleImage; }

		int			_GetByID(ListViewControl0 list, int id)		{ return list(LVM_GETGROUPINFO, id, this); }
		int			_GetByIndex(ListViewControl0 list, int i)	{ return list(LVM_GETGROUPINFOBYINDEX, i, this);}
		Group&		GetByID(ListViewControl0 list, int id)		{ _GetByID(list, id); return *this; }
		Group&		GetByIndex(ListViewControl0 list, int i)	{ _GetByIndex(list, i); return *this; }
		bool		Set(ListViewControl0 list, int id)			{ return list(LVM_SETGROUPINFO, id, this); }
		int			Set(ListViewControl0 list)			const	{ return list(LVM_SETGROUPINFO, iGroupId, this); }
		int			Insert(ListViewControl0 list, int i = -1)	{ return list(LVM_INSERTGROUP, i, this); }
	};

	//	TileInfo
	struct TileInfo : LVTILEVIEWINFO {
		TileInfo()												{ clear(*this); cbSize = sizeof(*this); dwFlags = LVTVIF_AUTOSIZE; }
		TileInfo(int lines)										{ clear(*this); cbSize = sizeof(*this); dwMask = LVTVIM_COLUMNS; cLines = lines; dwFlags = LVTVIF_AUTOSIZE; }
		TileInfo(const POINT &size)								{ clear(*this); cbSize = sizeof(*this); dwMask = LVTVIM_TILESIZE; (POINT&)sizeTile = size; dwFlags = LVTVIF_FIXEDSIZE; }
		TileInfo&		Width(int w)							{ sizeTile.cx = w; dwMask |= LVTVIM_TILESIZE; dwFlags |= LVTVIF_FIXEDWIDTH; return *this; }
		TileInfo&		Height(int h)							{ sizeTile.cy = h; dwMask |= LVTVIM_TILESIZE; dwFlags |= LVTVIF_FIXEDHEIGHT; return *this; }
		TileInfo&		Size(const POINT &size)					{ (POINT&)sizeTile = size; dwMask |= LVTVIM_TILESIZE; dwFlags |= LVTVIF_FIXEDSIZE; return *this; }
		TileInfo&		Lines(int n)							{ cLines = n; dwMask |= LVTVIM_COLUMNS; return *this; }
		TileInfo&		Margin(const RECT &r)					{ rcLabelMargin = r; dwMask |= LVTVIM_LABELMARGIN; return *this; }
		int				Width()							const	{ return sizeTile.cx; }
		int				Height()						const	{ return sizeTile.cy; }
		Point			Size()							const	{ return (const Point&)sizeTile; }
		int				Lines()							const	{ return cLines; }
		Rect			Margin()						const	{ return (const Rect&)rcLabelMargin; }
		bool			Set(ListViewControl0 list)		const	{ return !!list(LVM_SETTILEVIEWINFO, 0, this); }
	};

	ListViewControl0()	{}
	ListViewControl0(Control c) : CommonControl(c) {}
	ListViewControl0(HWND hWnd) : CommonControl(hWnd) {}

	HeaderControl	GetHeader()							const	{ return (HWND)SendMessage(LVM_GETHEADER); }
	uint32			NumColumns()						const	{ return GetHeader().Count(); }

	bool			DeleteColumn(int i)					const	{ return !!SendMessage(LVM_DELETECOLUMN, i); }
	int				GetColumnWidth(int i)				const	{ return SendMessage(LVM_GETCOLUMNWIDTH, i); }
	bool			SetColumnWidth(int i, int width)	const	{ return !!SendMessage(LVM_SETCOLUMNWIDTH, i, width); }

	bool			DeleteAll()							const	{ return !!SendMessage(LVM_DELETEALLITEMS); }
	bool			DeleteItem(int i)					const	{ return !!SendMessage(LVM_DELETEITEM, i); }
	int				Count()								const	{ return int(SendMessage(LVM_GETITEMCOUNT)); }
	bool			SetCount(int n, uint32 flags = 0)	const	{ return !!SendMessage(LVM_SETITEMCOUNT, n, flags); }

	Rect			GetItemRect(int i, REGION r = BOUNDS) const {
		Rect rect;
		rect.left = r;
		SendMessage(LVM_GETITEMRECT, i, LPARAM(&rect));
		return rect;
	}
	Rect			GetSubItemRect(int i, int column, REGION r = BOUNDS)	const	{
		Rect rect;
		rect.left = r;
		if (column == 0) {
			SendMessage(LVM_GETITEMRECT, i, LPARAM(&rect));
		} else {
			rect.top = column;
			SendMessage(LVM_GETSUBITEMRECT, i, LPARAM(&rect));
		}
		return rect;
	}
	bool			SetItemTileInfo(int i, const uint32 *p, uint32 n)	const	{
		LVTILEINFO info = {
			sizeof(LVTILEINFO), i, n, const_cast<uint32*>(p)
#if _WIN32_WINNT >= 0x0600
			, 0
#endif
		};
		return !!SendMessageL(LVM_SETTILEINFO, LPARAM(&info));
	}
	template<int N> bool SetItemTileInfo(int i, const uint32 (&p)[N])	const	{ return SetItemTileInfo(i, p, N); }

	int				GetSelectionMark()					const	{ return SendMessage(LVM_GETSELECTIONMARK); }
	int				SetSelectionMark(int i)				const	{ return SendMessageL(LVM_SETSELECTIONMARK, i); }

	int				GetNextItem(int i, uint32 m)		const	{ return SendMessage(LVM_GETNEXTITEM, i, m); }
	int				GetSelectionCount()					const	{ return SendMessage(LVM_GETSELECTEDCOUNT); }
	bool			EnsureVisible(int i, bool partial=false) const	{ return !!SendMessage(LVM_ENSUREVISIBLE, i, partial); }
	bool			IsVisible(int i)					const	{ return !!SendMessage(LVM_ISITEMVISIBLE, i); }

	bool			SetView(VIEW v)						const	{ return SendMessage(LVM_SETVIEW, v) > 0; }
	VIEW			GetView()							const	{ return (VIEW)SendMessage(LVM_GETVIEW); }
	uint32			SetExtendedStyle(ListStyle styleEx, uint32 mask) const { return SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, mask, styleEx); }
	uint32			SetExtendedStyle(ListStyle styleEx)	const	{ return SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, styleEx, styleEx); }
	uint32			ClearExtendedStyle(ListStyle styleEx) const	{ return SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, styleEx); }
	ListStyle		GetExtendedStyle()					const	{ return (ListStyle)SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE); }

	bool			SetBackground(Colour col)			const	{ return !!SendMessageL(LVM_SETBKCOLOR, col); }
	bool			SetTextColour(Colour col)			const	{ return !!SendMessageL(LVM_SETTEXTCOLOR, col); }
	bool			SetTextBackground(Colour col)		const	{ return !!SendMessageL(LVM_SETTEXTBKCOLOR, col); }
	Colour			GetBackground()						const	{ return Colour((COLORREF)SendMessage(LVM_GETBKCOLOR)); }
	Colour			GetTextColour()						const	{ return Colour((COLORREF)SendMessage(LVM_GETTEXTCOLOR)); }
	Colour			GetTextBackground()					const	{ return Colour((COLORREF)SendMessage(LVM_GETTEXTBKCOLOR)); }
	ImageList		SetImageList(HIMAGELIST im, int type)const	{ return (HIMAGELIST)SendMessage(LVM_SETIMAGELIST, type, im); }
	ImageList		SetIcons(HIMAGELIST im)				const	{ return SetImageList(im, LVSIL_NORMAL); }
	ImageList		SetSmallIcons(HIMAGELIST im)		const	{ return SetImageList(im, LVSIL_SMALL); }
	ImageList		SetStateImages(HIMAGELIST im)		const	{ return SetImageList(im, LVSIL_STATE); }
	ImageList		SetGroupImages(HIMAGELIST im)		const	{ return SetImageList(im, LVSIL_GROUPHEADER); }
	ImageList		CreateDragImage(int i, Point &tl)	const { return (HIMAGELIST)SendMessage(LVM_CREATEDRAGIMAGE, i, &tl); }

	ToolTipControl	GetToolTipControl()					const	{ return (HWND)SendMessage(LVM_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)const	{ return (HWND)SendMessage(LVM_SETTOOLTIPS, (HWND)tt); }
	EditControl		EditLabel(int i)					const	{ return (HWND)SendMessage(LVM_EDITLABEL, i); }
	void			CancelEditLabel()					const	{ SendMessage(LVM_CANCELEDITLABEL); }

	bool			EnableGroups(bool enable=true)		const	{ return SendMessage(LVM_ENABLEGROUPVIEW, enable) > 0; }
	bool			RemoveGroup(int id)					const	{ return SendMessage(LVM_REMOVEGROUP, id) > 0; }
	Group			GroupByID(int id)					const	{ return Group().GetByID(*this, id); }
	Group			GroupByIndex(int i)					const	{ return Group().GetByIndex(*this, i); }
	int				NumGroups()							const	{ return SendMessage(LVM_GETGROUPCOUNT); }
	Rect			GetGroupRect(int id, int type = LVGGR_GROUP) const	{ Rect r; r.top = type; SendMessage(LVM_GETGROUPRECT, id, &r); return r; }
	uint32			GetGroupState(int id, uint32 mask)	const	{ return SendMessage(LVM_GETGROUPSTATE, id, mask); }

	int				HitTest(const POINT &pt, LVHITTESTINFO &hti) const {
		hti.pt = pt;
		return SendMessageL(LVM_SUBITEMHITTEST, &hti);
	}
	int				HitTest(const POINT &pt, int &column) const {
		LVHITTESTINFO	hti;
		int	i = HitTest(pt, hti);
		if (i >= 0)
			column = hti.iSubItem;
		return i;
	}

	void Autosize() const {
		for (int i = 0, n = NumColumns(); i < n; i++)
			SetColumnWidth(i, LVSCW_AUTOSIZE);
	}
	void ResizeAutoLast(const POINT &pt) const {
		Resize(pt);
		SetColumnWidth(NumColumns() - 1, LVSCW_AUTOSIZE_USEHEADER);
	}

	template<typename T> bool SortByParam(T t) {
		struct thunk {
			static int CALLBACK f(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)	{ return (*(T*)lParamSort)((arbitrary&)lParam1, (arbitrary&)lParam2); }
		};
		return !!SendMessage(LVM_SORTITEMS, &t, &thunk::f);
	}
	template<typename T> bool SortByParam(bool up, T t) {
		struct thunk {
			static int CALLBACK down(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort) { return (*(T*)lParamSort)((arbitrary&)lParam2, (arbitrary&)lParam1); }
			static int CALLBACK up(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)	{ return (*(T*)lParamSort)((arbitrary&)lParam1, (arbitrary&)lParam2); }
		};
		return !!SendMessage(LVM_SORTITEMS, &t, up ? &thunk::up : &thunk::down);
	}
	template<typename T> bool SortByIndex(T t) {
		struct thunk {
			static int CALLBACK f(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)	{ return (*(T*)lParamSort)(lParam1, lParam2); }
		};
		return !!SendMessage(LVM_SORTITEMSEX, &t, &thunk::f);
	}
	template<typename T> bool SortByIndex(bool up, T t) {
		struct thunk {
			static int CALLBACK down(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)	{ return (*(T*)lParamSort)(lParam1, lParam2); }
			static int CALLBACK up(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)	{ return (*(T*)lParamSort)(lParam1, lParam2); }
		};
		return !!SendMessage(LVM_SORTITEMSEX, &t, up ? &thunk::up : &thunk::down);
	}

	auto	SomeItems(uint32 mask)				const	{ return FilteredItemContainer<ListViewControl0, int>(*this, mask, -1, GetNextItem(-1, mask)); }
	auto	Selected()							const	{ return SomeItems(LVNI_SELECTED); }
};

template<typename C> class ListViewControlT : public control_mixin<ListViewControlT<C>, ListViewControl0> {
	typedef ListViewControl0 Base;

	struct _string_getter {
		Control			c;
		int				i, col;
		_string_getter(Control c, int i, int col) : c(c), i(i), col(col) {}
		size_t	string_len()						const	{ return 0; }
		size_t	string_get(char *s, size_t len)		const	{ return (size_t)c(LVM_GETITEMTEXT, i, &Item().Column(col).Text(s, (int)len)); }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
public:
	typedef typename ListViewControl0::ColumnT<C>	Column;
	typedef typename ListViewControl0::ItemT<C>		Item;
	static const C *ClassName();

	using control_mixin<ListViewControlT<C>, ListViewControl0>::control_mixin;

	//HWND		Create(const WindowPos &wpos, text title, Style style, ListViewControl0::ListStyle styleEx, ID id = ID()) {
	//	HWND h = control_mixin<ListViewControlT<C>, ListViewControl0>::Create(wpos, title, style, NOEX, id);
	//	SetExtendedStyle(styleEx);
	//	return h;
	//}
	Column			GetColumn(int i, uint32 mask = 0)	const	{ return Column(mask).Get(*this, i); }

	Item			GetItem(int i)									const	{ return Item().Get(*this, i); }
	Item			GetItem(int i, int col, uint32 mask = 0)		const	{ return Item(mask).Column(col).Get(*this, i); }
	bool			ChangeItemState(int i, uint32 v, uint32 m)		const	{ LVITEM item; item.state = v; item.stateMask = m; return !!SendMessage(LVM_SETITEMSTATE, i, &item); }
	bool			SetItemState(int i, uint32 v)					const	{ return ChangeItemState(i, v, v); }
	bool			ClearItemState(int i, uint32 v)					const	{ return ChangeItemState(i, 0, v); }
	uint32			GetItemState(int i, uint32 m)					const	{ return SendMessage(LVM_GETITEMSTATE, i, m); }
	string_getter<_string_getter> GetItemText(int i, int col = 0)	const	{ return _string_getter(*this, i, col); }
	bool			SetItemText(int i, const char *s, int col = 0)	const	{ return Item(s).Column(col).Set(*this, i); }
	arbitrary		GetItemParam(int i)								const	{ return Item(LVIF_PARAM).Get(*this, i).Param(); }

	auto	Items(uint32 mask = Item::ALL)		const	{ return ItemContainer<ListViewControlT,Item>(*this, Count(), mask); }
	auto	Columns(uint32 mask = Column::ALL)	const	{ return ItemContainer<ListViewControlT,Column>(*this, NumColumns(), mask); }

	void AddColumns() const {}
	void AddColumns(const C *s) const {
		Column(s).Insert(*this);
	}
	template<typename...I> void AddColumns(const C *s, int w, I...i) const {
		Column(s).Width(w).Insert(*this);
		AddColumns(i...);
	}
	template<typename...I> void AddColumns(const C *s, int w, int f, I...i) const {
		Column(s).Width(w).Format(f).Insert(*this);
		AddColumns(i...);
	}
};

typedef ListViewControlT<char>		ListViewControl;
typedef ListViewControlT<char16>	ListViewControl16;

template<> inline const char*	ListViewControl::ClassName()	{ return WC_LISTVIEWA; }
template<> inline const char16*	ListViewControl16::ClassName()	{ return WC_LISTVIEWW; }

//-----------------------------------------------------------------------------
//	TabControl
//-----------------------------------------------------------------------------

class TabControl : public control_mixin<TabControl, CommonControl> {
public:
	struct Item : TCITEMA {
		const static uint32 ALL = TCIF_TEXT | TCIF_IMAGE | TCIF_RTLREADING| TCIF_PARAM| TCIF_STATE;
		Item(uint32 _mask = 0)								{ clear(*this); mask = _mask; }
		Item&		Text(text s)							{ pszText = unconst(s.begin()); mask |= TCIF_TEXT; return *this; }
		Item&		Text(char *s, int len)					{ pszText = s; cchTextMax = len; mask |= TCIF_TEXT; return *this; }
		template<int N> Item& Text(fixed_string<N> &s)		{ return Text(s, N); }
		Item&		Image(int i)							{ iImage = i; mask |= TCIF_IMAGE; return *this; }
		Item&		Param(const arbitrary &p)				{ lParam = p; mask |= TCIF_PARAM; return *this; }

		char*		Text()							const	{ return pszText; }
		int			Image()							const	{ return iImage; }
		arbitrary&	Param()							const	{ return (arbitrary&)lParam; }
		bool		Set(TabControl tab, int i)		const	{ return !!tab(TCM_SETITEM, i, this); }
		int			Insert(TabControl tab, int i = 0x7fffffff)	const	{ return tab(TCM_INSERTITEM, i, this); }
		bool		_Get(TabControl tab, int i)				{ return !!tab(TCM_GETITEM, i, this); }
		Item&		Get(TabControl tab, int i)				{ _Get(tab, i); return *this; }
	};
	static const char *ClassName()	{ return WC_TABCONTROLA; }
	static const Style
		SCROLLOPPOSITE		= Style(0x0001),
		BOTTOM				= Style(0x0002),
		RIGHT				= Style(0x0002),
		MULTISELECT			= Style(0x0004),
		FLATBUTTONS			= Style(0x0008),
		FORCEICONLEFT		= Style(0x0010),
		FORCELABELLEFT		= Style(0x0020),
		HOTTRACK			= Style(0x0040),
		VERTICAL			= Style(0x0080),
		BUTTONS				= Style(0x0100),
		MULTILINE			= Style(0x0200),
		FIXEDWIDTH			= Style(0x0400),
		RAGGEDRIGHT			= Style(0x0800),
		FOCUSONBUTTONDOWN	= Style(0x1000),
		OWNERDRAWFIXED		= Style(0x2000),
		TOOLTIPS			= Style(0x4000),
		FOCUSNEVER			= Style(0x8000);
	enum TabStyle {
		FLATSEPARATORS		= 0x0001,
		REGISTERDROP		= 0x0002,
	};
	friend TabStyle	operator|(TabStyle a, TabStyle b) { return (TabStyle)(uint32(a) | uint32(b)); }

	using Base::Base;

	uint32		SetExtendedStyle(TabStyle styleEx, uint32 mask) const { return SendMessage(TCM_SETEXTENDEDSTYLE, mask, styleEx); }
	uint32		SetExtendedStyle(TabStyle styleEx)			const	{ return SendMessage(TCM_SETEXTENDEDSTYLE, styleEx, styleEx); }
	uint32		ClearExtendedStyle(TabStyle styleEx)		const	{ return SendMessage(TCM_SETEXTENDEDSTYLE, styleEx); }
	TabStyle	GetExtendedStyle()							const	{ return (TabStyle)SendMessage(TCM_GETEXTENDEDSTYLE); }

	void		SetPadding(int x, int y)					const	{ SendMessageL(TCM_SETPADDING, lparam(x, y)); }
	int			Count()										const	{ return int(SendMessage(TCM_GETITEMCOUNT)); }
	int			NumRows()									const	{ return SendMessage(TCM_GETROWCOUNT); }

	bool		RemoveItem(int i)							const	{ return !!SendMessage(TCM_DELETEITEM, i); }
	int			SetSelectedIndex(int i)						const	{ return SendMessage(TCM_SETCURSEL, i); }
	int			GetSelectedIndex()							const	{ return int(SendMessage(TCM_GETCURSEL)); }

	Item		GetItem(int i, int mask = TCIF_PARAM)		const	{ return Item(mask).Get(*this, i); }
	Rect		GetItemRect(int i)							const	{ Rect rect; SendMessage(TCM_GETITEMRECT, i, LPARAM(&rect)); return rect; }

	Rect&		AdjustRect(Rect &rect, bool client = false)	const	{ SendMessage(TCM_ADJUSTRECT, client, LPARAM(&rect)); return rect; }
//	Rect		GetChildRect()								const	{ Rect rect = GetClientRect(); SendMessage(TCM_ADJUSTRECT, FALSE, LPARAM(&rect)); return rect; }
	Rect		GetChildRect()								const	{ return GetClientRect() + Rect(4, 23, -4, -(23 + 4)); }
	Rect		GetTabStrip()								const	{ return GetClientRect().Subbox(4, 0, -4, 23); }
	WindowPos	GetChildWindowPos()							const	{ return WindowPos(*this, GetChildRect()); }
	Rect		GetDisplayRect()							const	{ Rect rect = GetRect(); SendMessage(TCM_ADJUSTRECT, FALSE, LPARAM(&rect)); return rect; }
	int			HitTest(const POINT &pt)					const;

	ImageList	SetImageList(HIMAGELIST h)					const	{ return (HIMAGELIST)SendMessageL(TCM_SETIMAGELIST, h); }
	ImageList	GetImageList()								const	{ return (HIMAGELIST)SendMessage(TCM_GETIMAGELIST); }
	bool		RemoveImage(int i)							const	{ return !!SendMessage(TCM_REMOVEIMAGE, i); }

	ToolTipControl	GetToolTipControl()						const	{ return (HWND)SendMessage(TCM_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)	const	{ return (HWND)SendMessage(TCM_SETTOOLTIPS, (HWND)tt); }

	auto		Items(uint32 mask = Item::ALL)				const	{ return ItemContainer<TabControl,Item>(*this, Count(), mask); }
};

//-----------------------------------------------------------------------------
//	ComboControl
//-----------------------------------------------------------------------------

class ComboControl : public control_mixin<ComboControl, CommonControl> {
	struct _string_getter {
		Control		c;
		int			i;
		_string_getter(Control c, int i) : c(c), i(i) {}
		size_t	string_len()						const	{ return c(CB_GETLBTEXTLEN, i); }
	#ifdef UNICODE
		size_t	string_get(char16 *s, size_t len)	const	{ return c(CB_GETLBTEXT, i, s); }
		size_t	string_get(char *s, size_t len)		const	{ return string_getter_transform<char16>(*this, s, len); }
	#else
		size_t	string_get(char *s, size_t len)		const	{ return c(CB_GETLBTEXT, i, s); }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	#endif
	};
public:
	static const char *ClassName()	{ return WC_COMBOBOXA; }
	static const Style
		SIMPLE				= Style(0x0001L),
		DROPDOWN			= Style(0x0002L),
		DROPDOWNLIST		= Style(0x0003L),
		OWNERDRAWFIXED		= Style(0x0010L),
		OWNERDRAWVARIABLE	= Style(0x0020L),
		AUTOHSCROLL			= Style(0x0040L),
		OEMCONVERT			= Style(0x0080L),
		SORT				= Style(0x0100L),
		HASSTRINGS			= Style(0x0200L),
		NOINTEGRALHEIGHT	= Style(0x0400L),
		DISABLENOSCROLL		= Style(0x0800L),
		UPPERCASE			= Style(0x2000L),
		LOWERCASE			= Style(0x4000L);
	static const StyleEx
		NOEDITIMAGE			= StyleEx(0x0001),
		NOEDITIMAGEINDENT	= StyleEx(0x0002),
		PATHWORDBREAKPROC	= StyleEx(0x0004),
		NOSIZELIMIT			= StyleEx(0x0008),
		CASESENSITIVE		= StyleEx(0x0010),
		TEXTENDELLIPSIS		= StyleEx(0x0020);

	using Base::Base;

	void		Reset()									const	{ SendMessage(CB_RESETCONTENT); }
	int			Count()									const	{ return (int)SendMessage(CB_GETCOUNT); }
	int			Add(text s)								const	{ return (int)SendMessageL(CB_ADDSTRING, s); }
	int			Insert(int i, text s)					const	{ return SendMessage(CB_INSERTSTRING, i, s); }
	int			AddData(arbitrary p)					const	{ return SendMessageL(CB_ADDSTRING, p); }
	int			InsertData(int i, arbitrary p)			const	{ return SendMessage(CB_INSERTSTRING, i, p); }
	arbitrary	GetItemData(int i)						const	{ return SendMessage(CB_GETITEMDATA, i); }
	int			SetItemData(int i, arbitrary p)			const	{ return SendMessage(CB_SETITEMDATA, i, p); }
	int			Remove(int i)							const	{ return (int)SendMessage(CB_DELETESTRING, i); }
	int			ItemHeight()							const	{ return SendMessage(CB_GETITEMHEIGHT); }
	bool		ItemHeight(int i, int height)			const	{ return SendMessage(CB_SETITEMHEIGHT, i, height) == CB_OKAY; }

	int			FindText(text s, int from = -1)			const	{ return (int)SendMessage(CB_FINDSTRING, from, s); }
	int			FindTextExact(text s, int from = -1)	const	{ return (int)SendMessage(CB_FINDSTRINGEXACT, from, s); }
	int			FindData(arbitrary p, int from = -1)	const	{ return SendMessage(CB_FINDSTRING, from, p); }
	string_getter<_string_getter>	GetItemText(int i)	const	{ return _string_getter(*this, i); }
	int			Selected()								const	{ return (int)SendMessage(CB_GETCURSEL); }
	bool		Select(int i)							const	{ return SendMessage(CB_SETCURSEL, i) != CB_ERR; }
	int			SelectString(text s, int from = -1)		const	{ return SendMessage(CB_SELECTSTRING, from, s); }
	int			SelectData(arbitrary p, int from = -1)	const	{ return SendMessage(CB_SELECTSTRING, from, p); }

	bool		EnsureVisible(int i)					const	{ return !!SendMessage(CB_SETMINVISIBLE, i); }
	int			GetMinVisible()							const	{ return SendMessage(CB_GETMINVISIBLE); }
	int			SetDroppedWidth(int i)					const	{ return SendMessage(CB_SETDROPPEDWIDTH, i); }
	bool		SetCueBannerText(text text)				const	{ return !!SendMessageL(CB_SETCUEBANNER, text); }
	CharRange	GetTextSelection()						const	{ uint32 v = SendMessage(CB_GETEDITSEL); return CharRange(LOWORD(v), HIWORD(v)); }
	bool		SetTextSelection(const CharRange &cr)	const	{ return !!SendMessageL(CB_SETEDITSEL, lparam(cr.cpMin, cr.cpMax)); }
	bool		ShowDropdown(bool show = true)			const	{ return !!SendMessage(CB_SHOWDROPDOWN, show); }
	bool		IsDropped()								const	{ return !!SendMessage(CB_GETDROPPEDSTATE); }
	Rect		GetDroppedRect()						const	{ Rect r; SendMessageL(CB_GETDROPPEDCONTROLRECT, &r); return r; }
	bool		GetExtendedUI()							const	{ return !!SendMessage(CB_GETEXTENDEDUI); }
	bool		SetExtendedUI(bool ext = true)			const	{ return !!SendMessage(CB_SETEXTENDEDUI, ext); }
	int			Dir(text spec, int attrs)				const	{ return SendMessage(CB_DIR, attrs, spec) == CB_OKAY; }
};

//-----------------------------------------------------------------------------
//	ScrollBarControl
//-----------------------------------------------------------------------------

class ScrollBarControl : public control_mixin<ScrollBarControl, CommonControl> {
public:
	static const char *ClassName()	{ return WC_SCROLLBARA; }

	using Base::Base;

	int		Set(const SCROLLINFO &si, bool redraw = true)	const	{ return SetScrollInfo(*this, SB_CTL, &si, redraw); }
	Colour	SetBackground(Colour bg)						const	{ return (Colour)SendMessageL(SB_SETBKCOLOR, bg); }
};

//-----------------------------------------------------------------------------
//	TreeControl
//-----------------------------------------------------------------------------

class TreeControl : public control_mixin<TreeControl, CommonControl> {
	struct _string_getter {
		Control			c;
		HTREEITEM		h;
		_string_getter(Control c, HTREEITEM h) : c(c), h(h) {}
		size_t	string_len()						const	{ return 260; }
		size_t	string_get(char *s, size_t len)		const	{ return s && (size_t)Item(h).Text(s, (int)len)._Get((TreeControl)c) ? strlen(s) : 0; }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
	bool			_CopyCheck(HTREEITEM hItem, HTREEITEM hItemTo) const;
	HTREEITEM		_CopyChildren(HTREEITEM hItem, HTREEITEM hItemTo) const;
	HTREEITEM		_Copy(HTREEITEM hItem, HTREEITEM hItemTo, HTREEITEM hItemPos) const;
public:

	struct Item : TVITEMEXA {
		static const uint32 ALL = TVIF_TEXT|TVIF_IMAGE|TVIF_PARAM|TVIF_STATE|TVIF_HANDLE|TVIF_SELECTEDIMAGE|TVIF_CHILDREN|TVIF_INTEGRAL|TVIF_STATEEX|TVIF_EXPANDEDIMAGE;
		enum StateFlag {
			SELECTED		= TVIS_SELECTED,
			CUT				= TVIS_CUT,
			DROPHILITED		= TVIS_DROPHILITED,
			BOLD			= TVIS_BOLD,
			EXPANDED		= TVIS_EXPANDED,
			EXPANDEDONCE	= TVIS_EXPANDEDONCE,
			EXPANDPARTIAL	= TVIS_EXPANDPARTIAL,
			USER1			= TVIS_USERMASK & -TVIS_USERMASK, USER2 = USER1 << 1, USER3 = USER1 << 2, USER4 = USER1 << 3
		};
		static Item	TextCallback()						{ Item i(TVIF_TEXT); i.pszText = LPSTR_TEXTCALLBACK; return i; }

		void		init(uint32 _mask)					{ mask = _mask; stateMask = 0; uStateEx = 0; }
					Item(uint32 _mask = 0)				{ init(_mask); }
					//Item(const char *s)					{ init(TVIF_TEXT); pszText = const_cast<char*>(s); }
					Item(text s)						{ init(TVIF_TEXT); pszText = unconst(s.begin()); }

					Item(HTREEITEM h, uint32 _mask = 0)	{ init(_mask | TVIF_HANDLE); hItem = h; }
		Item&		Handle(HTREEITEM h)					{ hItem = h; return *this; }
		Item&		Text(text s)						{ pszText = unconst(s.begin()); mask |= TVIF_TEXT; return *this; }
		//Item&		Text(const char *s)					{ pszText = const_cast<char*>(s); mask |= TVIF_TEXT; return *this; }
		Item&		Text(char *s, int len)				{ pszText = s; cchTextMax = len; mask |= TVIF_TEXT; return *this; }
		template<int N> Item& Text(fixed_string<N> &s)	{ return Text(s, N); }
		Item&		Param(const arbitrary &p)			{ lParam = p; mask |= TVIF_PARAM; return *this; }
		Item&		BothImages(int i)					{ iImage = iSelectedImage = i; mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE; return *this; }
		Item&		Image(int i)						{ iImage = i; mask |= TVIF_IMAGE; return *this; }
		Item&		Image2(int i)						{ iSelectedImage = i; mask |= TVIF_SELECTEDIMAGE; return *this; }
		Item&		Children(int i)						{ cChildren = i; mask |= TVIF_CHILDREN; return *this; }
		Item&		ChangeState(uint32 v, uint32 m)		{ state = (state & ~m) | v; stateMask |= m; mask |= TVIF_STATE; return *this; }
		Item&		SetState(int i)						{ return ChangeState(i, i); }
		Item&		ToggleState(int i)					{ return ChangeState(~state & i, i); }
		Item&		SetState(int i, bool enable)		{ return ChangeState(enable ? i : 0, i); }
		Item&		ClearState(int i)					{ return ChangeState(0, i); }
		Item&		ChangeStateEx(uint32 v, uint32 m)	{ uStateEx = (uStateEx & ~m) | v; mask |= TVIF_STATEEX; return *this; }
		Item&		SetStateEx(int i)					{ return ChangeStateEx(i, i); }
		Item&		ToggleStateEx(int i)				{ return ChangeStateEx(~state & i, i); }
		Item&		SetStateEx(int i, bool enable)		{ return ChangeStateEx(enable ? i : 0, i); }
		Item&		ClearStateEx(int i)					{ return ChangeStateEx(0, i); }
		Item&		OverlayImage(int i)					{ return ChangeState(i << 8, TVIS_OVERLAYMASK); }
		Item&		StateImage(int i)					{ return ChangeState(i << 12, TVIS_STATEIMAGEMASK); }
		Item&		StateImage8(int i)					{ return ChangeState(i << 8, 0xff00); }
		Item&		Bold(bool enable = true)			{ return SetState(TVIS_BOLD, enable); }
		Item&		Expand(bool enable = true)			{ return SetState(TVIS_EXPANDED, enable); }
#if _WIN32_WINNT >= 0x0600
		Item&		Disable(bool d = true)				{ return SetStateEx(TVIS_EX_DISABLED, d); }
#endif

		HTREEITEM	Handle()				const		{ return hItem; }
		char*		Text()					const		{ return pszText; }
		auto		TextBuffer()			const		{ return string_bufferT<char>(pszText, cchTextMax); }
		arbitrary&	Param()					const		{ return (arbitrary&)lParam; }
		int			Image()					const		{ return iImage; }
		int			Image2()				const		{ return iSelectedImage; }
		int			Children()				const		{ return cChildren; }
		uint32		State()					const		{ return state; }
		uint32		OverlayImage()			const		{ return (state & TVIS_OVERLAYMASK) >> 8; }
		uint32		StateImage()			const		{ return state >> 12;}
		uint32		StateImage8()			const		{ return state >> 8;}

		bool		_Get(TreeControl tree)				{ return !!tree(TVM_GETITEMA, 0, this); }
		Item&		Get(TreeControl tree)				{ _Get(tree); return *this; }
		bool		Set(TreeControl tree)	const		{ return !!tree(TVM_SETITEMA, 0, this); }
		HTREEITEM	Insert(TreeControl tree, HTREEITEM hItemParent = TVI_ROOT, HTREEITEM hItemAfter = TVI_LAST) {
			TVINSERTSTRUCTA		tvis;
			tvis.hParent		= hItemParent;
			tvis.hInsertAfter	= hItemAfter;
			tvis.itemex			= *this;
			Handle((HTREEITEM)tree(TVM_INSERTITEMA, 0, &tvis));
			return hItem;
		}
		HTREEITEM	InsertBefore(TreeControl tree, HTREEITEM hItemParent, HTREEITEM hItemBefore) {
			TVINSERTSTRUCTA		tvis;
			tvis.hParent		= hItemParent;
			tvis.itemex			= *this;
			if (!(tvis.hInsertAfter = tree.GetPrevItem(hItemBefore)))
				tvis.hInsertAfter = TVI_FIRST;
			Handle((HTREEITEM)tree(TVM_INSERTITEMA, 0, &tvis));
			return hItem;
		}
	};

	static const char *ClassName()	{ return WC_TREEVIEWA; }
	static const Style
		HASBUTTONS			= Style(0x0001),
		HASLINES			= Style(0x0002),
		LINESATROOT			= Style(0x0004),
		EDITLABELS			= Style(0x0008),
		DISABLEDRAGDROP		= Style(0x0010),
		SHOWSELALWAYS		= Style(0x0020),
		RTLREADING			= Style(0x0040),
		NOTOOLTIPS			= Style(0x0080),
		CHECKBOXES			= Style(0x0100),
		TRACKSELECT			= Style(0x0200),
		SINGLEEXPAND		= Style(0x0400),
		INFOTIP				= Style(0x0800),
		FULLROWSELECT		= Style(0x1000),
		NOSCROLL			= Style(0x2000),
		NONEVENHEIGHT		= Style(0x4000),
		NOHSCROLL			= Style(0x8000);
	static const StyleEx
		NOSINGLECOLLAPSE	= StyleEx(0x0001),
		MULTISELECT			= StyleEx(0x0002),
		DOUBLEBUFFER		= StyleEx(0x0004),
		NOINDENTSTATE		= StyleEx(0x0008),
		RICHTOOLTIP			= StyleEx(0x0010),
		AUTOHSCROLL			= StyleEx(0x0020),
		FADEINOUTEXPANDOS	= StyleEx(0x0040),
		PARTIALCHECKBOXES	= StyleEx(0x0080),
		EXCLUSIONCHECKBOXES	= StyleEx(0x0100),
		DIMMEDCHECKBOXES	= StyleEx(0x0200),
		DRAWIMAGEASYNC		= StyleEx(0x0400);

	using Base::Base;

	HTREEITEM	InsertItem(int mask, const char *caption, int image, int imageSelected, int state, int stateMask, HTREEITEM hItemParent = TVI_ROOT, HTREEITEM hItemAfter = TVI_LAST, void *param = NULL, int cChildren = 0) {
		TV_INSERTSTRUCTA	tvis;
		tvis.hParent				= hItemParent;
		tvis.hInsertAfter			= hItemAfter;
		tvis.item.mask				= mask;
		tvis.item.state				= state;
		tvis.item.stateMask			= stateMask;
		tvis.item.pszText			= const_cast<char*>(caption);
		tvis.item.iImage			= image;
		tvis.item.iSelectedImage	= imageSelected;
		tvis.item.cChildren			= cChildren;
		tvis.item.lParam			= (LPARAM)param;
		return (HTREEITEM)SendMessageL(TVM_INSERTITEMA, &tvis);
	}
	HTREEITEM	InsertItem(text caption, int image = 0, int imageSelected = 0, HTREEITEM hItemParent = TVI_ROOT, HTREEITEM hItemAfter = TVI_LAST, void *param = NULL) {
		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_PARAM, caption, image, imageSelected, 0, 0, hItemParent, hItemAfter, param);
	}
	bool		DeleteItem(HTREEITEM hItem = TVI_ROOT)				const	{ return !!SendMessageL(TVM_DELETEITEM, hItem); }
	Item		GetItem(HTREEITEM hItem, int mask = 0)				const	{ return Item(hItem, mask & ~TVIF_TEXT).Get(*this); }
	template<int N> Item GetItem(HTREEITEM hItem, fixed_string<N> &s, int mask = 0) const { return Item(hItem, mask).Text(s).Get(*this); }

	HTREEITEM	GetNextItem(HTREEITEM hItem, int flag = TVGN_NEXT)	const	{ return (HTREEITEM)SendMessage(TVM_GETNEXTITEM, flag, reinterpret_cast<LPARAM>(hItem)); }
	HTREEITEM	GetPrevItem(HTREEITEM hItem)						const	{ return GetNextItem(hItem, TVGN_PREVIOUS); }
	HTREEITEM	GetBeforeItem(HTREEITEM hItem)						const	{ auto prev = GetNextItem(hItem, TVGN_PREVIOUS); return prev ? prev : TVI_FIRST; }
	HTREEITEM	GetChildItem(HTREEITEM hItem)						const	{ return GetNextItem(hItem, TVGN_CHILD); }
	HTREEITEM	GetParentItem(HTREEITEM hItem)						const	{ return GetNextItem(hItem, TVGN_PARENT); }
	HTREEITEM	GetRootItem()										const	{ return (HTREEITEM)SendMessage(TVM_GETNEXTITEM, TVGN_ROOT); }
	HTREEITEM	GetSelectedItem()									const	{ return (HTREEITEM)SendMessage(TVM_GETNEXTITEM, TVGN_CARET); }
	Rect		GetItemRect(HTREEITEM hItem, bool label_only = false)const	{ Rect rect; *(HTREEITEM*)&rect = hItem; if (!SendMessage(TVM_GETITEMRECT, label_only, &rect)) clear(rect); return rect; }

	bool		SetItemParam(HTREEITEM hItem, const arbitrary &p)	const	{ return Item(hItem).Param(p).Set(*this);  }
	arbitrary	GetItemParam(HTREEITEM hItem)						const	{ Item item(hItem, TVIF_PARAM); return item._Get(*this) ? item.Param() : arbitrary(~0ull);  }
	bool		SetItemText(HTREEITEM hItem, text caption)	const	{ return Item(hItem).Text(caption).Set(*this); }
	string_getter<_string_getter>	GetItemText(HTREEITEM hItem)	const	{ return _string_getter(*this, hItem); }
	uint32		GetItemState(HTREEITEM hItem, uint32 m = ~0)		const	{ return SendMessage(TVM_GETITEMSTATE, hItem, m);  }
	bool		ExpandedOnce(HTREEITEM h)							const	{ return !!GetItemState(h, Item::EXPANDEDONCE); }

	ImageList	SetImageList(HIMAGELIST h)							const	{ return (HIMAGELIST)SendMessage(TVM_SETIMAGELIST, TVSIL_NORMAL, h);}
	ImageList	SetStateImageList(HIMAGELIST h)						const	{ return (HIMAGELIST)SendMessage(TVM_SETIMAGELIST, TVSIL_STATE, h);}
	ImageList	GetImageList()										const	{ return (HIMAGELIST)SendMessage(TVM_GETIMAGELIST, TVSIL_NORMAL);}
	ImageList	GetStateImageList()									const	{ return (HIMAGELIST)SendMessage(TVM_GETIMAGELIST, TVSIL_STATE);}
	ImageList	CreateDragImage(HTREEITEM hItem)					const	{ return (HIMAGELIST)SendMessageL(TVM_CREATEDRAGIMAGE, hItem); }

	bool		SetSelectedItem(HTREEITEM hItem)					const	{ return !!SendMessage(TVM_SELECTITEM, TVGN_CARET,		hItem); }
	bool		SetDropTarget(HTREEITEM hItem)						const	{ return !!SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE, hItem); }
	HTREEITEM	HitTest(const POINT &pt, uint32 *flags = 0)			const	{ TVHITTESTINFO hti; hti.pt = pt; LRESULT r = SendMessageL(TVM_HITTEST, &hti); if (flags) *flags = hti.flags; return (HTREEITEM)r; }
	bool		EnsureVisible(HTREEITEM hItem)						const	{ return !!SendMessageL(TVM_ENSUREVISIBLE, hItem); }
	bool		ExpandItem(HTREEITEM hItem, int flags = TVE_EXPAND)	const	{ return !!SendMessage(TVM_EXPAND, flags, hItem); }
	bool		EditLabel(HTREEITEM hItem)							const	{ return !!SendMessageL(TVM_EDITLABEL, hItem); }
	void		CancelEditLabel(bool save = false)					const	{ SendMessage(TVM_ENDEDITLABELNOW, !save); }

	ToolTipControl	GetToolTipControl()								const	{ return (HWND)SendMessage(TVM_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)			const	{ return (HWND)SendMessage(TVM_SETTOOLTIPS, (HWND)tt); }

	void		SetIndent(int indent)								const	{ SendMessage(TVM_SETINDENT, indent); }
	int			GetIndent()											const	{ return SendMessage(TVM_GETINDENT); }
	Colour		SetBackground(Colour c)								const	{ return Colour(SendMessageL(TVM_SETBKCOLOR, c)); }
	Colour		GetBackground()			 							const	{ return Colour(SendMessage(TVM_GETBKCOLOR)); }

	HTREEITEM	GetChildItem(HTREEITEM hParent, int i)				const;
	int			FindChildIndex(HTREEITEM hParent, HTREEITEM hChild)	const;

	template<typename T> bool Enum(HTREEITEM hItem, T func) {
		if (!func(*this, hItem))
			return false;
		for (HTREEITEM hChildItem = GetChildItem(hItem); hChildItem; hChildItem = GetNextItem(hChildItem)) {
			if (!Enum(hChildItem, func))
				return false;
		}
		return true;
	}
	void		DeleteChildren(HTREEITEM hItem) const {
		while (HTREEITEM hChild = GetChildItem(hItem))
			DeleteItem(hChild);
	}
	HTREEITEM	CopyChildren(HTREEITEM hItem, HTREEITEM hItemTo) const {
		return	_CopyCheck(hItem, hItemTo)
			?	_CopyChildren(hItem, hItemTo)
			:	NULL;
	}
	HTREEITEM	Copy(HTREEITEM hItem, HTREEITEM hItemTo, HTREEITEM hItemPos = TVI_LAST) const {
		return	_CopyCheck(hItem, hItemTo) && hItemTo != GetParentItem(hItem)
			?	_Copy(hItem, hItemTo, hItemPos)
			:	NULL;
	}

	auto	SomeItems(HTREEITEM h, uint32 mask)	const	{ return FilteredItemContainer<TreeControl, HTREEITEM>(*this, mask, h, NULL); }
	auto	Selected()							const	{ return SomeItems(TVI_ROOT, TVGN_NEXTSELECTED); }
	auto	ChildItems(HTREEITEM h = TVI_ROOT)	const	{ return SomeItems(GetChildItem(h), TVGN_NEXT); }
	auto	From(HTREEITEM h)					const	{ return SomeItems(h, TVGN_NEXT); }
};

//-----------------------------------------------------------------------------
//	CommonControl2
//-----------------------------------------------------------------------------

class CommonControl2 : public CommonControl {
public:
	static const Control::Style
		TOP				= Control::Style(0x0001),
		NOMOVEY			= Control::Style(0x0002),
		BOTTOM			= Control::Style(0x0003),
		NORESIZE		= Control::Style(0x0004),
		NOPARENTALIGN	= Control::Style(0x0008),
		ADJUSTABLE		= Control::Style(0x0020),
		NODIVIDER		= Control::Style(0x0040),
		VERT			= Control::Style(0x0080),
		LEFT			= VERT | TOP,
		RIGHT			= VERT | BOTTOM,
		NOMOVEX			= VERT | NOMOVEY;
	CommonControl2() {}
	CommonControl2(HWND hWnd) : CommonControl(hWnd) {}
};

//-----------------------------------------------------------------------------
//	StatusBarControl
//-----------------------------------------------------------------------------

class StatusBarControl : public control_mixin<StatusBarControl, CommonControl2> {
public:
	static const char *ClassName()	{ return STATUSCLASSNAMEA; }
	static const Style
		SIZEGRIP	= Style(0x0100),
		TOOLTIPS	= Style(0x0800);

	using Base::Base;

	bool		SetText(int part, const char *text, int type = 0)	const {
		return !!SendMessage(SB_SETTEXTA, part | type, text);
	}
};

//-----------------------------------------------------------------------------
//	ToolBarControl
//-----------------------------------------------------------------------------

class CommonControl3 : public CommonControl2 {
protected:
	typedef CommonControl3 Base;

public:
	bool			SetColours(Colour highlight, Colour shadow = Colour::unspec) const {
		COLORSCHEME scheme = {sizeof(COLORSCHEME), highlight, shadow};
		return !!SendMessageL(CCM_SETCOLORSCHEME, &scheme);
	}
	bool			GetColors(COLORREF &highlight, COLORREF &shadow)	const {
		COLORSCHEME scheme = {sizeof(COLORSCHEME)};
		if (SendMessageL(CCM_GETCOLORSCHEME, &scheme)) {
			highlight	= scheme.clrBtnHighlight;
			shadow		= scheme.clrBtnShadow;
			return true;
		}
		return false;
	}
	CommonControl3() {}
	CommonControl3(HWND hWnd) : CommonControl2(hWnd) {}
};

class ToolBarControl : public control_mixin<ToolBarControl, CommonControl3> {
	struct _string_getter {
		Control			c;
		ID				id;
		_string_getter(Control c, ID id) : c(c), id(id) {}
		size_t	string_len()						const	{ return 0; }
		size_t	string_get(char *s, size_t len)		const	{ return c(TB_GETBUTTONTEXT, id); }
		size_t	string_get(char16 *s, size_t len)	const	{ return string_getter_transform<char>(*this, s, len); }
	};
public:
	enum { RT_TOOLBAR = 241 };
	static const int Height = 29;

	struct Data : trailing_array2<Data, WORD> {
		WORD	version, width, height, count;
		Point	GetSize()	const { return Point(width, height); }
		int		size()		const { return count; }
		int		NumImages() const {
			int	n = 0;
			for (auto &i : *this)
				n += int(i != 0);
			return n;
		}
	};

	struct Item : TBBUTTONINFOA {
		static const uint32 ALL = TBIF_IMAGE | TBIF_TEXT | TBIF_STATE | TBIF_STYLE | TBIF_LPARAM | TBIF_COMMAND | TBIF_SIZE;
		Item(uint32 mask = 0)								{ cbSize = sizeof(*this); dwMask = mask; }
		Item&		Text(const char *s)						{ pszText = const_cast<char*>(s); dwMask |= TBIF_TEXT; return *this; }
		Item&		Text(char *s, int len)					{ pszText = s; cchText = len; dwMask |= TBIF_TEXT; return *this; }
		template<int N> Item& Text(fixed_string<N> &s)		{ return Text(s, N); }
		Item&		Param(const arbitrary &p)				{ lParam = p; dwMask |= TBIF_LPARAM; return *this; }
		Item&		Image(int i)							{ iImage = i; dwMask |= TBIF_IMAGE; return *this; }
		Item&		ID(int id)								{ idCommand = id; dwMask |= TBIF_COMMAND; return *this; }
		Item&		Style(int style)						{ fsStyle = style; dwMask |= TBIF_STYLE; return *this; }
		Item&		State(int state)						{ fsState = state; dwMask |= TBIF_STATE; return *this; }
		Item&		Width(int w)							{ cx = w; dwMask |= TBIF_SIZE; return *this; }

		char*		Text()							const	{ return pszText; }
		template<typename T> const T& Param()		const	{ return (const T&)lParam; }
		arbitrary&	Param()							const	{ return (arbitrary&)lParam;}
		int			Image()							const	{ return iImage; }
		int			Command()						const	{ return idCommand; }
		int			Style()							const	{ return fsStyle; }
		int			State()							const	{ return fsState; }
		int			Width()							const	{ return cx; }

		int		_Get(ToolBarControl tb, win::ID id)			{ return tb(TB_GETBUTTONINFOA, id, this); }
		Item&	Get(ToolBarControl tb, win::ID id)			{ _Get(tb, id); return *this; }
		bool	Set(ToolBarControl tb, win::ID id)	const	{ return !!tb(TB_SETBUTTONINFOA, id, this); }
		bool	Set(ToolBarControl tb)				const	{ return !!tb(TB_SETBUTTONINFOA, idCommand, this); }
	};

	struct Button : TBBUTTON {
		Button(text s, ID id = ID(), int style = BTNS_BUTTON)	{ clear(*this); iString = INT_PTR(s.begin()); idCommand = id; fsState = TBSTATE_ENABLED; fsStyle = style; }
		Button&		Style(int style)							{ fsStyle = style; return *this; }
		Button&		State(int state)							{ fsState = state; return *this; }
		Button&		Bitmap(int i)								{ iBitmap =  i; return *this; }
		Button&		NoBitmap()									{ iBitmap =  I_IMAGENONE; return *this; }
		Button&		Param(const arbitrary &p)					{ dwData = p; return *this;	 }
		bool		Insert(ToolBarControl tb, int i = -1) const	{ return !!tb(TB_INSERTBUTTONA, i, this); }
		bool		_Get(ToolBarControl tb, int i)				{ return !!tb(TB_GETBUTTON, i, this); }
		Button&		Get(ToolBarControl tb, int i)				{ _Get(tb, i); return *this; }
	};

	static Button Separator()		{ return Button(0, ID(), BTNS_SEP); }
	static const char *ClassName()	{ return TOOLBARCLASSNAMEA; }
	static const Style
		TOOLTIPS			= Style(0x0100),
		WRAPABLE			= Style(0x0200),
		ALTDRAG				= Style(0x0400),
		FLAT				= Style(0x0800),
		LIST				= Style(0x1000),
		CUSTOMERASE			= Style(0x2000),
		REGISTERDROP		= Style(0x4000),
		TRNSPARENT			= Style(0x8000);
	enum ToolBarStyle {
		DRAWDDARROWS		= 0x0001,
		MIXEDBUTTONS		= 0x0008,
		HIDECLIPPEDBUTTONS	= 0x0010,
		MULTICOLUMN			= 0x0002,
		VERTICAL			= 0x0004,
		DOUBLEBUFFER		= 0x0080,
	};
	friend ToolBarStyle	operator|(ToolBarStyle a, ToolBarStyle b) { return (ToolBarStyle)(uint32(a) | uint32(b)); }
	using Base::Base;

	iso_export bool	Init(const Data *tb, int image)		const;
	iso_export bool	Init(Menu menu)						const;
	iso_export bool Add(Menu menu)						const;

	bool		Init(HINSTANCE hInst, ID id, ID bmid)	const {
		const Data	*data	= Resource(hInst, id, RT_TOOLBAR);
		return data && Init(data, AddImages(hInst, data->NumImages(), bmid));
	}
	bool		Init(ID id, ID bmid)					const	{ return Init(GetDefaultInstance(), id, bmid); }
	bool		Init(HINSTANCE hInst, ID id)			const	{ return Init(hInst, id, id); }
	bool		Init(ID id)								const	{ return Init(id, id); }

	DWORD		SetExtendedStyle(ToolBarStyle styleEx)	const	{ return SendMessageL(TB_SETEXTENDEDSTYLE, styleEx); }
	ToolBarStyle	GetExtendedStyle()					const	{ return (ToolBarStyle)SendMessage(TB_GETEXTENDEDSTYLE); }

	bool		SetBitmapSize(const POINT &size)		const	{ return !!SendMessageL(TB_SETBITMAPSIZE, lparam(size));}
	bool		CheckButton(UINT id, bool check = true)	const	{ return !!SendMessage(TB_CHECKBUTTON, id, MAKELONG(check, 0)); }

	ImageList	SetImageList(HIMAGELIST h, int i = 0)		const	{ return (HIMAGELIST)SendMessage(TB_SETIMAGELIST, i, h); }
	ImageList	GetImageList()								const	{ return (HIMAGELIST)SendMessage(TB_GETIMAGELIST); }
	ImageList	SetHotImageList(HIMAGELIST h, int i = 0)	const	{ return (HIMAGELIST)SendMessage(TB_SETHOTIMAGELIST, i, h); }
	ImageList	GetHotImageList()							const	{ return (HIMAGELIST)SendMessage(TB_GETHOTIMAGELIST); }
	ImageList	SetDisabledImageList(HIMAGELIST h, int i = 0)const	{ return (HIMAGELIST)SendMessage(TB_SETDISABLEDIMAGELIST, i, h); }
	ImageList	GetDisabledImageList()						const	{ return (HIMAGELIST)SendMessage(TB_GETDISABLEDIMAGELIST); }
#if _WIN32_WINNT >= 0x0600
	ImageList	SetPressedImageList(HIMAGELIST h, int i = 0)const	{ return (HIMAGELIST)SendMessage(TB_SETPRESSEDIMAGELIST, i, h); }
	ImageList	GetPressedImageList()						const	{ return (HIMAGELIST)SendMessage(TB_GETPRESSEDIMAGELIST); }
#endif
	int			GetImageListCount()							const	{ return SendMessage(TB_GETIMAGELISTCOUNT); }

	bool		LoadImages(int i)						const	{ return !!SendMessage(TB_LOADIMAGES, i, HINST_COMMCTRL); }
//	int			AddImages(HINSTANCE h, int n, ID id)	const	{ TBADDBITMAP t = {h, id}; return SendMessage(TB_ADDBITMAP, n, &t);}
	int			AddImages(HINSTANCE h, int n, ID id)	const	{ return AddImages(n, Bitmap::Load(h, id)); }
	int			AddImages(int n, ID id)					const	{ return AddImages(GetDefaultInstance(), n, id);}
	int			AddImages(int n, Bitmap b)				const	{ TBADDBITMAP t = {0, (UINT_PTR)(lparam)b}; return SendMessage(TB_ADDBITMAP, n, &t); }

	int			AddString(const char *s)				const	{ return SendMessageL(TB_ADDSTRINGA, s); }
	int			AddString(HINSTANCE hInst, ID id)		const	{ return SendMessage(TB_ADDSTRINGA, hInst, id); }
	bool		AddButtons(TBBUTTON *buttons, int n)	const	{ return !!SendMessage(TB_ADDBUTTONSA, n, buttons); }
	bool		InsertButton(TBBUTTON &button, int i)	const	{ return !!SendMessage(TB_INSERTBUTTONA, i, &button); }
	bool		DeleteButton(int i)						const	{ return !!SendMessage(TB_DELETEBUTTON, i); }
	bool		EnableButton(int i, bool en = true)		const	{ return !!SendMessage(TB_ENABLEBUTTON, i, LPARAM(en)); }
	int			Count()									const	{ return SendMessage(TB_BUTTONCOUNT); }
	bool		Indent(uint32 i)						const	{ return !!SendMessage(TB_SETINDENT, i); }
	bool		ButtonSize(const POINT &size)			const	{ return !!SendMessageL(TB_SETBUTTONSIZE, lparam(size));}
	Point		ButtonSize()							const	{ return Point(SendMessage(TB_GETBUTTONSIZE)); }

	Item		GetItem(ID id, int mask = TBIF_LPARAM)	const	{ return Item(mask).Get(*this, id); }
	string_getter<_string_getter> GetItemText(ID id)	const	{	return _string_getter(*this, id); }
	Rect		GetItemRect(int i)						const	{ Rect r; SendMessage(TB_GETITEMRECT, i, &r); return r; }
	Rect		GetItemRectByID(ID id)					const	{ Rect r; SendMessage(TB_GETRECT, id, &r); return r; }
	int			HitTest(const POINT &pt)				const	{ return SendMessageL(TB_HITTEST, &pt); }

	Rect		GetUnusedRect()							const	{ return GetClientRect().SetLeft(GetItemRect(Count() - 1).Right()); }

	ToolTipControl	GetToolTipControl()						const	{ return (HWND)SendMessage(TB_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)	const	{ return (HWND)SendMessage(TB_SETTOOLTIPS, (HWND)tt); }

	auto	Items(uint32 mask = Item::ALL)	const	{ return ItemContainer<ToolBarControl,Item>(*this, Count(), mask); }
};

//-----------------------------------------------------------------------------
//	ReBarControl
//-----------------------------------------------------------------------------

class ReBarControl : public control_mixin<ReBarControl, CommonControl3> {
public:
	struct Item : REBARBANDINFOA {
		static const uint32	ALL = RBBIM_STYLE | RBBIM_COLORS | RBBIM_TEXT | RBBIM_IMAGE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_SIZE | RBBIM_BACKGROUND | RBBIM_ID | RBBIM_IDEALSIZE | RBBIM_LPARAM | RBBIM_HEADERSIZE | RBBIM_CHEVRONLOCATION | RBBIM_CHEVRONSTATE;
		Item(uint32 mask = 0)								{ cbSize = sizeof(*this); fMask = mask; }
		Item&		Text(const char *s)						{ lpText = const_cast<char*>(s); fMask |= RBBIM_TEXT; return *this; }
		Item&		Text(char *s, int len)					{ lpText = s; cch = len; fMask |= RBBIM_TEXT; return *this; }
		template<int N> Item& Text(fixed_string<N> &s)		{ return Text(s, N); }
		Item&		Param(const arbitrary &p)				{ lParam = p; fMask |= RBBIM_LPARAM; return *this; }
		Item&		Image(int i)							{ iImage = i; fMask |= RBBIM_IMAGE; return *this; }
		Item&		ID(int id)								{ wID = id; fMask |= RBBIM_ID; return *this; }
		Item&		Style(int style)						{ fStyle = style; fMask |= RBBIM_STYLE; return *this; }
		Item&		Width(int w)							{ cx = w; fMask |= RBBIM_SIZE; return *this; }
		Item&		Colours(Colour fg, Colour bg)			{ clrFore = fg; clrBack = bg; fMask |= RBBIM_COLORS; return *this; }
		Item&		ChildSize(int minw, int minh, int maxh, int h, int step) {
			cxMinChild = minw; cyMinChild = minh; cyMaxChild = maxh; cyChild = h; cyIntegral = step; fMask |= RBBIM_CHILDSIZE; return *this;
		}
		Item&		ChildSize(int minw, int minh)			{ return ChildSize(minw, minh, minh, minh, minh); }
#if _WIN32_WINNT >= 0x0600
		Item&		ChevronRect(RECT &rect)					{ rcChevronLocation = rect; fMask |= RBBIM_CHEVRONLOCATION; return *this; }
		Item&		ChevronState(uint32 state)				{ uChevronState = state; fMask |= RBBIM_CHEVRONSTATE; return *this; }
#endif

		char*		Text()						const		{ return lpText; }
		arbitrary&	Param()						const		{ return (arbitrary&)lParam; }
		int			Image()						const		{ return iImage; }
		int			Command()					const		{ return wID; }
		int			Style()						const		{ return fStyle; }
		int			Width()						const		{ return cx; }

		bool	_Get(ReBarControl rb, int i)				{ return !!rb(RB_GETBANDINFOA, i, this); }
		Item&	Get(ReBarControl rb, int i)					{ _Get(rb, i); return *this; }
		bool	Set(ReBarControl rb, int i)	const			{ return !!rb(RB_SETBANDINFOA, i, this); }
		bool	Insert(ReBarControl rb, int i = -1)	const	{ return !!rb(RB_INSERTBANDA, i, this); }
	};
	static const char *ClassName()	{ return REBARCLASSNAMEA; }
	static const Style
		TOOLTIPS			= Style(0x0100),
		VARHEIGHT			= Style(0x0200),
		BANDBORDERS			= Style(0x0400),
		FIXEDORDER			= Style(0x0800),
		REGISTERDROP		= Style(0x1000),
		AUTOSIZE			= Style(0x2000),
		VERTICALGRIPPER		= Style(0x4000),
		DBLCLKTOGGLE		= Style(0x8000);

	using Base::Base;

	bool			SetImageList(HIMAGELIST h)				const	{ REBARINFO info = {sizeof(REBARINFO), RBIM_IMAGELIST, h}; return !!SendMessageL(RB_SETBARINFO, &info); }
	ImageList		GetImageList()							const	{ REBARINFO info = {sizeof(REBARINFO), RBIM_IMAGELIST}; SendMessageL(RB_GETBARINFO, &info); return info.himl; }
	int				Count()									const	{ return SendMessage(RB_GETBANDCOUNT); }
	int				Height()								const	{ return SendMessage(RB_GETBARHEIGHT); }
	int				Rows()									const	{ return SendMessage(RB_GETROWCOUNT); }
	int				RowHeight(int i)						const	{ return SendMessage(RB_GETROWHEIGHT, i); }
	bool			DeleteItem(int i)						const	{ return !!SendMessage(RB_DELETEBAND, i); }
	bool			ShowItem(int i, bool show = true)		const	{ return !!SendMessage(RB_SHOWBAND, i, show); }
	Rect			GetItemRect(int i)						const	{ Rect r; SendMessage(RB_GETRECT, i, &r); return r; }
	Rect			GetItemBorders(int i)					const	{ Rect r; SendMessage(RB_GETBANDBORDERS, i, &r); return r; }
	Rect			GetItemMargins(int i)					const	{ Rect r; SendMessage(RB_GETBANDMARGINS, i, &r); return r; }
	int				GetIndex(ID id)							const	{ return SendMessage(RB_IDTOINDEX, id); }
	int				HitTest(const POINT &pt, uint32 *flags)	const	{ RBHITTESTINFO hti; hti.pt = pt; int i = SendMessageL(RB_HITTEST, &hti); if (flags) *flags = hti.flags; return i; }
	IDropTarget*	GetDropTarget()							const	{ IDropTarget *p; return SendMessageL(RB_GETDROPTARGET, &p) ? p : 0; }
	ToolTipControl	GetToolTipControl()						const	{ return (HWND)SendMessage(RB_GETTOOLTIPS); }
	ToolTipControl	SetToolTipControl(ToolTipControl tt)	const	{ return (HWND)SendMessage(RB_SETTOOLTIPS, (HWND)tt); }

#if (_WIN32_WINNT >= 0x0600)
	bool			SetItemWidth(int i, int width)			const	{ return !!SendMessage(RB_SETBANDWIDTH, i, width); }
#endif
	auto			Items(uint32 mask = Item::ALL)			const	{ return ItemContainer<ReBarControl,Item>(*this, Count(), mask); }
};

//-------------------------------------
//	Subclass
// same WindowClass with overridden Proc
//-------------------------------------

template<typename T> LRESULT CALLBACK SubclassThunk(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	return ((T*)GetWindowLongPtr(hWnd, GWLP_USERDATA))->Proc((MSG_ID)msg, wParam, lParam);
}

template<typename T, typename B> class Subclass : public B {
	WNDPROC	prev_proc = 0;
	static void bind(HWND h, void *p, WNDPROC proc, bool call_create) {
		SetWindowLongPtr(h, GWLP_WNDPROC, (LONG_PTR)proc);
		SetWindowLongPtr(h, GWLP_USERDATA, (LONG_PTR)p);
		if (call_create)
			proc(h, WM_CREATE, 0, 0);
	}
protected:
	template<typename T2> void	Rebind(T2 *t2, bool call_create = true)	{
		bind(hWnd, t2, SubclassThunk<T2>, call_create);
	}

	void	Unbind() {
		SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)prev_proc);
	}
	LRESULT	Super(MSG_ID message, WPARAM wParam = 0, LPARAM lParam = 0) {
		return message == WM_CREATE ? 0 : CallWindowProc(prev_proc, hWnd, message, wParam, lParam);
	}
	LRESULT	Proc(MSG_ID msg, WPARAM wParam, LPARAM lParam) {
		return Super(msg, wParam, lParam);
	}
	HWND	init(HWND h) {
		prev_proc = (WNDPROC)GetWindowLongPtr(h, GWLP_WNDPROC);
		bind(h, static_cast<T*>(this), SubclassThunk<T>, true);
		return h;
	}
public:
	using B::hWnd;
	using typename B::Style;
	using typename B::StyleEx;

	static T*	Cast(Control c)			{ return c.Class().name() == B::ClassName() ? (T*)GetWindowLongPtr(c, GWLP_USERDATA) : 0; }
	static T*	FindAncestor(Control c) { return c.FindAncestor<T>(); }
	template<typename T2> static T2* CastByProcHelper(Control c) {
		return c.winproc== SubclassThunk<T2> ? static_cast<T2*>((Control*)GetWindowLongPtr(c, GWLP_USERDATA)) : nullptr;
	}

	template<typename...P> Subclass(P&&...p) : B(forward<P>(p)...) {
		if (hWnd)
			init(hWnd);
	}
	template<typename...P> auto Create(P&&...p) {
		return init(B::Create(forward<P>(p)...));
	};
	/*
	HWND Create(HWND hWndParent, const char *caption, Style style, StyleEx styleEx, const RECT &rect, ID id = ID()) {
		return init(B::Create(hWndParent, caption, style, styleEx, rect, id));
	};
	HWND Create(HWND hWndParent, const char *caption, Style style, StyleEx styleEx, const POINT &size, ID id = ID()) {
		return init(B::Create(hWndParent, caption, style, styleEx, size, id));
	}
	HWND Create(HWND hWndParent, const char *caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID()) {
		return init(B::Create(hWndParent, caption, style, styleEx, id));
	}
	HWND Create(const WindowPos &pos, const char *caption, Style style, StyleEx styleEx = B::NOEX, ID id = ID()) {
		return init(B::Create(pos, caption, style, styleEx, id));
	}
	*/
};

//-----------------------------------------------------------------------------
//	Window
//-----------------------------------------------------------------------------

struct WindowClass {
	struct Params : WNDCLASSA {
		Params(const char *name)		{ GetClassInfoA(0, name, this); }
		Params&	Proc(WNDPROC wp)		{ lpfnWndProc	= wp; return *this; }
		Params&	Name(const char *name)	{ lpszClassName = name; return *this; }
	};
	ATOM	atom;
	iso_export WindowClass(const char *name, WNDPROC proc, uint32 style, uint32 cextra, uint32 wextra, HBRUSH bg, HCURSOR hc);
	iso_export WindowClass(const WNDCLASSA &wc) { atom = RegisterClassA(&wc); }
	template<size_t N> WindowClass(meta::array<char, N> name, WNDPROC proc, uint32 style, uint32 cextra, uint32 wextra, HBRUSH bg, HCURSOR hc) :
		WindowClass(name.begin(), proc, style, cextra, wextra, bg, hc) {}
	operator ATOM()			const	{ return atom; }
	operator const char*()	const	{ return (const char*)(ULONG_PTR)(WORD)(atom); }
	Params		GetParams()	const	{ return Params(*this); }
};

template<typename T> LRESULT CALLBACK WindowThunk(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	auto	wnd = static_cast<T*>(T::toT((Control*)GetWindowLongPtr(hWnd, 0)));
	return wnd ? wnd->Proc((MSG_ID)msg, wParam, lParam) : DefWindowProc(hWnd, msg, wParam, lParam);
}

template<class T, class B = Control> class Window : public B {
protected:
	static auto			ClassName()	{
		return meta::fixed_name<T>();
	}
	static WindowClass	get_class() {
		static WindowClass wc(T::ClassName(), thunk, T::get_class_style(), T::get_class_cextra(), T::get_class_wextra(), T::get_class_background(), T::get_class_cursor());
		return wc;
	}
	static T*			make() {
		return 0;
	}

	static LRESULT CALLBACK	thunk(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
		if (msg == WM_NCCREATE) {
			Control	*c = (Control*)((CREATESTRUCT*)lParam)->lpCreateParams;
			if (!c)
				c = T::make();
			c->hWnd		= hWnd;
			c->winproc	= WindowThunk<T>;
			SetWindowLongPtr(hWnd, 0, (LONG_PTR)c);
		}
		return WindowThunk<T>(hWnd, msg, wParam, lParam);
	}

	LRESULT	Super(MSG_ID msg, WPARAM wParam = 0, LPARAM lParam = 0) {
		return B::Proc(msg, wParam, lParam);
	}

	template<typename T2> void	Rebind(T2 *t2, bool call_create = true) {
		ISO_ASSERT(GetWindowLongPtr(hWnd, 0) == (LONG_PTR)&t2->control());
		//SetWindowLongPtr(hWnd, 0, (LONG_PTR)&t2->control());
		winproc		= WindowThunk<T2>;
		if (call_create)
			t2->Proc(kWM_CREATE, 0, 0);
	}

public:
	using typename Control::Style;
	using typename Control::StyleEx;

	static T	*toT(Control *c) {
		if (!c)
			return nullptr;
		Control&	c2 = ((T*)0)->control();
		return (T*)((uint8*)c - (uint8*)&c2);
	}
	static T*	FindAncestor(Control c) { return c.FindAncestor<T>(); }
	static T*	Cast(Control c)	{
		return c.Class().atom == T::get_class() ? static_cast<T*>(T::toT((Control*)GetWindowLongPtr(c, 0))) : nullptr;
	}
	template<typename T2> static T2* CastByProcHelper(Control c) {
		return c.winproc== WindowThunk<T2> ? static_cast<T2*>(toT((Control*)GetWindowLongPtr(c, 0))) : nullptr;
	}

	HWND _Create(HWND hWndParent, const char *caption, HMENU hMenu, Control::Style style, Control::StyleEx styleEx, const RECT &rect) {
		Control&	c = static_cast<T*>(this)->control();
		return c = CreateWindowExA(styleEx, T::get_class(), caption, style, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hWndParent, hMenu, GetDefaultInstance(), &c);
	}
	HWND Create(const WindowPos &pos, text caption, HMENU hMenu, Control::Style style, Control::StyleEx styleEx = Control::NOEX)	{ return _Create(pos.Parent(), caption, hMenu, style, styleEx, pos.rect); }
	HWND Create(const WindowPos &pos, text caption, Control::Style style, Control::StyleEx styleEx = Control::NOEX, ID id = ID())	{ return _Create(pos.Parent(), caption, (HMENU)(LPARAM)id, style, styleEx, pos.rect); }

	template<typename...PP> Window(PP&&...pp) : B(forward<PP>(pp)...) {}
	Window(const WindowPos &pos, const char *caption, HMENU hMenu, Style style, StyleEx styleEx = Control::NOEX)	{ T::Create(pos, caption, hMenu, style, styleEx); }
	Window(const WindowPos &pos, const char *caption, Style style, StyleEx styleEx = Control::NOEX, ID id = ID())	{ T::Create(pos, caption, style, styleEx, id); }
};

template<typename T> T*	CastByProc(Control c)	{
	return T::template CastByProcHelper<T>(c);
}

template<typename T, typename B> using Inherit = Window<T, B>;

//-----------------------------------------------------------------------------
//	Dialog
//-----------------------------------------------------------------------------

struct DialogBase : Control {
public:
	DialogBase()						{}
	DialogBase(Control c) : Control(c)	{}
	Control		Item(int id)								const	{ return GetDlgItem(hWnd, id); }
	Control		operator[](int id)							const	{ return Item(id); }

	bool		IsButtonChecked(int id)						const	{ return IsDlgButtonChecked(hWnd, id) == BST_CHECKED; }
	bool		CheckButton(int id, bool check = true)		const	{ return !!CheckDlgButton(hWnd, id, check ? BST_CHECKED : BST_UNCHECKED); }
	bool		CheckButtons(int first, int last, int id)	const	{ return !!CheckRadioButton(hWnd, first, last, id); }
	string_getter<HWND> ItemText(int id)					const	{ return GetDlgItem(hWnd, id); }
	bool		EndDialog(int i)							const	{ return !!::EndDialog(*this, i); }

	HWND		GetNextTab(HWND hCtl, bool prev)			const	{ return GetNextDlgTabItem(hWnd, hCtl, prev); }
	HWND		GetNextGroup(HWND hCtl, bool prev)			const	{ return GetNextDlgGroupItem(hWnd, hCtl, prev); }
	void		SetFocus(HWND hCtl)							const	{ SendMessage(WM_NEXTDLGCTL, hCtl, TRUE); }
	void		SetFocus(int id)							const	{ SetFocus(Item(id)); }
	void		NextTab()									const	{ SendMessage(WM_NEXTDLGCTL, 0, FALSE); }
	void		PrevTab()									const	{ SendMessage(WM_NEXTDLGCTL, 1, FALSE); }
	int			DefaultID()									const	{ return LOWORD(SendMessage(DM_GETDEFID)); }
	void		DefaultID(int id)							const	{ SendMessage(DM_SETDEFID, id); }
	void		Reposition()								const	{ SendMessage(DM_REPOSITION); }
};

template<class T> struct DialogHelper {
	static T*	bind(Control *c, HWND hWnd)	{
		c->hWnd = hWnd;
		SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)c);
		return static_cast<T*>(c);
	}
	static INT_PTR CALLBACK	thunk(HWND hWnd, MSG_ID message, WPARAM wParam, LPARAM lParam) {
		T *wnd = message == WM_INITDIALOG
			? bind((Control*)lParam, hWnd)
			: static_cast<T*>((Control*)GetWindowLongPtr(hWnd, GWLP_USERDATA));
		return wnd ? wnd->Proc(message, wParam, lParam) : 0;
	}
};

template<typename T> class Dialog : public DialogBase {
protected:
	template<typename T2> void	Rebind(T2 *t2, bool call_init_dialog = true) {
		SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)(Control*)static_cast<T*>(t2));
		SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)DialogHelper<T2>::thunk);
		if (call_init_dialog)
			t2->Proc(kWM_INITDIALOG, 0, t2);
	}
	LPARAM		dlgparam() { return reinterpret_cast<LPARAM>((T*)this); }
public:
	static INT_PTR	CALLBACK dlgproc(HWND h, UINT m, WPARAM w, LPARAM l)	{ return DialogHelper<T>::thunk(h, (MSG_ID)m, w, l); }

	int			Modal(HINSTANCE hInst, HWND hWndParent, ID id)				{ return DialogBoxParamA(hInst, id, hWndParent, dlgproc, dlgparam()); }
	int			Modal(HWND hWndParent, ID id)								{ return Modal(GetDefaultInstance(), hWndParent, id); }
	int			Modal(HINSTANCE hInst, HWND hWndParent, DLGTEMPLATE *t)		{ return DialogBoxIndirectParamA(hInst, t, hWndParent, dlgproc, dlgparam()); }
	int			Modal(HWND hWndParent, DLGTEMPLATE *t)						{ return Modal(GetDefaultInstance(), hWndParent, t); }
	int			Modal(HWND hWndParent, Style style, DWORD dwExtendedStyle, int x, int y, int w, int h) {
		DLGTEMPLATE t = {style, dwExtendedStyle, 0, x, y, w, h} ;
		return Modal(hWndParent, &t);
	}

	HWND		Modeless(HINSTANCE hInst, HWND hWndParent, ID id)			{ return CreateDialogParamA(hInst, id, hWndParent, dlgproc, dlgparam()); }
	HWND		Modeless(HWND hWndParent, ID id)							{ return Modeless(GetDefaultInstance(), hWndParent, id); }
	HWND		Modeless(HINSTANCE hInst, HWND hWndParent, DLGTEMPLATE *t)	{ return CreateDialogIndirectParamA(hInst, t, hWndParent, dlgproc, dlgparam()); }
	HWND		Modeless(HWND hWndParent, DLGTEMPLATE *t)					{ return Modeless(GetDefaultInstance(), hWndParent, t); }
	HWND		Modeless(HWND hWndParent, Style style, DWORD dwExtendedStyle, int x, int y, int w, int h) {
		DLGTEMPLATE t = {style, dwExtendedStyle, 0, x, y, w, h} ;
		return Modeless(hWndParent, &t);
	}
};

//-----------------------------------------------------------------------------
//	Enumerator
//-----------------------------------------------------------------------------
template<typename T> class WindowEnumerator {
	static BOOL CALLBACK thunk(HWND hwnd, LPARAM lParam) {
		return (*(T*)lParam)(Control(hwnd));
	}
public:
	bool enum_thread(DWORD thread_id)	{ return !!EnumThreadWindows(thread_id, &thunk, LPARAM(static_cast<T*>(this))); }
	bool enum_this_thread()				{ return enum_thread(GetCurrentThreadId()); }
	bool enum_children(Control c)		{ return !!EnumChildWindows(c, &thunk, LPARAM(static_cast<T*>(this))); }
	bool enum_top()						{ return !!EnumWindows(&thunk, LPARAM(static_cast<T*>(this))); }
	bool enum_immediate_children(Control c) {
		for (auto i : c.Children()) {
			if (!(*static_cast<T*>(this))(i))
				return false;
		}
		return true;
	}
};

struct ChildEnumerator {
	WNDENUMPROC	proc;
	ChildEnumerator(WNDENUMPROC proc) : proc(proc) {}

	bool enum_immediate_children(Control c) {
		for (auto i : c.Children()) {
			if (!proc(i, (LPARAM)this))
				return false;
		}
		return true;
	}
	bool process(Control c) {
		return proc(c, (LPARAM)this);
	}
};

template<typename L> struct WindowEnumeratorLambda : ChildEnumerator {
	L				lambda;

	static BOOL CALLBACK thunk(HWND hwnd, LPARAM lParam) {
		auto	ce	= (ChildEnumerator*)lParam;
		return static_cast<WindowEnumeratorLambda*>(ce)->lambda(ce, hwnd);
	}
	auto	lparam() { return LPARAM(static_cast<ChildEnumerator*>(this)); }
public:
	WindowEnumeratorLambda(L &&lambda) : ChildEnumerator(&thunk), lambda(move(lambda)) {}
	bool enum_thread(DWORD thread_id)	{ return !!EnumThreadWindows(thread_id, &thunk, lparam()); }
	bool enum_children(Control c)		{ return !!EnumChildWindows(c, &thunk, lparam()); }
	bool enum_top()						{ return !!EnumWindows(&thunk, lparam()); }
};

template<typename L> bool enum_thread_windows(DWORD thread_id, L &&lambda)	{ return WindowEnumeratorLambda<L>(forward<L>(lambda)).enum_thread(thread_id); }
template<typename L> bool enum_child_windows(Control c, L &&lambda)			{ return WindowEnumeratorLambda<L>(forward<L>(lambda)).enum_children(c); }
template<typename L> bool enum_top_windows(L &&lambda)						{ return WindowEnumeratorLambda<L>(forward<L>(lambda)).enum_top(); }

//-----------------------------------------------------------------------------
//	Theme
//-----------------------------------------------------------------------------

iso_export void PaintCustomCaption(DeviceContext &dc, const char16 *title, const Rect &rect);
iso_export void PaintCustomCaption(DeviceContext &dc, const char16 *title, const Rect &rect, HFONT font, Colour col, int glow, int textflags);

} // namespace win

//-----------------------------------------------------------------------------
// in namespace iso
//-----------------------------------------------------------------------------

template<>	inline size_t	string_getter<HWND>::len()						const { return GetWindowTextLength(t); }
template<> template<>	inline size_t	string_getter<HWND>::get<char>(char *s, size_t len)		const { return GetWindowTextA(t, s, (int)len + 1); }
template<> template<>	inline size_t	string_getter<HWND>::get<char16>(char16 *s, size_t len)	const { return GetWindowTextW(t, s, (int)len + 1); }

//iso_export string_accum&	operator<<(string_accum &sa, const iso::Win32Error &v);

} // namespace iso

#endif	// WINDOW_H
