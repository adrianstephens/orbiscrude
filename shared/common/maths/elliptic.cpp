#include "base/maths.h"
namespace iso {

#if 0
// Reference: Fukushima, T, (2012) J. Comp. Appl. Math., 236, 1961-1975
//	Precise and fast computation of a general incomplete elliptic integral of third kind by half and double argument transformations
//	Author: Fukushima, T. <Toshio.Fukushima@nao.ac.jp>
//
//	F(phi|m):	Incomplete elliptic integral of the first kind
//	E(phi|m):	Incomplete elliptic integral of the second kind
//	F(phi|m) = B(phi|m) + D(phi|m)
//	E(phi|m) = B(phi|m) + (1-m) D(phi|m)

double	uatan(double t, double h);

double	calc_J_small(double y, double n, double m);
void	calc_BD_small(double phi, double m, double& B, double& D);

void	calc_BD_complete(double mc, double& B, double& D);
bool	calc_BDJ_complete(double nc0, double mc0, double& B, double& D, double& J);

bool	calc_BD(double s0, double mc, double& B, double& D);
bool	calc_BDJ(double s0, double n, double mc, double& B, double& D, double& J);


//---------------------------------------------------------------------------
// Calculate associate elliptic integrals of second kind, B(phi|m) and D(phi|m)
//
//     Inputs: phi  = argument                0 <= phi  <= pi/2
//             phic = complementar argument   0 <= phic <= pi/2
//             mc   = complementary parameter 0 <= mc   <= 1
//
//     Outputs: B, D
//     CAUTION: phi and phic must satisfy condition, phi + phic = pi/2
//
bool associate_elliptic_integrals(double phi, double phic, double mc, double& B, double& D) {
	if (phi < 1.249)	// Modified: Pascal Leroy's suggestion 2019/08/12
		return calc_BD(sin(phi), mc, B, D);

	double	m	= 1 - mc;
	double	c	= sin(phic);
	double	x	= c * c;
	double	d2	= mc + m * x;

	double	BC, DC;

	if (x < 0.9 * d2) {
		double	z = c / sqrt(d2);
		double	sz = z * sqrt(1 - x);

		calc_BD(z, mc, B, D);
		calc_BD_complete(mc, BC, DC);

		B  = BC - (B - sz);
		D  = DC - (D + sz);
		return true;
	}

	if (mc * (1 - x) < x * d2)
		return calc_BD(sqrt(1 - x), mc, B, D);

	double	t2 = (1 - x) / d2;
	double	sz = c * sqrt(t2);

	calc_BD(sqrt(1 - mc * t2), mc, B, D);
	calc_BD_complete(mc, BC, DC);

	B  = BC - (B - sz);
	D  = DC - (D + sz);
	return true;
}

//---------------------------------------------------------------------------
// Calculate associate elliptic integrals of third kind, B(phi|m), D(phi|m), and J(phi,n|m)
//
//     Inputs: phi  = argument                0 <= phi  <= pi/2
//             phic = complementar argument   0 <= phic <= pi/2
//             n    = characteristic          0 <= n    <= 1
//             mc   = complementary parameter 0 <= mc   <= 1
//
//     Outputs: B, D, J
//     CAUTION: phi and phic must satisfy condition, phi + phic = pi/2
//
bool associate_elliptic_integrals(double phi, double phic, double n, double mc, double& B, double& D, double& J) {
	if (phi < 1.249)	// Modified: Pascal Leroy's suggestion 2019/08/12
		return calc_BDJ(sin(phi), n, mc, B, D, J);

	double	m	= 1 - mc;
	double	nc	= 1 - n;
	double	h	= n * nc * (n - m);
	double	c	= sin(phic);
	double	x	= c * c;
	double	d2	= mc + m * x;

	double	BC, DC, JC;

	if (x < 0.9 * d2) {
		double	z = c / sqrt(d2);
		double	sz = z * sqrt(1 - x);

		calc_BDJ(z, n, mc, B, D, J);
		calc_BDJ_complete(nc, mc, BC, DC, JC);

		B  = BC - (B - sz);
		D  = DC - (D + sz);
		J  = JC - (J + uatan(sz / nc, h));
		return true;
	}

	if (mc * (1 - x) < x * d2)
		return calc_BDJ(sqrt(1 - x), n, mc, B, D, J);

	double	t2 = (1 - x) / d2;
	double	sz = c * sqrt(t2);

	calc_BDJ(sqrt(1 - mc * t2), n, mc, B, D, J);
	calc_BDJ_complete(nc, mc, BC, DC, JC);

	B  = BC - (B - sz);
	D  = DC - (D + sz);
	J  = JC - (J + uatan(sz / nc, h));
	return true;
}

//---------------------------------------------------------------------------
// Simultaneous computation of associate complete elliptic integrals of second kind, B(m) and D(m)
//
void calc_BD_complete(double mc, double& B, double& D) {
	static const double EPS	= 1.11e-16;

	static const double B1 = 1. / 2;
	static const double B2 = 1. / 16;
	static const double B3 = 3. / 128;
	static const double B4 = 25. / 2048;
	static const double B5 = 245. / 32768;
	static const double B6 = 1323. / 262144;
	static const double B7 = 7623. / 2097152;
	static const double B8 = 184041. / 67108864;

	static const double D1 = 1. / 2;
	static const double D2 = 3. / 16;
	static const double D3 = 15. / 128;
	static const double D4 = 175. / 2048;
	static const double D5 = 2205. / 32768;
	static const double D6 = 14553. / 262144;
	static const double D7 = 99099. / 2097152;
	static const double D8 = 2760615. / 67108864;

	double	m = 1 - mc;
	if (m < EPS) {
		B = pi / 4;
		D = pi / 4;

	} else if (mc < EPS) {
		B = 1;
		D = 0.3862943611198906188344642429164 - 0.5 * log(mc);

	} else if (mc < 0.1) {
		double	nome = horner(mc, 0.,
			1. / 16,
			1. / 32,
			21. / 1024,
			31. / 2048,
			6257. / 524288,
			10293. / 1048576,
			279025. / 33554432,
			483127. / 67108864,
			435506703. / 68719476736,
			776957575. / 137438953472,
			22417045555. / 4398046511104,
			40784671953. / 8796093022208,
			9569130097211. / 2251799813685248,
			17652604545791. / 4503599627370496,
			523910972020563. / 144115188075855872,
			976501268709949. / 288230376151711744
		);
		double	dkkc, dddc;
		if (mc < 0.01) {
			dkkc = horner(mc, 0.,
				1. / 4,
				9. / 64,
				25. / 256,
				1225. / 16384,
				3969. / 65536,
				53361. / 1048576,
				184041. / 4194304
			);
			dddc = horner(mc, 0., D1, D2, D3, D4, D5, D6, D7);

		} else {
			double	mx = mc - 0.05;
			//
			// (K'-1)/(pi/2)
			//
			dkkc = horner(mx,
				0.01286425658832983978282698630501405107893,
				0.26483429894479586582278131697637750604652,
				0.15647573786069663900214275050014481397750,
				0.11426146079748350067910196981167739749361,
				0.09202724415743445309239690377424239940545,
				0.07843218831801764082998285878311322932444,
				0.06935260142642158347117402021639363379689,
				0.06293203529021269706312943517695310879457,
				0.05821227592779397036582491084172892108196,
				0.05464909112091564816652510649708377642504,
				0.05191068843704411873477650167894906357568,
				0.04978344771840508342564702588639140680363,
				0.04812375496807025605361215168677991360500
			);
			//
			// (K'-E')/(pi/2)
			//
			dddc = horner(mx,
				0.02548395442966088473597712420249483947953,
				0.51967384324140471318255255900132590084179,
				0.20644951110163173131719312525729037023377,
				0.13610952125712137420240739057403788152260,
				0.10458014040566978574883406877392984277718,
				0.08674612915759188982465635633597382093113,
				0.07536380269617058326770965489534014190391,
				0.06754544594618781950496091910264174396541,
				0.06190939688096410201497509102047998554900,
				0.05771071515451786553160533778648705873199,
				0.05451217098672207169493767625617704078257,
				0.05204028407582600387265992107877094920787,
				0.05011532514520838441892567405879742720039
			);
		}
		double	kkc	  = 1 + dkkc;
		double	logq2 = -0.5 * log(nome);
		double	elk	  = kkc * logq2;
		double	dele  = -dkkc / kkc + logq2 * dddc;
		double	elk1  = elk - 1;
		double	delb  = (dele - mc * elk1) / m;
		B	= 1 + delb;
		D	= elk1 - delb;

	} else if (m <= 0.01) {
		B	= pi / 2 * horner(m, B1, B2, B3, B4, B5, B6, B7, B8);
		D	= pi / 2 * horner(m, D1, D2, D3, D4, D5, D6, D7, D8);

	} else if (m <= 0.1) {
		double	mx	= 0.95 - mc;
		B = horner(mx,
			0.790401413584395132310045630540381158921005,
			0.102006266220019154892513446364386528537788,
			0.039878395558551460860377468871167215878458,
			0.021737136375982167333478696987134316809322,
			0.013960979767622057852185340153691548520857,
			0.009892518822669142478846083436285145400444,
			0.007484612400663335676130416571517444936951,
			0.005934625664295473695080715589652011420808,
			0.004874249053581664096949448689997843978535,
			0.004114606930310886136960940893002069423559,
			0.003550452989196176932747744728766021440856,
			0.003119229959988474753291950759202798352266
		);
		D = horner(mx,
			0.800602040206397047799296975176819811774784,
			0.313994477771767756849615832867393028789057,
			0.205913118705551954501930953451976374435088,
			0.157744346538923994475225014971416837073598,
			0.130595077319933091909091103101366509387938,
			0.113308474489758568672985167742047066367053,
			0.101454199173630195376251916342483192174927,
			0.0929187842072974367037702927967784464949434,
			0.0865653801481680871714054745336652101162894,
			0.0817279846651030135350056216958053404884715,
			0.0779906657291070378163237851392095284454654,
			0.075080426851268007156477347905308063808848
		);

	} else if (m <= 0.2) {
		double	mx	= 0.85 - mc;
		B = horner(mx,
			0.80102406445284489393880821604009991524037,
			0.11069534452963401497502459778015097487115,
			0.047348746716993717753569559936346358937777,
			0.028484367255041422845322166419447281776162,
			0.020277811444003597057721308432225505126013,
			0.015965005853099119442287313909177068173564,
			0.013441320273553634762716845175446390822633,
			0.011871565736951439501853534319081030547931,
			0.010868363672485520630005005782151743785248,
			0.010231587232710564565903812652581252337697,
			0.009849585546666211201566987057592610884309,
			0.009656606347153765129943681090056980586986
		);
		D = horner(mx,
			0.834232667811735098431315595374145207701720,
			0.360495281619098275577215529302260739976126,
			0.262379664114505869328637749459234348287432,
			0.223723944518094276386520735054801578584350,
			0.206447811775681052682922746753795148394463,
			0.199809440876486856438050774316751253389944,
			0.199667451603795274869211409350873244844882,
			0.204157558868236842039815028663379643303565,
			0.212387467960572375038025392458549025660994,
			0.223948914061499360356873401571821627069173,
			0.238708097425597860161720875806632864507536,
			0.256707203545463755643710021815937785120030
		);

	} else if (m <= 0.3) {
		double	mx	= 0.75 - mc;
		B = horner(mx,
			0.81259777291992049322557009456643357559904,
			0.12110961794551011284012693733241967660542,
			0.057293376831239877456538980381277010644332,
			0.038509451602167328057004166642521093142114,
			0.030783430301775232744816612250699163538318,
			0.027290564934732526869467118496664914274956,
			0.025916369289445198731886546557337255438083,
			0.025847203343361799141092472018796130324244,
			0.026740923539348854616932735567182946385269,
			0.028464314554825704963640157657034405579849,
			0.030995446237278954096189768338119395563447,
			0.034384369179940975864103666824736551261799,
			0.038738002072493935952384233588242422046537
		);
		D = horner(mx,
			0.873152581892675549645633563232643413901757,
			0.420622230667770215976919792378536040460605,
			0.344231061559450379368201151870166692934830,
			0.331133021818721761888662390999045979071436,
			0.345277285052808411877017306497954757532251,
			0.377945322150393391759797943135325823338761,
			0.427378012464553880508348757311170776829930,
			0.494671744307822405584118022550673740404732,
			0.582685115665646200824237214098764913658889,
			0.695799207728083164790111837174250683834359,
			0.840018401472533403272555302636558338772258,
			1.023268503573606060588689738498395211300483,
			1.255859085136282496149035687741403985044122
		);

	} else if (m <= 0.4) {
		double	mx	= 0.65 - mc;
		B = horner(mx,
			0.8253235579835158949845697805395190063745,
			0.1338621160836877898575391383950840569989,
			0.0710112935979886745743770664203746758134,
			0.0541784774173873762208472152701393154906,
			0.0494517449481029932714386586401273353617,
			0.0502221962241074764652127892365024315554,
			0.0547429131718303528104722303305931350375,
			0.0627462579270016992000788492778894700075,
			0.0746698810434768864678760362745179321956,
			0.0914808451777334717996463421986810092918,
			0.1147050921109978235104185800057554574708,
			0.1465711325814398757043492181099197917984,
			0.1902571373338462844225085057953823854177
		);
		D = horner(mx,
			0.9190270392420973478848471774160778462738,
			0.5010021592882475139767453081737767171354,
			0.4688312705664568629356644841691659415972,
			0.5177142277764000147059587510833317474467,
			0.6208433913173031070711926900889045286988,
			0.7823643937868697229213240489900179142670,
			1.0191145350761029126165253557593691585239,
			1.3593452027484960522212885423056424704073,
			1.8457173023588279422916645725184952058635,
			2.5410717031539207287662105618152273788399,
			3.5374046552080413366422791595672470037341,
			4.9692960029774259303491034652093672488707,
			7.0338228700300311264031522795337352226926,
			10.020043225034471401553194050933390974016
		);

	} else if (m <= 0.5) {
		double	mx	= 0.55 - mc;
		B = horner(mx,
			0.8394795702706129706783934654948360410325,
			0.1499164403063963359478614453083470750543,
			0.0908319358194288345999005586556105610069,
			0.0803470334833417864262134081954987019902,
			0.0856384405004704542717663971835424473169,
			0.1019547259329903716766105911448528069506,
			0.1305748115336160150072309911623351523284,
			0.1761050763588499277679704537732929242811,
			0.2468351644029554468698889593583314853486,
			0.3564244768677188553323196975301769697977,
			0.5270025622301027434418321205779314762241,
			0.7943896342593047502260866957039427731776,
			1.2167625324297180206378753787253096783993
		);
		D = horner(mx,
			0.9744043665463696730314687662723484085813,
			0.6132468053941609101234053415051402349752,
			0.6710966695021669963502789954058993004082,
			0.8707276201850861403618528872292437242726,
			1.2295422312026907609906452348037196571302,
			1.8266059675444205694817638548699906990301,
			2.8069345309977627400322167438821024032409,
			4.4187893290840281339827573139793805587268,
			7.0832360574787653249799018590860687062869,
			11.515088120557582942290563338274745712174,
			18.931511185999274639516732819605594455165,
			31.411996938204963878089048091424028309798,
			52.520729454575828537934780076768577185134,
			88.384854735065298062125622417251073520996,
			149.56637449398047835236703116483092644714,
			254.31790843104117434615624121937495622372
		);

	} else if (m <= 0.6) {
		double	mx	= 0.45 - mc;
		B = horner(mx,
			0.8554696151564199914087224774321783838373,
			0.1708960726897395844132234165994754905373,
			0.1213352290269482260207667564010437464156,
			0.1282018835749474096272901529341076494573,
			0.1646872814515275597348427294090563472179,
			0.2374189087493817423375114793658754489958,
			0.3692081047164954516884561039890508294508,
			0.6056587338479277173311618664015401963868,
			1.0337055615578127436826717513776452476106,
			1.8189884893632678849599091011718520567105,
			3.2793776512738509375806561547016925831128,
			6.0298883807175363312261449542978750456611,
			11.269796855577941715109155203721740735793,
			21.354577850382834496786315532111529462693
		);
		D = horner(mx,
			1.04345529511513353426326823569160142342838,
			0.77962572192850485048535711388072271372632,
			1.02974236093206758187389128668777397528702,
			1.62203722341135313022433907993860147395972,
			2.78798953118534762046989770119382209443756,
			5.04838148737206914685643655935236541332892,
			9.46327761194348429539987572314952029503864,
			18.1814899494276679043749394081463811247757,
			35.5809805911791687037085198750213045708148,
			70.6339354619144501276254906239838074917358,
			141.828580083433059297030133195739832297859,
			287.448751250132166257642182637978103762677,
			587.115384649923076181773192202238389711345,
			1207.06543522548061603657141890778290399603,
			2495.58872724866422273012188618178997342537,
			5184.69242939480644062471334944523925163600,
			10817.2133369041327524988910635205356016939
		);

	} else if (m <= 0.7) {
		double	mx	= 0.35 - mc;
		B = horner(mx,
			0.8739200618486431359820482173294324246058,
			0.1998140574823769459497418213885348159654,
			0.1727696158780152128147094051876565603862,
			0.2281069132842021671319791750725846795701,
			0.3704681411180712197627619157146806221767,
			0.6792712528848205545443855883980014994450,
			1.3480084966817573020596179874311042267679,
			2.8276709768538207038046918250872679902352,
			6.1794682501239140840906583219887062092430,
			13.935686010342811497608625663457407447757,
			32.218929281059722026322932181420383764028,
			76.006962959226101026399085304912635262362,
			182.32144908775406957609058046006949657416,
			443.51507644112648158679360783118806161062,
			1091.8547229028388292980623647414961662223,
			2715.7658664038195881056269799613407111521
		);
		D = horner(mx,
			1.13367833657573316571671258513452768536080,
			1.04864317372997039116746991765351150490010,
			1.75346504119846451588826580872136305225406,
			3.52318272680338551269021618722443199230946,
			7.74947641381397458240336356601913534598302,
			17.9864500558507330560532617743406294626849,
			43.2559163462326133313977294448984936591235,
			106.681534454096017031613223924991564429656,
			268.098486573117433951562111736259672695883,
			683.624114850289804796762005964155730439745,
			1763.49708521918740723028849567007874329637,
			4592.37475383116380899419201719007475759114,
			12053.4410190488892782190764838488156555734,
			31846.6630207420816960681624497373078887317,
			84621.2213590568080177035346867495326879117,
			225956.423182907889987641304430180593010940,
			605941.517281758859958050194535269219533685,
			1.63108259953926832083633544697688841456604e6
		);

	} else if (m <= 0.8) {
		double	mx	= 0.25 - mc;
		B = horner(mx,
			0.895902820924731621258525533131864225704,
			0.243140003766786661947749288357729051637,
			0.273081875594105531575351304277604081620,
			0.486280007533573323895498576715458103274,
			1.082747437228230914750752674136983406683,
			2.743445290986452500459431536349945437824,
			7.555817828670234627048618342026400847824,
			22.05194082493752427472777448620986154515,
			67.15640644740229407624192175802742979626,
			211.2722537881770961691291434845898538537,
			681.9037843053270682273212958093073895805,
			2246.956231592536516768812462150619631201,
			7531.483865999711792004783423815426725079,
			25608.51260130241579018675054866136922157,
			88140.74740089604971425934283371277143256,
			306564.4242098446591430938434419151070722,
			1.076036077811072193752770590363885180738e6,
			3.807218502573632648224286313875985190526e6,
			1.356638224422139551020110323739879481042e7
		);
		D = horner(mx,
			1.26061282657491161418014946566845780315983,
			1.54866563808267658056930177790599939977154,
			3.55366941187160761540650011660758187283401,
			9.90044467610439875577300608183010716301714,
			30.3205666174524719862025105898574414438275,
			98.1802586588830891484913119780870074464833,
			329.771010434557055036273670551546757245808,
			1136.65598974289039303581967838947708073239,
			3993.83433574622979757935610692842933356144,
			14242.7295865552708506232731633468180669284,
			51394.7572916887209594591528374806790960057,
			187246.702914623152141768788258141932569037,
			687653.092375389902708761221294282367947659,
			2.54238553565398227033448846432182516906624e6,
			9.45378121934749027243313241962076028066811e6,
			3.53283630179709170835024033154326126569613e7,
			1.32593262383393014923560730485845833322771e8,
			4.99544968184054821463279808395426941549833e8,
			1.88840934729443872364972817525484292678543e9,
			7.16026753447893719179055010636502508063102e9,
			2.72233079469633962247554894093591262281929e10
		);

	} else if (m <= 0.85) {
		double	mx	= 0.175 - mc;
		B = horner(mx,
			0.915922052601931494319853880201442948834592,
			0.294714252429483394379515488141632749820347,
			0.435776709264636140422971598963772380161131,
			1.067328246493644238508159085364429570207744,
			3.327844118563268085074646976514979307993733,
			11.90406004445092906188837729711173326621810,
			46.47838820224626393512400481776284680677096,
			192.7556002578809476962739389101964074608802,
			835.3356299261900063712302517586717381557137,
			3743.124548343029102644419963712353854902019,
			17219.07731004063094108708549153310467326395,
			80904.60401669850158353080543152212152282878,
			386808.3292751742460123683674607895217760313,
			1.876487670110449342170327796786290400635732e6,
			9.216559908641567755240142886998737950775910e6
		);
		D = horner(mx,
			1.402200569110579095046054435635136986038164,
			2.322205897861749446534352741005347103992773,
			7.462158366466719682730245467372788273333992,
			29.43506890797307903104978364254987042421285,
			128.1590924337895775262509354898066132182429,
			591.0807036911982326384997979640812493154316,
			2830.546229607726377048576057043685514661188,
			13917.76431889392229954434840686741305556862,
			69786.10525163921228258055074102587429394212,
			355234.1420341879634781808899208309503519936,
			1.830019186413931053503912913904321703777885e6,
			9.519610812032515607466102200648641326190483e6,
			4.992086875574849453986274042758566713803723e7,
			2.635677009826023473846461512029006874800883e8,
			1.399645765120061118824228996253541612110338e9,
			7.469935792837635004663183580452618726280406e9,
			4.004155595835610574316003488168804738481448e10,
			2.154630668144966654449602981243932210695662e11
		);

	} else {
		double	mx	= 0.125 - mc;
		B = horner(mx,
			0.931906061029524827613331428871579482766771,
			0.348448029538453860999386797137074571589376,
			0.666809178846938247558793864839434184202736,
			2.210769135708128662563678717558631573758222,
			9.491765048913406881414290930355300611703187,
			47.09304791027740853381457907791343619298913,
			255.9200460211233087050940506395442544885608,
			1480.029532675805407554800779436693505109703,
			8954.040904734313578374783155553041065984547,
			56052.48220982686949967604699243627330816542,
			360395.7241626000916973524840479780937869149,
			2.367539415273216077520928806581689330885103e6,
			1.582994957277684102454906900025484391190264e7,
			1.074158093278511100137056972128875270067228e8,
			7.380585460239595691878086073095523043390649e8,
			5.126022002555101496684687154904781856830296e9,
			3.593534065502416588712409180013118409428367e10,
			2.539881257612812212004146637239987308133582e11,
			1.808180007145359569674767150594344316702507e12
		);
		D = horner(mx,
			1.541690112721819084362258323861459983048179,
			3.379176214579645449453938918349243359477706,
			14.94058385670236671625328259137998668324435,
			81.91773929235074880784578753539752529822986,
			497.4900546551479866036061853049402721939835,
			3205.184010234846235275447901572262470252768,
			21457.32237355321925571253220641357074594515,
			147557.0156564174712105689758692929775004292,
			1.035045290185256525452269053775273002725343e6,
			7.371922334832212125197513363695905834126154e6,
			5.314344395142401141792228169170505958906345e7,
			3.868823475795976312985118115567305767603128e8,
			2.839458401528033778425531336599562337200510e9,
			2.098266122943898941547136470383199468548861e10,
			1.559617754017662417944194874282275405676282e11,
			1.165096220419884791236699872205721392201682e12,
			8.742012983013913804987431275193291316808766e12,
			6.584725462672366918676967847406180155459650e13,
			4.976798737062434393396993620379481464465749e14,
			3.773018634056605404718444239040628892506293e15,
			2.868263194837819660109735981973458220407767e16
		);
	}
};

//---------------------------------------------------------------------------
// Simultaneous computation of associate complete elliptic integrals of third kind, B(m), D(m), and J(n|m)
// Restricted Version with Assumptions: 0 < mc, 0 < nc
//
bool calc_BDJ_complete(double nc0, double mc0, double& B, double& D, double& J) {
	static const int	IMAX	= 40;
	static const double EPS		= 1.11e-16;

	if (mc0 <= 0 || nc0 <= 0)
		return false;

	double		mc, nc;
	if (mc0 < 1) {
		mc	= mc0;
		nc	= nc0;
	} else if (mc0 > 1) {
		mc	= 1 / mc0;
		nc	= nc0 * mc;
	} else {
		B	= pi / 4;
		D	= pi / 4;
		J	= pi / (2 * (nc0 + sqrt(nc0)));
		return true;
	}

	calc_BD_complete(mc, B, D);
	if (nc == mc) {
		J = B / mc;

	} else {
		double	y[IMAX], x[IMAX], c[IMAX], d[IMAX], a[IMAX];
		double	m	 = 1 - mc;
		double	n	 = 1 - nc;
		bool	flag = nc < mc || n * nc > nc - mc;

		y[0] = flag ? (nc - mc) / (nc * m) : n / m;

		int	is = 0;
		if (y[0] > 0.5) {
			x[0] = 1 - y[0];
			for (int i = 0; i < IMAX; i++) {
				c[i]	= sqrt(x[i]);
				d[i]	= sqrt(mc + m * x[i]);
				x[i + 1] = (c[i] + d[i]) / (1 + d[i]);
				if (x[i + 1] > 0.5) {
					y[i + 1] = y[i] / ((1 + c[i]) * (1 + d[i]));
					is	= i + 1;
					break;
				}
				y[i + 1] = 1 - x[i + 1];
			}
			return true;
		}

		int	i;
		for (i = is; i < IMAX; i++) {
			c[i]	= sqrt(1 - y[i]);
			d[i]	= sqrt(1 - m * y[i]);
			y[i + 1] = y[i] / ((1 + c[i]) * (1 + d[i]));
			if (abs(y[i + 1]) < 0.325)
				break;
		}
		if (i == IMAX)
			return false;

		int		ie		= i + 1;
		double	ye		= y[ie], yi = ye;
		double	celk	= B + D;
		a[0]	= J = D;
		a[1]	= ((1 + 2 * m) * D - B) / 3;

		double	dj		= a[1] * yi;
		i		= 1;

		if (abs(dj) >= EPS * abs(J)) {
			J = J + dj;
			double	m1	 = 1 + m;
			for (int i = 2; i < IMAX; i++) {
				yi	 = yi * ye;
				a[i] = (1 - 1. / (2 * i + 1)) * m1 * a[i - 1] - (1 - 2. / (2 * i + 1)) * m * a[i - 2];
				dj	 = a[i] * yi;
				if (abs(dj) < EPS * abs(J))
					break;
				J = J + dj;
			}
			if (i == IMAX)
				return false;
		}

		for (i = ie; --i; --i)
			J = (2 * (c[i] + d[i]) * J - y[i] * celk) / (c[i] * d[i] * (1 + c[i]) * (1 + d[i]));

		if (flag)
			J = (nc * celk - mc * J) / (nc * nc);
	}

	if (mc0 > 1) {
		double	kc0		= sqrt(mc0);
		double	temp	= B;
		B	= D / kc0;
		D	= temp / kc0;
		J	= J / (mc0 * kc0);
	}
	return true;
}

//---------------------------------------------------------------------------
// Calculate associate elliptic integrals B(phi|m), D(phi|m) by using the half/double argument transformation of sn functions
//
bool calc_BD(double s0, double mc, double& B, double& D) {
	double	yy[10], ss[10];

	double	m	= 1 - mc;
	double	del	= 0.01622;	// J9

	double	s	= s0;
	double	y	= s * s;
	yy[0]	= y;
	ss[0]	= s;
	int	i	= 0;
	for (; i < 9 && y >= del; i++) {
		double	c	= sqrt(1 - y);
		D			= sqrt(1 - m * y);
		y			= y / ((1 + c) * (1 + D));
		yy[i + 1]	= y;
		ss[i + 1]	= sqrt(y);
	}

	if (i == 10)
		return false;

	calc_BD_small(y, m, B, D);
	B = ss[i] * B;
	D = ss[i] * y * D;
	for (int k = i; k--; ) {
		double	sy = ss[k] * yy[k + 1];
		B  = 2 * B - sy;
		D  = 2 * D + sy;
	}
	return true;
}

//---------------------------------------------------------------------------
// Calculate associate elliptic integrals B(phi|m), D(phi|m), and J(phi,n|m) by using the half/double argument transformation of sn functions
//
bool calc_BDJ(double s0, double n, double mc, double& B, double& D, double& J) {
	double	yy[10], ss[10], cd[10];

	double	m	= 1 - mc;
	double	h	= n * (1 - n) * (n - m);
	double	del	= 0.01622;	// J9

	double	s	= s0;
	double	y	= s * s;
	yy[0]	= y;
	ss[0]	= s;
	int	i	= 0;
	for (; i < 9 && y >= del; i++) {
		double	c	= sqrt(1 - y);
		D			= sqrt(1 - m * y);
		y			= y / ((1 + c) * (1 + D));
		yy[i + 1]	= y;
		ss[i + 1]	= sqrt(y);
		cd[i]		= c * D;
	}

	if (i == 10)
		return false;

	calc_BD_small(y, m, B, D);
	B = ss[i] * B;
	D = ss[i] * y * D;
	J = ss[i] * calc_J_small(y, n, m);
	for (int k = i; k--; ) {
		double	sy = ss[k] * yy[k + 1];
		double	t  = sy / (1 - n * (yy[k] - yy[k + 1] * cd[k]));
		B  = 2 * B - sy;
		D  = 2 * D + sy;
		J  = 2 * J + uatan(t, h);
	}
	return true;
}

//---------------------------------------------------------------------------
// Calculate associate elliptic integrals, B(phi|m) and D(phi|m), for small arguments by the series expansion
//
void calc_BD_small(double phi, double m, double& B, double& D) {
	static const double F10 = 1;
	static const double F20 = 3, F21 = 2;
	static const double F30 = 5, F31 = 3;
	static const double F40 = 35, F41 = 20, F42 = 18;
	static const double F50 = 63, F51 = 35, F52 = 30;
	static const double F60 = 231, F61 = 126, F62 = 105, F63 = 100;
	static const double F70 = 429, F71 = 231, F72 = 189, F73 = 175;
	static const double F80 = 6435, F81 = 3432, F82 = 2722, F83 = 2520, F84 = 2450;
	static const double F90 = 12155, F91 = 6435, F92 = 5148, F93 = 4620, F94 = 4410;
	static const double FA0 = 46189, FA1 = 24310, FA2 = 19305, FA3 = 17160, FA4 = 16170, FA5 = 15876;
	static const double FB0 = 88179, FB1 = 46189, FB2 = 36465, FB3 = 32175, FB4 = 30030, FB5 = 29106;

	double F1 = horner(m, F10, F10) / 6;
	double F2 = horner(m, F20, F21, F20) / 40;
	double F3 = horner(m, F30, F31, F31, F30) / 112;
	double F4 = horner(m, F40, F41, F42, F41, F40) / 1152;
	double F5 = horner(m, F50, F51, F52, F52, F51, F50) / 2816;
	double F6 = horner(m, F60, F61, F62, F63, F62, F61, F60) / 13312;
	double F7 = horner(m, F70, F71, F72, F73, F73, F72, F71, F70) / 30720;
	double F8 = horner(m, F80, F81, F82, F83, F84, F83, F82, F81, F80) / 557056;
	double F9 = horner(m, F90, F91, F92, F93, F94, F94, F93, F92, F91, F90) / 1245184;
	double FA = horner(m, FA0, FA1, FA2, FA3, FA4, FA5, FA4, FA3, FA2, FA1, FA0) / 5505024;
	double FB = horner(m, FB0, FB1, FB2, FB3, FB4, FB5, FB5, FB4, FB3, FB2, FB1, FB0) / 12058624;

	static const double A1 = 3. / 5;
	static const double A2 = 5. / 7;
	static const double A3 = 7. / 9;
	static const double A4 = 9. / 11;
	static const double A5 = 11. / 13;
	static const double A6 = 13. / 15;
	static const double A7 = 15. / 17;
	static const double A8 = 17. / 19;
	static const double A9 = 19. / 21;
	static const double AA = 21. / 23;
	static const double AB = 23. / 25;

	D = horner(phi, 1.0 / 3.0, F1 * A1, F2 * A2, F3 * A3, F4 * A4, F5 * A5, F6 * A6, F7 * A7, F8 * A8, F9 * A9, FA * AA, FB * AB);
	B = horner(phi, 1.0, F1 * (1 - A1), F2 * (1 - A2), F3 * (1 - A3), F4 * (1 - A4), F5 * (1 - A5), F6 * (1 - A6), F7 * (1 - A7), F8 * (1 - A8), F9 * (1 - A9), FA * (1 - AA), FB * (1 - AB));
}

//---------------------------------------------------------------------------
//
// Computation of associate elliptic integral J(phi,n|m) for small arguments by the series expansion
//
double calc_J_small(double y, double n, double m) {
	double	J1 = 1. / 3;
	double	J2 = (1 + n * 2 + m * 1) / 10;

//	if (y <  9.2925066e-09)
//		return horner(y, 0., J1, J2);

	double	J3 = horner(m,
		horner(n, 3, 4, 8),
		horner(n, 2, 4),
		3
	) / 56;

//	if (y <  4.3667383e-06)
//		return horner(y, 0., J1, J2, J3);

	double	J4 = horner(m,
		horner(n, 5, 6, 8, 16),
		horner(n, 3, 4, 8),
		horner(n, 3, 6),
		5
	) / 144;

//	if (y < 9.4990006e-05)
//		return horner(y, 0., J1, J2, J3, J4);

	double	J5 = horner(m,
		horner(n, 35, 40, 48, 64, 128),
		horner(n, 20, 24, 32, 64),
		horner(n, 18, 24, 48),
		horner(n, 20, 40),
		35
	) / 1408;

	if (y <= 6.0369310e-04)
		return horner(y, 0., J1, J2, J3, J4, J5);

	double	J6 = horner(m,
		horner(n, 63, 70, 80, 96, 128, 256),
		horner(n, 35, 40, 48, 64, 128),
		horner(n, 30, 36, 48, 96),
		horner(n, 30, 40, 80),
		horner(n, 35, 70),
		63
	) / 3328;

	if (y <= 2.0727505e-03)
		return horner(y, 0., J1, J2, J3, J4, J5, J6);

	double	J7 = horner(m,
		horner(n, 231, 252, 280, 320, 384, 512, 1024),
		horner(n, 126, 140, 160, 192, 256, 512),
		horner(n, 105, 120, 144, 192, 384),
		horner(n, 100, 120, 160, 320),
		horner(n, 105, 140, 280),
		horner(n, 126, 252),
		231
	) / 15360;

	if (y <= 5.0047026e-03)
		return horner(y, 0., J1, J2, J3, J4, J5, J6, J7);

	double	J8 = horner(m,
		horner(n, 429, 462, 504, 560, 640, 768, 1024, 2048),
		horner(n, 231, 252, 280, 320, 384, 512, 1024),
		horner(n, 189, 210, 240, 288, 284, 768),
		horner(n, 175, 200, 240, 320, 640),
		horner(n, 175, 210, 280, 560),
		horner(n, 189, 252, 504),
		horner(n, 231, 462),
		429
	) / 34816;

	if (y <= 9.6961652e-03)
		return horner(y, 0., J1, J2, J3, J4, J5, J6, J7, J8);

	double	J9 = horner(m,
		horner(n, 6435, 6864, 7392, 8064, 8960, 10240, 12288, 16384, 32768),
		horner(n, 3432, 3696, 4032, 4480, 5120, 6144, 8192, 16384),
		horner(n, 2772, 3024, 3360, 3840, 4608, 6144, 12288),
		horner(n, 2520, 2800, 3200, 3840, 5120, 10240),
		horner(n, 2450, 2800, 3360, 4480, 8960),
		horner(n, 2520, 3024, 4032, 8064),
		horner(n, 2772, 3696, 7392),
		horner(n, 3432, 6864),
		6435
	) / 622592;

	if (y <= 1.6220210e-02)
		return horner(y, 0., J1, J2, J3, J4, J5, J6, J7, J8, J9);

	double	JA = horner(m,
		horner(n, 12155, 12870, 13728, 14784, 16128, 17920, 20480, 24576, 32768, 65536),
		horner(n, 6435, 6864, 7392, 8064, 8960, 10240, 12288, 16384, 32768),
		horner(n, 5148, 5544, 6048, 6720, 7680, 9216, 12288, 24576),
		horner(n, 4620, 5040, 5600, 6400, 7680, 10240, 20480),
		horner(n, 4410, 4900, 5600, 6720, 8960, 17920),
		horner(n, 4410, 5040, 6048, 8064, 16128),
		horner(n, 4620, 5544, 7392, 14784),
		horner(n, 5148, 6864, 13728),
		horner(n, 6435, 12870),
		12155
	) / 1376256;

	return horner(y, 0., J1, J2, J3, J4, J5, J6, J7, J8, J9, JA);
}

//---------------------------------------------------------------------------
// Universal arctangent function
// atan(sqrt(h) * t) / sqrt(h)
//
double uatan(double t, double h) {
	double	z = -h * t * t;
	double	a = abs(z);

	if (a < 3.3306691e-16)
		return t;
	if (a < 2.3560805e-08)
		return t * horner(z, 1., 1./3);
	if (a < 9.1939631e-06)
		return t * horner(z, 1., 1./3, 1./5);
	if (a < 1.7779240e-04)
		return t * horner(z, 1., 1./3, 1./5, 1./7);
	if (a < 1.0407839e-03)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9);
	if (a < 3.3616998e-03)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11);
	if (a < 7.7408014e-03)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13);
	if (a < 1.4437181e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15);
	if (a < 2.3407312e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15, 1./17);
	if (a < 3.4416203e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15, 1./17, 1./19);

	if (z < 0) {
		double	r	= sqrt(h);
		return atan(r * t) / r;
	}

	if (a < 4.7138547e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15, 1./17, 1./19, 1./21);
	if (a < 6.1227405e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15, 1./17, 1./19, 1./21, 1./23);
	if (a < 7.6353468e-02)
		return t * horner(z, 1., 1./3, 1./5, 1./7, 1./9, 1./11, 1./13, 1./15, 1./17, 1./19, 1./21, 1./23, 1./25);

	double	r	= sqrt(-h);
	double	y	= r * t;
	return log((1 + y) / (1 - y)) * 0.5 / r;
}
#endif

//---------------------------------------------------------------------------
// Carlson symmetric form (of elliptic integrals)
//---------------------------------------------------------------------------

// Rc(x, y) = Rf(x, y, y)
// Carlson's degenerate elliptic integral
// x must be nonnegative and y must be nonzero. If y<0, the Cauchy principal value is returned

inline double _rc_close(double x, double y) {
	double	ave = (x + 2 * y) / 3;
	double	s	= (y - ave) / ave;
	return s * s * horner(s, 3. / 10, 1. / 7, 3. / 8, 9. / 22) * rsqrt(ave);
}

double rc(double x, double y) {
	if (y < 0)
		return rc(x - y, -y) * sqrt(x) / sqrt(x - y);

	static const double ERRTOL = 0.0012;
	double	ave = (x + 2 * y) / 3;
	while (abs(y - ave) > ave * ERRTOL) {
		double	lambda = 2 * sqrt(x) * sqrt(y) + y;
		x	= (x + lambda) / 4;
		y	= (y + lambda) / 4;
		ave	= (x + y + y) / 3;
	}
	return _rc_close(x, y);
}

// Carlson's elliptic integral of the first kind
// x, y, and z must be nonnegative, and at most one can be zero

inline double _rf_close(double x, double y, double z) {
	double	ave = (x + y + z) / 3;
	double	dx	= (ave - x) / ave;
	double	dy	= (ave - y) / ave;
	double	dz	= (ave - z) / ave;

	double	e2	= dx * dy - dz * dz;
	double	e3	= dx * dy * dz;
	return (1 + (-1. / 10 + e2 / 24 - e3 * 3 / 44) * e2 + e3 / 14) * rsqrt(ave);
}

double rf(double x, double y, double z) {
	static const double ERRTOL = 0.0025;

	double	ave = (x + y + z) / 3;
	while (max(max(abs(ave - x), abs(ave - y)), abs(ave - z)) > ave * ERRTOL) {
		double	rx	= sqrt(x);
		double	ry	= sqrt(y);
		double	rz	= sqrt(z);
		double	lambda = rx * (ry + rz) + ry * rz;

		x	= (x + lambda) / 4;
		y	= (y + lambda) / 4;
		z	= (z + lambda) / 4;
		ave	= (x + y + z) / 3;
	}

	return _rf_close(x, y, z);
}

// Carlson's elliptic integral of the second kind
// x and y must be nonnegative, and at most one can be zero. z must be positive

inline double _rd_close(double x, double y, double z) {
	double	ave	= (x + y + 3 * z) / 5;
	double	dx	= (ave - x) / ave;
	double	dy	= (ave - y) / ave;
	double	dz	= (ave - z) / ave;

	double	ea	= dx * dy;
	double	eb	= dz * dz;
	double	ec	= ea - eb;
	double	ed	= ea - 6 * eb;
	double	ee	= ed + 2 * ec;
	return (1
		+ ed * (-3. / 14 + ed * 36 / 22 - dz * ee * 9 / 52)
		//+ dz * (ee / 6 + dz * (ec * -9 / 22 + dz * 3 / 26 * ea))
		+ horner(dz, 0., ee / 6, ec * -9 / 22, 3 / 26 * ea)
	) / ave * rsqrt(ave);
}

double rdf(double x, double y, double z, double &f) {
	static const double ERRTOL = 0.0015;
	double	sum = 0;
	double	fac = 1;
	double	ave	= (x + y + 3 * z) / 5;

	while (max(max(abs(ave - x), abs(ave - y)), abs(ave - z)) > ave * ERRTOL) {
		double	rx = sqrt(x);
		double	ry = sqrt(y);
		double	rz = sqrt(z);
		double	lambda = rx * (ry + rz) + ry * rz;

		sum	+= fac / (rz * (z + lambda));
		fac	/= 4;
		x	= (x + lambda) / 4;
		y	= (y + lambda) / 4;
		z	= (z + lambda) / 4;
		ave	= (x + y + 3 * z) / 5;
	}

	f = _rf_close(x, y, z);
	return 3 * sum + fac * f;
}


// Carlson's elliptic integral of the third kind
// x, y, and z must be nonnegative, and at most one can be zero
// p must be nonzero. If p<0, the Cauchy principal value is returned

inline double _rj_close(double x, double y, double z, double p) {
	double	ave = (x + y + z + p + p) / 5;
	double	dx	= (ave - x) / ave;
	double	dy	= (ave - y) / ave;
	double	dz	= (ave - z) / ave;
	double	dp	= (ave - p) / ave;

	double	ea	= dx * (dy + dz) + dy * dz;
	double	eb	= dx * dy * dz;
	double	ec	= dp * dp;
	double	ed	= ea - 3 * ec;
	double	ee	= eb + 2 * dp * (ea - ec);

	//return (1 + ed * (-3.0 / 14 + ed * 9 / 88 - ee * 9 / 52) + eb * (1.0 / 6 + dp * (-6.0 / 22 + dp * 3 / 26)) + dp * ea * (1.0 / 3 - dp * 3 / 22) - dp * ec / 3) / ave * rsqrt(ave);

	return (1
		+ ed * (-3. / 14 + ed * 9 / 88 - ee * 9 / 52)
		+ eb * horner(dp, 1. / 6, -6. / 22, 3. / 26)
		+ ea * horner(dp, 0., 1. / 3, -3. / 22)
		- dp * ec / 3
		) / ave * rsqrt(ave);
}

double rjf(double x, double y, double z, double p, double &f) {
	if (p < 0) {
		double	x1	= min(min(x, y), z);
		double	z1	= max(max(x, y), z);
		double	y1	= x + y + z - x1 - z1;
		double	a	= 1 / (y1 - p);
		double	b	= a * (z1 - y1) * (y1 - x1);
		double	p1	= y1 + b;

		double	rcx = rc(x1 * z1 / y1, p * p1 / y1);
		double	ans = rjf(x1, y1, z1, p1, f);
		return a * (b * ans + 3 * (rcx - rf(x, y, z)));
	}

	static const double ERRTOL = 0.0015;

	double	sum = 0;
	double	fac = 1;
	double	ave = (x + y + z + p + p) / 5;
	while (max(max(abs(ave - x), abs(ave - y)), max(abs(ave - z), abs(ave - p))) > ave * ERRTOL) {
		double	rx = sqrt(x);
		double	ry = sqrt(y);
		double	rz = sqrt(z);
		double	lambda = rx * (ry + rz) + ry * rz;

		sum	+= fac * rc(square(p * (rx + ry + rz) + rx * ry * rz), p * square(p + lambda));
		fac	/= 4;
		x	= (x + lambda) / 4;
		y	= (y + lambda) / 4;
		z	= (z + lambda) / 4;
		p	= (p + lambda) / 4;
		ave	= (x + y + z + p + p) / 5;
	}

	f = _rf_close(x, y, z);
	return 3 * sum + fac * _rj_close(x, y, z, p);
}

// Legendre elliptic integral of the first kind evaluated using Carlson's function RF
double legendre_F(double phi, double k) {
	double	s, c;
	sincos(phi, &s, &c);
	return s * rf(square(c), 1 - square(s * k), 1);
}
// Legendre elliptic integral of the first kind given k^2
double legendre_F2(double phi, double k2) {
	double	s, c;
	sincos(phi, &s, &c);
	return s * rf(square(c), 1 - square(s) * k2, 1);
}

// Legendre elliptic integral of the second kind evaluated using Carlson's functions RD and RF
double legendre_E(double phi, double k) {
	double	s, c;
	sincos(phi, &s, &c);
	double	t		= square(s * k);
	double	f, d	= rdf(square(c), 1 - t, 1, f);
	return s * (f - t * d / 3);
}
// Legendre elliptic integral of the second kind given k^2
double legendre_E2(double phi, double k2) {
	double	s, c;
	sincos(phi, &s, &c);
	double	t		= square(s) * k2;
	double	f, d	= rdf(square(c), 1 - t, 1, f);
	return s * (f - t * d / 3);
}

// Legendre elliptic integral of the third kind evaluated using Carlson's functions RJ and RF
double legendre_PI(double phi, double en, double k) {
	double	s, c;
	sincos(phi, &s, &c);
	double	enss	= en * square(s);
	double	f, j	= rjf(square(c), 1 - square(s * k), 1, 1 + enss, f);
	return s * (f - enss * j / 3);
}
// Legendre elliptic integral of the third kind given k^2
double legendre_PI2(double phi, double en, double k2) {
	double	s, c;
	sincos(phi, &s, &c);
	double	enss	= en * square(s);
	double	f, j	= rjf(square(c), 1 - square(s) * k2, 1, 1 + enss, f);
	return s * (f - enss * j / 3);
}

//elliptint.h Returns the Jacobian elliptic functions.Here uuDu, while emmcDk2 c.
void jacobians(double u, double emc, double& sn, double& cn, double& dn) {
	if (emc == 0) {
		cn = 1 / cosh(u);
		dn = cn;
		sn = tanh(u);

	} else if (emc < 0) {
		double	d = 1 - emc, rd = sqrt(d);
		jacobians(u * rd, -emc * d, sn, cn, dn);
		double	a = dn;
		dn = cn;
		cn = a;
		sn /= rd;

	} else {
		static const double CA = 1.0e-8;	//The accuracy is the square of CA
		double	em[13], en[13];

		double	a  = 1, c;
		dn = 1;
		int	i = 0;
		while (i < 13) {
			em[i] = a;
			en[i] = (emc = sqrt(emc));
			++i;
			c	  = (a + emc) / 2;
			if (abs(a - emc) <= CA * a)
				break;
			emc *= a;
			a = c;
		}
		u	*= c;
		sn	= sin(u);
		cn	= cos(u);

		if (sn != 0) {
			a = cn / sn;
			c *= a;
			while (i--) {
				double	b = em[i];
				a *= c;
				c *= dn;
				dn = (en[i] + a) / (b + a);
				a  = c / b;
			}
			a  = rsqrt(c * c + 1);
			sn = sn >= 0 ? a : -a;
			cn = c * sn;
		}
	}
}

} //namespace iso