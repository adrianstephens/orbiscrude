#ifndef JAVA_H
#define JAVA_H

#include "base/defs.h"
#include "base/pointer.h"
#include "base/array.h"
#include "base/strings.h"
#include "stream.h"

namespace java {
using namespace iso;

template<typename C> struct index {
	C			idx;
};

template<typename T, typename C> struct table_ref {
	const embedded_array<T, C>	*p;
	typedef const T *iterator, *const_iterator;
	typedef const T	element, &reference;

	size_t		size()	const	{ return p->size(); }
	iterator	begin()	const	{ return p->begin(); }
	iterator	end()	const	{ return p->end(); }

	bool read(byte_reader &r) {
		p = readp(r);
		return true;
	}
};


template<typename T, typename C> struct table_ref<const T*, C> : dynamic_array<const T*> {
	bool read(byte_reader &r) {
		this->resize(r.get<C>());
		for (auto &i : *this)
			i = readp<T>(r);
		return true;
	}
};

typedef packed_types<bigendian_types> java_types;

//-----------------------------------------------------------------------------
//	ENUMS
//-----------------------------------------------------------------------------

enum ACCESS_FLAGS {
	ACC_PUBLIC		= 0x0001,	// Declared public; may be accessed from outside its package.
	ACC_PRIVATE		= 0x0002,	// Declared private; usable only within the defining class.
	ACC_PROTECTED	= 0x0004,	// Declared protected; may be accessed within subclasses.
	ACC_STATIC		= 0x0008,	// Declared static.
	ACC_FINAL		= 0x0010,	// Declared final; never directly assigned to after object construction (JLS §17.5).
	ACC_SUPER		= 0x0020,	// Treat superclass methods specially when invoked by the invokespecial instruction.
	ACC_VOLATILE	= 0x0040,	// Declared volatile; cannot be cached.
	ACC_TRANSIENT	= 0x0080,	// Declared transient; not written or read by a persistent object manager.
	ACC_NATIVE		= 0x0100,	// Declared native; implemented in a language other than Java.
	ACC_INTERFACE	= 0x0200,	// Was an interface in source.
	ACC_ABSTRACT	= 0x0400,	// Marked or implicitly abstract in source.
	ACC_STRICT		= 0x0800,	// Declared strictfp; floating-point mode is FP-strict.
	ACC_SYNTHETIC	= 0x1000,	// Declared synthetic; not present in the source code.
	ACC_ANNOTATION	= 0x2000,	// Declared as an annotation type.
	ACC_ENUM		= 0x4000,	// Declared as an element of an enum.
	//method only
	ACC_SYNCHRONIZED= 0x0020,	// Declared synchronized; invocation is wrapped by a monitor use.
	ACC_BRIDGE		= 0x0040,	// A bridge method, generated by the compiler.
	ACC_VARARGS		= 0x0080,	// Declared with variable number of arguments.
};

enum DESCRIPTOR {
	DESC_BYTE		= 'B',	//signed byte
	DESC_CHAR		= 'C',	//Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16
	DESC_DOUBLE		= 'D',	//double-precision floating-point value
	DESC_FLOAT		= 'F',	//single-precision floating-point value
	DESC_INT		= 'I',	//integer
	DESC_LONG		= 'J',	//long integer
	DESC_REFERENCE	= 'L',	//reference	(followed by '<ClassName>;')
	DESC_SHORT		= 'S',	//signed short
	DESC_BOOLEAN	= 'Z',	//true or false
	DESC_ARRAY		= '[',	//reference	one array dimension
// in annotations:
	DESC_STRING		= 's',	//String
	DESC_ENUM		= 'e',	//enum constant
	DESC_CLASS		= 'c',	//class
	DESC_ANNOTATION	= '@',	//annotation type
};

//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

template<int C> struct ConstantT;

struct Constant {
	enum CONSTANT {
		Utf8				= 1,
		Integer				= 3,
		Float				= 4,
		Long				= 5,
		Double				= 6,
		Class				= 7,
		String				= 8,
		Fieldref			= 9,
		Methodref			= 10,
		InterfaceMethodref	= 11,
		NameAndType			= 12,
		MethodHandle		= 15,
		MethodType			= 16,
		InvokeDynamic		= 18,
	};
	compact<CONSTANT,8>	tag;

	static const Constant *get_ptr(byte_reader &b);
	template<CONSTANT C> const ConstantT<C> &info() const { return *(const ConstantT<C>*)(this + 1); }
};

template<Constant::CONSTANT C> struct ConstantT2 : Constant, ConstantT<C> {};

template<> struct ConstantT<Constant::Class>				{ index<uint16be>	name; };
template<> struct ConstantT<Constant::Fieldref>				{ index<uint16be>	clazz, name_and_type; };
template<> struct ConstantT<Constant::Methodref>			{ index<uint16be>	clazz, name_and_type; };
template<> struct ConstantT<Constant::InterfaceMethodref>	{ index<uint16be>	clazz, name_and_type; };
template<> struct ConstantT<Constant::String>				{ index<uint16be>	string; };
template<> struct ConstantT<Constant::Integer>				{ int32be			v; };
template<> struct ConstantT<Constant::Float>				{ float32be			v; };
template<> struct ConstantT<Constant::Long>					{ int64be			v; };
template<> struct ConstantT<Constant::Double>				{ float64be			v; };
template<> struct ConstantT<Constant::NameAndType>			{ index<uint16be>	name, descriptor; };
template<> struct ConstantT<Constant::Utf8>	{
	uint16be		len;
	count_string	get() const { return str((const char*)(this + 1), len); }
};

template<> struct ConstantT<Constant::MethodHandle> {
	enum {
		//indexes Fieldref
		REF_getField			= 1,
		REF_getStatic			= 2,
		REF_putField			= 3,
		REF_putStatic			= 4,
		//indexes Methodref
		REF_invokeVirtual		= 5,
		REF_invokeStatic		= 6,
		REF_invokeSpecial		= 7,
		REF_newInvokeSpecial	= 8,
		//indexes InterfaceMethodref
		REF_invokeInterface		= 9,
	};
	uint8		reference_kind;
	uint16be	reference;
};
template<> struct ConstantT<Constant::MethodType>			{ index<uint16be>	descriptor; };
template<> struct ConstantT<Constant::InvokeDynamic>		{ index<uint16be>	bootstrap_method_attr, name_and_type; };

template<Constant::CONSTANT C, typename R> bool read(R &r, Constant*& c) {
	ConstantT2<C>	*c2 = new ConstantT2<C>;
	c2->tag	= C;
	c = c2;
	return read(r, *static_cast<ConstantT<C>*>(c2));
}

inline const Constant *Constant::get_ptr(byte_reader &b) {
	const Constant	*p = b.get_ptr();
	int64	size	= 0;
	switch (p->tag) {
		case Constant::Class:				size = sizeof(ConstantT<Constant::Class>			); break;
		case Constant::Fieldref:			size = sizeof(ConstantT<Constant::Fieldref>			); break;
		case Constant::Methodref:			size = sizeof(ConstantT<Constant::Methodref>		); break;
		case Constant::InterfaceMethodref:	size = sizeof(ConstantT<Constant::InterfaceMethodref>); break;
		case Constant::String:				size = sizeof(ConstantT<Constant::String>			); break;
		case Constant::Integer:				size = sizeof(ConstantT<Constant::Integer>			); break;
		case Constant::Float:				size = sizeof(ConstantT<Constant::Float>			); break;
		case Constant::Long:				size = sizeof(ConstantT<Constant::Long>				); break;
		case Constant::Double:				size = sizeof(ConstantT<Constant::Double>			); break;
		case Constant::NameAndType:			size = sizeof(ConstantT<Constant::NameAndType>		); break;
		case Constant::Utf8:				size = b.get<uint16be>(); break;
		case Constant::MethodHandle:		size = sizeof(ConstantT<Constant::MethodHandle>		); break;
		case Constant::MethodType:			size = sizeof(ConstantT<Constant::MethodType>		); break;
		case Constant::InvokeDynamic:		size = sizeof(ConstantT<Constant::InvokeDynamic>	); break;
		default:							size = -1; break;
	}
	b.skip(size);
	return p;
}


//-----------------------------------------------------------------------------
//	Annotation
//-----------------------------------------------------------------------------

struct ElementValue : java_types {
	uint8			tag;	//DESCRIPTOR
};
struct ElementValueIndex : ElementValue {//when tag is B, C, D, F, I, J, S, Z, s, or c.
	index<uint16>	i;
};

struct ElementValueEnum : ElementValue {//when tag is e
	index<uint16>	type_name;
	index<uint16>	const_name;
};

struct ElementValueArray : ElementValue {//when tag is [
	uint16			num_values;
	ElementValue	values[];//num_values];
};

struct Annotation : java_types {
	struct ElementValuePair {
		uint16			element_name;
		ElementValue	value;
	};

	uint16							type;
	embedded_array<ElementValuePair, uint16>	element_value_pairs;
};

struct ElementValueAnnotation : ElementValue {//when tag is @
	Annotation		anno;
};

//-----------------------------------------------------------------------------
//	Attributes
//-----------------------------------------------------------------------------

/*
predefined attributes
ConstantValue							1.0.2	45.3
Code									1.0.2	45.3
StackMapTable							6		50.0
Exceptions								1.0.2	45.3
InnerClasses							1.1		45.3
EnclosingMethod							5.0		49.0
Synthetic								1.1		45.3
Signature								5.0		49.0
SourceFile								1.0.2	45.3
SourceDebugExtension					5.0		49.0
LineNumberTable							1.0.2	45.3
LocalVariableTable						1.0.2	45.3
LocalVariableTypeTable					5.0		49.0
Deprecated								1.1		45.3
RuntimeVisibleAnnotations				5.0		49.0
RuntimeInvisibleAnnotations				5.0		49.0
RuntimeVisibleParameterAnnotations		5.0		49.0
RuntimeInvisibleParameterAnnotations	5.0		49.0
AnnotationDefault						5.0		49.0
BootstrapMethods						7		51.0
*/
struct Attribute : java_types {
	index<uint16>	name;
	uint32			length;

	const Attribute *next() const { return (const Attribute*)((uint8*)(this + 1) + length); }

	static const Attribute *get_ptr(byte_reader &r) {
		const Attribute	*p = r.get_ptr();
		r.skip(p->length);
		return p;
	}
};

struct AttributePtr : holder<Attribute*> {
	template<typename R> bool read(R &r) {
		Attribute	a = r.template get<Attribute>();
		t	= (Attribute*)iso::malloc(sizeof(Attribute) + a.length);
		*t	= a;
		r.readbuff(t + 1, a.length);
		return true;
	}
};

struct ConstantValue : Attribute {
	index<uint16>	constantvalue;
};

struct Code : Attribute	{
	struct Exception {
		uint16	start_pc;
		uint16	end_pc;
		uint16	handler_pc;
		uint16	catch_type;
	};

	uint16								max_stack;
	uint16								max_locals;
	union {
	embedded_array<uint8,uint32>					code;
	after<embedded_array<Exception,uint16>, embedded_array<uint8,uint32> > exception_table;
	after<embedded_next_array<const Attribute,uint16>,after<embedded_array<Exception,uint16>, embedded_array<uint8,uint32> > >	attributes;
	};
};

struct StackMapTable : Attribute {
	struct VerificationItem {
		enum {
			VI_Top					= 0,
			VI_Integer				= 1,
			VI_Float				= 2,
			VI_Long					= 4,
			VI_Double				= 3,
			VI_Null					= 5,
			VI_UninitializedThis	= 6,
			VI_Object				= 7,
			VI_Uninitialized		= 8,
		};
		uint8	tag;
	};
	struct ObjectVerificationItem : VerificationItem {
		index<uint16>	cpool;
	};
	struct UninitializedVerificationItem : VerificationItem	{
		uint16	offset;
	};

	struct Frame {
		enum {
			SAME								= 0,	// 0-63
			SAME_LOCALS_1_STACK_ITEM			= 64,	// 64-127
			SAME_LOCALS_1_STACK_ITEM_EXTENDED	= 247,	// 247
			CHOP								= 248,	// 248-250
			SAME_FRAME_EXTENDED					= 251,	// 251
			APPEND								= 252,	// 252-254
			FULL_FRAME							= 255,	// 255
		};
		uint8	type;
	};

	struct same_frame : Frame {
	};
	struct same_locals_1_stack_item_frame : Frame {
		VerificationItem	stack[1];
	};
	struct same_locals_1_stack_item_frame_extended : Frame {
		uint16	offset_delta;
		VerificationItem	stack[1];
	};
	struct chop_frame : Frame {
		uint16	offset_delta;
	};
	struct same_frame_extended : Frame {
		uint16	offset_delta;
	};
	struct append_frame : Frame {
		uint16	offset_delta;
		VerificationItem	locals[];	//type - SAME_FRAME_EXTENDED;
	};
	struct full_frame : Frame {
		uint16				offset_delta;
		embedded_next_array<const VerificationItem,uint16>	locals;
		embedded_next_array<const VerificationItem,uint16>	stack;
	};

	embedded_array<Frame,uint16>	entries;
};

struct Exceptions : Attribute {
	embedded_array<uint16,uint16>	exception_index_table;
};
struct InnerClasses : Attribute	{
	struct Class {
		index<uint16>	inner_class_info;
		index<uint16>	outer_class_info;
		index<uint16>	inner_name;
		uint16	inner_class_access_flags;
	};
	embedded_array<Class,uint16>	classes;
};
struct EnclosingMethod : Attribute {
	index<uint16>	clazz;
	index<uint16>	method;
};
struct Synthetic : Attribute {
};
struct Signature : Attribute {
	index<uint16>	signature;
};
struct SourceFile : Attribute {
	index<uint16>	sourcefile;
};
struct SourceDebugExtension : Attribute {
//	uint8	debug_extension[];
};
struct LineNumberTable : Attribute	{
	struct Record {
		uint16	start_pc;
		uint16	line_number;
	};
	embedded_array<Record,uint16> line_number_table;
};
struct LocalVariableTable : Attribute {
	struct Record {
		uint16	start_pc;
		uint16	length;
		index<uint16>	name;
		index<uint16>	descriptor;
		uint16	index;
	};
	embedded_array<Record,uint16> local_variable_table;
};
struct LocalVariableTypeTable : Attribute {
	struct Record {
		uint16	start_pc;
		uint16	length;
		index<uint16>	name;
		index<uint16>	signature;
		uint16	index;
	};
	embedded_array<Record,uint16> local_variable_type_table;
};
struct Deprecated : Attribute {
};

struct RuntimeVisibleAnnotations : Attribute {
	embedded_next_array<const Annotation, uint16>	annotations;
};
struct RuntimeInvisibleAnnotations : Attribute	{
	embedded_next_array<const Annotation, uint16>	annotations;
};
struct RuntimeVisibleParameterAnnotations : Attribute	{
	embedded_next_array<const embedded_next_array<const Annotation, uint16>,uint8> parameter_annotations;
};
struct RuntimeInvisibleParameterAnnotations : Attribute	{
	embedded_next_array<const embedded_next_array<const Annotation, uint16>,uint8> parameter_annotations;
};
struct AnnotationDefault : Attribute {
	ElementValue	default_value;
};
struct BootstrapMethods : Attribute	{
	struct Record {
		uint16	bootstrap_method_ref;
		embedded_array<uint16,uint16>	bootstrap_arguments;
		const Record*	next() const	{ return (const Record*)bootstrap_arguments.end(); }
	};
	embedded_next_array<const Record, uint16>	bootstrap_methods;
};

//-----------------------------------------------------------------------------
//	Header
//-----------------------------------------------------------------------------

struct ClassHeader {
	enum	{MAGIC = 0xCAFEBABE};
	uint32be	magic;
	uint16be	minor_version;
	uint16be	major_version;

	bool	valid() const {
		return magic == MAGIC;
	}
};

struct ClassInfo {
	uint16be		access_flags;
	index<uint16be>	this_class;
	index<uint16be>	super_class;
};

struct FieldorMethod {
	uint16be		access_flags;
	index<uint16be>	name;
	index<uint16be>	descriptor;
	embedded_next_array<const Attribute,uint16be> attributes;

	static const FieldorMethod *get_ptr(byte_reader &r) {
		const FieldorMethod	*p = r.get_ptr();
		readp<Attribute>(r, p->attributes.size());
		return p;
	}
};

struct ClassFile {
	ClassHeader *header;

	dynamic_array<const Constant*>				_constants;
	const ClassInfo								*_info;
	table_ref<uint16be,uint16be>				_interfaces;
	table_ref<const FieldorMethod*,uint16be>	_fields;
	table_ref<const FieldorMethod*,uint16be>	_methods;
	table_ref<const Attribute*,uint16be>		_attributes;

	ClassFile(ClassHeader *_header) : header(_header) {
		byte_reader	r(header + 1);

		uint32	n = r.get<uint16be>();
		_constants.resize(n);
		for (int i = 1; i < n; i++) {
			_constants[i] = readp<Constant>(r);
			if (_constants[i]->tag == Constant::Long || _constants[i]->tag == Constant::Double)
				++i;
		}

		read(r, _info, _interfaces, _fields, _methods, _attributes);
	}

	const Constant	*get_constant(int i) const {
		return i < _constants.size() ? _constants[i] : 0;
	}
	template<Constant::CONSTANT C> const ConstantT<C>	*get_constant(int i) const {
		auto	*c = get_constant(i);
		return c && c->tag == C ? &c->info<C>() : 0;
	}
};

//-----------------------------------------------------------------------------
//	byte code
//-----------------------------------------------------------------------------

enum OPCODE {
	op_nop				= 0x00,
	op_aconst_null		= 0x01,
	op_iconst_m1		= 0x02,
	op_iconst_0			= 0x03,
	op_iconst_1			= 0x04,
	op_iconst_2			= 0x05,
	op_iconst_3			= 0x06,
	op_iconst_4			= 0x07,
	op_iconst_5			= 0x08,
	op_lconst_0			= 0x09,
	op_lconst_1			= 0x0a,
	op_fconst_0			= 0x0b,
	op_fconst_1			= 0x0c,
	op_fconst_2			= 0x0d,
	op_dconst_0			= 0x0e,
	op_dconst_1			= 0x0f,
	op_bipush			= 0x10,
	op_sipush			= 0x11,
	op_ldc				= 0x12,
	op_ldc_w			= 0x13,
	op_ldc2_w			= 0x14,

	op_iload			= 0x15,
	op_lload			= 0x16,
	op_fload			= 0x17,
	op_dload			= 0x18,
	op_aload			= 0x19,
	op_iload_0			= 0x1a,
	op_iload_1			= 0x1b,
	op_iload_2			= 0x1c,
	op_iload_3			= 0x1d,
	op_lload_0			= 0x1e,
	op_lload_1			= 0x1f,
	op_lload_2			= 0x20,
	op_lload_3			= 0x21,
	op_fload_0			= 0x22,
	op_fload_1			= 0x23,
	op_fload_2			= 0x24,
	op_fload_3			= 0x25,
	op_dload_0			= 0x26,
	op_dload_1			= 0x27,
	op_dload_2			= 0x28,
	op_dload_3			= 0x29,
	op_aload_0			= 0x2a,
	op_aload_1			= 0x2b,
	op_aload_2			= 0x2c,
	op_aload_3			= 0x2d,
	op_iaload			= 0x2e,
	op_laload			= 0x2f,
	op_faload			= 0x30,
	op_daload			= 0x31,
	op_aaload			= 0x32,
	op_baload			= 0x33,
	op_caload			= 0x34,
	op_saload			= 0x35,

	op_istore			= 0x36,
	op_lstore			= 0x37,
	op_fstore			= 0x38,
	op_dstore			= 0x39,
	op_astore			= 0x3a,
	op_istore_0			= 0x3b,
	op_istore_1			= 0x3c,
	op_istore_2			= 0x3d,
	op_istore_3			= 0x3e,
	op_lstore_0			= 0x3f,
	op_lstore_1			= 0x40,
	op_lstore_2			= 0x41,
	op_lstore_3			= 0x42,
	op_fstore_0			= 0x43,
	op_fstore_1			= 0x44,
	op_fstore_2			= 0x45,
	op_fstore_3			= 0x46,
	op_dstore_0			= 0x47,
	op_dstore_1			= 0x48,
	op_dstore_2			= 0x49,
	op_dstore_3			= 0x4a,
	op_astore_0			= 0x4b,
	op_astore_1			= 0x4c,
	op_astore_2			= 0x4d,
	op_astore_3			= 0x4e,
	op_iastore			= 0x4f,
	op_lastore			= 0x50,
	op_fastore			= 0x51,
	op_dastore			= 0x52,
	op_aastore			= 0x53,
	op_bastore			= 0x54,
	op_castore			= 0x55,
	op_sastore			= 0x56,

	op_pop				= 0x57,
	op_pop2				= 0x58,
	op_dup				= 0x59,
	op_dup_x1			= 0x5a,
	op_dup_x2			= 0x5b,
	op_dup2				= 0x5c,
	op_dup2_x1			= 0x5d,
	op_dup2_x2			= 0x5e,
	op_swap				= 0x5f,

	op_iadd				= 0x60,
	op_ladd				= 0x61,
	op_fadd				= 0x62,
	op_dadd				= 0x63,
	op_isub				= 0x64,
	op_lsub				= 0x65,
	op_fsub				= 0x66,
	op_dsub				= 0x67,
	op_imul				= 0x68,
	op_lmul				= 0x69,
	op_fmul				= 0x6a,
	op_dmul				= 0x6b,
	op_idiv				= 0x6c,
	op_ldiv				= 0x6d,
	op_fdiv				= 0x6e,
	op_ddiv				= 0x6f,
	op_irem				= 0x70,
	op_lrem				= 0x71,
	op_frem				= 0x72,
	op_drem				= 0x73,
	op_ineg				= 0x74,
	op_lneg				= 0x75,
	op_fneg				= 0x76,
	op_dneg				= 0x77,
	op_ishl				= 0x78,
	op_lshl				= 0x79,
	op_ishr				= 0x7a,
	op_lshr				= 0x7b,
	op_iushr			= 0x7c,
	op_lushr			= 0x7d,
	op_iand				= 0x7e,
	op_land				= 0x7f,
	op_ior				= 0x80,
	op_lor				= 0x81,
	op_ixor				= 0x82,
	op_lxor				= 0x83,
	op_iinc				= 0x84,

	op_i2l				= 0x85,
	op_i2f				= 0x86,
	op_i2d				= 0x87,
	op_l2i				= 0x88,
	op_l2f				= 0x89,
	op_l2d				= 0x8a,
	op_f2i				= 0x8b,
	op_f2l				= 0x8c,
	op_f2d				= 0x8d,
	op_d2i				= 0x8e,
	op_d2l				= 0x8f,
	op_d2f				= 0x90,
	op_i2b				= 0x91,
	op_i2c				= 0x92,
	op_i2s				= 0x93,

	op_lcmp				= 0x94,
	op_fcmpl			= 0x95,
	op_fcmpg			= 0x96,
	op_dcmpl			= 0x97,
	op_dcmpg			= 0x98,
	op_ifeq				= 0x99,
	op_ifne				= 0x9a,
	op_iflt				= 0x9b,
	op_ifge				= 0x9c,
	op_ifgt				= 0x9d,
	op_ifle				= 0x9e,
	op_if_icmpeq		= 0x9f,
	op_if_icmpne		= 0xa0,
	op_if_icmplt		= 0xa1,
	op_if_icmpge		= 0xa2,
	op_if_icmpgt		= 0xa3,
	op_if_icmple		= 0xa4,
	op_if_acmpeq		= 0xa5,
	op_if_acmpne		= 0xa6,

	op_goto				= 0xa7,
	op_jsr				= 0xa8,
	op_ret				= 0xa9,
	op_tableswitch		= 0xaa,
	op_lookupswitch		= 0xab,
	op_ireturn			= 0xac,
	op_lreturn			= 0xad,
	op_freturn			= 0xae,
	op_dreturn			= 0xaf,
	op_areturn			= 0xb0,
	op_return			= 0xb1,

	op_getstatic		= 0xb2,
	op_putstatic		= 0xb3,
	op_getfield			= 0xb4,
	op_putfield			= 0xb5,
	op_invokevirtual	= 0xb6,
	op_invokespecial	= 0xb7,
	op_invokestatic		= 0xb8,
	op_invokeinterface	= 0xb9,
	op_invokedynamic	= 0xba,
	op_new				= 0xbb,
	op_newarray			= 0xbc,
	op_anewarray		= 0xbd,
	op_arraylength		= 0xbe,
	op_athrow			= 0xbf,
	op_checkcast		= 0xc0,
	op_instanceof		= 0xc1,
	op_monitorenter		= 0xc2,
	op_monitorexit		= 0xc3,

	op_wide				= 0xc4,
	op_multianewarray	= 0xc5,
	op_ifnull			= 0xc6,
	op_ifnonnull		= 0xc7,
	op_goto_w			= 0xc8,
	op_jsr_w			= 0xc9,

	op_breakpoint		= 0xca,
	op_impdep1			= 0xfe,
	op_impdep2			= 0xff,
};

enum PARAMS {
	NONE				= 0x00,
	INDEX				= 0x01,
	INDEX2				= 0x02,
	CONSTANT			= 0x11,
	CONSTANT2			= 0x12,
	BRANCH2				= 0x22,
	BRANCH4				= 0x24,
	TYPE				= 0x31,
	INDEX_CONST			= 0x42,
	INDEX2_DIMS			= 0x43,
	INDEX2_0_0			= 0x44,
	INDEX2_COUNT_0		= 0x54,
	WIDE				= 0x60,
	TABLESWITCH			= 0x61,
	LOOKUPSWITCH		= 0x62,
};

struct OPCODE_INFO {
	const char *op;
	PARAMS params;
};

const OPCODE_INFO &get_info(OPCODE op);
uint32 get_len(PARAMS params);
uint32 get_len(const uint8 *p);

struct TableSwitch {
	int32be	def;
	int32be	low;
	int32be	high;
	int32be	offsets[];

	const uint8	*end() const	{ return (const uint8*)&offsets[high - low + 1]; }
};
struct LookupSwitch {
	int32be		def;
	uint32be	count;
	struct {
		int32be	val;
		int32be	offset;
	} pairs[];

	const uint8	*end() const	{ return (const uint8*)&pairs[count]; }
};


} // namespace java

#endif	//JAVA_H

