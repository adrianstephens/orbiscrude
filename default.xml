<?xml version="1.0" encoding="utf-8"?>
<sdb xmlns="http://sce/sdb" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" binFileName="D:\dev\shared\common\default.fx" workingDirectory="D:\dev\shared\isoview">
    <guid bin="0xdbc6ee40" src="0x62fa9b10"/>
    <compilerVersion name="Orbis Shader Compiler (shared library version)" major="2" minor="5" build="8747" version="2.5 build 8747"/>
    <commandLineArgs/>
    <compileOptions>
        <option name="mainfilename" value="D:\dev\shared\common\default.fx"/>
        <option name="entryfunction" value="VS_thickpoint"/>
        <option name="profile" value="sce_vs_es_orbis"/>
        <option name="cgfx" value="true"/>
        <option name="nostdlib" value="false"/>
        <option name="optimizationlevel" value="3"/>
        <option name="raStrategy" value="default"/>
        <option name="fastmath" value="true"/>
        <option name="fastprecision" value="false"/>
        <option name="fastint" value="true"/>
        <option name="packing-parameter" value="false"/>
        <option name="allow-scratch-buffer-spill" value="false"/>
        <option name="force-max-shader-vgpr-count" value="false"/>
        <option name="wave-count-first" value="false"/>
        <option name="disable-default-packing" value="false"/>
        <option name="global-cb-strip" value="true"/>
        <option name="indirect-draw" value="false"/>
        <option name="enable-dx10-clamp" value="false"/>
        <option name="enable-ieee" value="false"/>
        <option name="max-user-sgpr-count" value="16"/>
        <option name="max-user-extdata-count" value="48"/>
        <option name="ttrace" value="0"/>
        <option name="avoid-lds-bank-conflict" value="false"/>
        <option name="max-shader-vgpr-count" value="256"/>
        <option name="max-shader-sgpr-count" value="102"/>
        <option name="preferred-vgpr-count" value="0"/>
        <option name="sc-min-reg-sched-heuristic" value="false"/>
        <option name="debug" value="false"/>
        <option name="mrtformat" value="0x44444444"/>
        <option name="warningsaserrors" value="false"/>
        <option name="performancewarnings" value="false"/>
        <option name="pedantic" value="false"/>
        <option name="pedantic-error" value="false"/>
        <option name="preprocessonly" value="false"/>
        <option name="preprocessnolinenumbers" value="false"/>
        <option name="preprocesskeepcomments" value="false"/>
        <option name="emitdependencies" value="false"/>
        <option name="dependencywritephonies" value="false"/>
        <option name="cache-gen-source-hash" value="true"/>
        <option name="cache-user-source-hash" value="0"/>
        <option name="disable-temp-array-replace" value="false"/>
        <option name="enforce-temp-array-replace" value="false"/>
        <option name="disable-literal-buffer" value="false"/>
        <option name="do-not-unroll" value="false"/>
        <option name="disable-store-coalesce-boundary-check-workaround" value="false"/>
        <option name="write-constant-block" value="false"/>
        <option name="printshaderperformancestats" value="false"/>
        <option name="searchpath" value="D:\dev\shared\assets\shaders/"/>
        <option name="define" value="PLAT_PS4"/>
        <option name="dependencytargetname" value=""/>
    </compileOptions>
    <allFiles>
        <file userSpecifiedFileName="D:\dev\shared\common\default.fx" absoluteFileName="D:\dev\shared\common\default.fx" fileID="2" primary="1">
            <fileInfo creationTime="2014-12-13T02:42:50Z" modificationTime="2015-06-24T05:23:30Z"/>
            <fileSource>
                <![CDATA[#include "common.fxh"
#include "lighting.fxh"
#include "shadow.fxh"

sampler_def2D(diffuse_samp, FILTER_MIN_MAG_MIP_LINEAR;);
sampler_def2D(diffuse_samp2,FILTER_MIN_MAG_MIP_LINEAR;);

sampler_def2D(linear_samp,
	FILTER_MIN_MAG_MIP_LINEAR;
	ADDRESSU = CLAMP;
	ADDRESSV = CLAMP;
);

sampler_def2D(linear_samp2,
	FILTER_MIN_MAG_MIP_LINEAR;
	ADDRESSU = CLAMP;
	ADDRESSV = CLAMP;
);

sampler_defCUBE(sky_samp,
	FILTER_MIN_MAG_MIP_LINEAR;
#ifdef PLAT_WII
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
#else
	ADDRESSU = CLAMP;
	ADDRESSV = CLAMP;
#endif
);

//------------------------------------

float			glossiness		= 60;
float4			diffuse_colour	= {1,1,1,1};
float			flip_normals	= 1;
float4			matrices[64];

//------------------------------------

struct S_Background {
	float4	pos		: POSITION_OUT;
	float2	uv		: TEXCOORD0;
};

struct S_World {
	float4	pos		: POSITION_OUT;
	float4	world	: TEXCOORD0;
};

struct S_TransformCol {
	float4	pos		: POSITION_OUT;
	float4	colour	: COLOR;
};

struct S_TransformTex {
	float4	pos		: POSITION_OUT;
	float2	uv		: TEXCOORD0;
};

struct S_TransformColTex {
	float4	pos		: POSITION_OUT;
	float2	uv		: TEXCOORD0;
	float4	colour	: COLOR;
};

struct S_TransformColTex2 {
	float4	pos		: POSITION_OUT;
	float4	uv01	: TEXCOORD0;
	float4	colour	: COLOR;
};

struct S_Lighting {
	float4	position: POSITION_OUT;
	float4	ambient	: AMBIENT;
	float3	normal	: TEXCOORD1;
	float3	worldpos: TEXCOORD3;
	fogtype	fog		: FOG;
	SHADOW_VO
};
//------------------------------------

S_Background VS_PassThrough(float2 position:POSITION, in float2 uv:TEXCOORD0) {
	S_Background	v;
	v.uv	= uv;
	v.pos	= platform_fix(float3(position, 0));
	return v;
}

S_World VS_ScreenToWorld(float3 position:POSITION) {
	S_World	v;
	v.pos	= platform_fix(position);
	v.world	= mul(cofactors(worldViewProj), v.pos);
//	v.world	= mul(inverse_transpose(worldViewProj), float4(position, 1));
//	v.world	= float4(position, 1);
	return v;
}

S_World VS_ShowWorld(float3 position : POSITION) {
	S_World	v;
	v.pos	= mul(float4(position, 1.0), worldViewProj);
	v.world	= mul(inverse_transpose(worldViewProj), v.pos);
//	v.world	= float4(position, 1);
	return v;
}

float4 VS_Trivial3D(float3 position:POSITION) : POSITION_OUT {
	return mul(float4(position, 1.0), worldViewProj);
}

#ifdef PLAT_WII
float4 VS_Background(float3 position:POSITION, inout float2 uv:TEXCOORD0) : POSITION_OUT {
	return mul(float4(position, 1.0), worldViewProj);
}
#else
S_Background VS_Background(float2 position:POSITION_IN) {
	S_Background	v;
	v.uv		= position;
	v.pos		= float4(position, far_depth, 1);
	return v;
}
#endif

S_TransformCol VS_Transform(float3 position:POSITION) {
	S_TransformCol	v;
	v.colour	= diffuse_colour;
	v.pos		= mul(float4(position, 1), worldViewProj);
	return v;
}

S_TransformCol VS_Transform4(float4 position:POSITION) {
	S_TransformCol	v;
	v.colour	= diffuse_colour;
	v.pos		= mul(position, worldViewProj);
	return v;
}

S_TransformCol VS_Transform_idx(float3 position:POSITION, int4 idx:BLENDINDICES) {
	S_TransformCol	v;
	float4x4	iworld;
	iworld[0]	= matrices[idx.x + 0];
	iworld[1]	= matrices[idx.x + 1];
	iworld[2]	= matrices[idx.x + 2];
	iworld[3]	= float4(0,0,0,1);
	iworld		= mul(transpose(iworld), worldViewProj);
	v.colour	= diffuse_colour;
	v.pos		= mul(float4(position, 1), iworld);
	return v;
}

S_TransformCol VS_TransformColour(float3 position:POSITION, float4 colour:COLOR) {
	S_TransformCol	v;
	v.colour	= colour;
	v.pos		= mul(float4(position, 1), worldViewProj);
	return v;
}

S_TransformColTex VS_TransformTex(float3 position:POSITION, float2 uv:TEXCOORD0) {
	S_TransformColTex	v;
	v.uv		= uv;
	v.colour	= diffuse_colour;
	v.pos		= mul(float4(position, 1), worldViewProj);
	return v;
}

S_TransformColTex VS_TransformColourTex(float3 position:POSITION, float2 uv:TEXCOORD0, float4 colour:COLOR) {
	S_TransformColTex	v;
	v.uv		= uv;
	v.colour	= colour;
	v.pos		= mul(float4(position, 1), worldViewProj);
	return v;
}

S_TransformColTex2 VS_TransformColourTex2(float3 position:POSITION, float2 uv0:TEXCOORD0, float2 uv1:TEXCOORD1, float4 colour:COLOR) {
	S_TransformColTex2	v;
	v.uv01		= float4(uv0, uv1);
	v.colour	= colour;
	v.pos		= mul(float4(position, 1), worldViewProj);
	return v;
}

S_Lighting VS_TransformLighting(float3 position:POSITION, float3 normal:NORMAL) {
	S_Lighting	v;

	float3x3 it_world = inverse_transpose((float3x3)world);

	float3	pos		= mul(float4(position, 1.0),	(float4x3)world);
	float3	norm	= normalise(mul(normal,			it_world)) * flip_normals;
	v.position		= mul(float4(pos, 1.0), 		ViewProj());
	v.normal		= norm;
	v.worldpos		= pos;
	v.ambient		= light_ambient;//DiffuseLight(pos, norm);
	v.fog			= VSFog(pos);
	SHADOW_VS(v,pos)
	return v;
}
S_Lighting VS_TransformLighting4(float4 position:POSITION, float3 normal:NORMAL) {
	S_Lighting	v;

	float4x4 it_world = inverse_transpose((float4x4)world);

	float4	pos		= mul(position,			world);
	float3	pos3	= pos.xyz / pos.w;
	float3	norm	= (normalise(mul(float4(normal, 0),	it_world)) * flip_normals).xyz;
	v.position		= mul(position, worldViewProj);
//	v.position		= mul(pos,				ViewProj());
	v.normal		= norm;
	v.worldpos		= pos3;
	v.ambient		= light_ambient;//DiffuseLight(pos3, norm);
	v.fog			= VSFog(pos3);
	SHADOW_VS(v,pos3)
	return v;
}
//-----------------------------------------------------------------------------
//	pixel shaders
//-----------------------------------------------------------------------------

float4 PS_Background(S_Background v) : OUTPUT0 {
#ifdef PLAT_WII
	return tex2D(sky_samp, uv);
#else
	return float4(texCUBE(sky_samp, mul(float4(v.uv, near_depth, 1), worldViewProj).xzy).rgb, 1);
#endif
}

float4 PS_Black() : OUTPUT0 {
	return 0;
}
float4 PS_White() : OUTPUT0 {
	return 1;
}
float4 PS_Col(S_TransformCol v): OUTPUT0 {
	return v.colour;
}
float4 PS_Tex(S_TransformColTex v) : OUTPUT0 {
	return float4(tex2D(diffuse_samp, v.uv).rgb, 1);
}
float4 PS_TexCol(S_TransformColTex v) : OUTPUT0 {
	return tex2D(diffuse_samp, v.uv) * v.colour;
}

float4 PS_Blend(S_TransformCol v) : OUTPUT0 {
	return Blend(v.colour);
}

float4 PS_Add(S_TransformCol v) : OUTPUT0 {
	return Add(v.colour);
}

float4 PS_TexBlend(S_TransformColTex v) : OUTPUT0 {
	return Blend(tex2D(diffuse_samp, v.uv) * v.colour);
}

#ifdef PLAT_WII
float4 PS_TexBlendMask(float2 uv0:TEXCOORD0, float2 uv1:TEXCOORD1, float4 colour:COLOR) : OUTPUT0 {
	float4	t0 = tex2D(linear_samp, uv0);
	float4	t1 = tex2D(linear_samp2, uv1);
	return Blend(float4(t0.rgb, t0.a * t1.r) * colour);
}
#else
float4 PS_TexBlendMask(S_TransformColTex2 v) : OUTPUT0 {
	float4	t0 = tex2D(linear_samp, v.uv01.xy);
	float4	t1 = tex2D(linear_samp2, v.uv01.zw);
	return Blend(float4(t0.rgb, t0.a * t1.r) * v.colour);
}
#endif

float4 PS_TexAdd(S_TransformColTex v) : OUTPUT0 {
	return Add(tex2D(diffuse_samp, v.uv) * v.colour);
}

float4 PS_Blend2(float2 uv:TEXCOORD0) : COLOR {
	float4 c1 = tex2D(diffuse_samp, uv);
	float4 c2 = tex2D(diffuse_samp2, uv);
	return float4(c1.rgb * (1 - c2.a) + c2.rgb, 1);
}

#ifdef PLAT_WII
float4 PS_TexDistMask(in float2 uv0:TEXCOORD0, in float2 uv1:TEXCOORD1, in float4 colour:COLOR) : OUTPUT0 {
	float4	t = tex2D(linear_samp, uv0);
	return Blend(float4(t.rgb, 1) * colour) * Distance0(0.5, t.a) * tex2D(linear_samp2, uv1).r;
}
#else
float4 PS_TexDistMask(S_TransformColTex2 v) : OUTPUT0 {
	float4	t = tex2D(linear_samp, v.uv01.xy);
	return Distance1(Blend(float4(t.rgb, tex2D(linear_samp2, v.uv01.zw).r) * v.colour), 0.5, t.a, max(abs(ddx(v.uv01.x)), abs(ddx(v.uv01.y))) * 16);
}
#endif

float4 PS_Specular(S_Lighting v) : OUTPUT0 {
	return FogSpecularLight(
		v.worldpos.xyz,
		normalise(v.normal),
		diffuse_colour,
		v.ambient,
		glossiness,
		1,
		GETSHADOW(v),
		v.fog
	);
}

#if defined(PLAT_PC) && !defined(USE_DX11)
float4 PS_DepthMin(float2 uv:TEXCOORD0) : OUTPUT0 {
	float	v0 = PointSample(_zbuffer, uv, float2(-.5, -.5)).x;
	float	v1 = PointSample(_zbuffer, uv, float2(+.5, -.5)).x;
	float	v2 = PointSample(_zbuffer, uv, float2(-.5, +.5)).x;
	float	v3 = PointSample(_zbuffer, uv, float2(+.5, +.5)).x;
	return min(min(v0, v1), min(v2, v3));
}

float3 RayIntersectMip(sampler2D s, float3 p, float3 v)
{
	const int mips = 10;

	for (int i = mips; i--;)	{
		v *= 0.5;
		if (p.z < tex2Dlod(s, float4(p.xy,0,i)).x)
			p += v;
	}

	return p;
}

float3 RayIntersect(sampler2D s, float3 p0, float3 p1)
{
	const int num_steps_lin = 10;
	const int num_steps_bin = 5;

	float3	p = p0;
	float3	v = (p1 - p0) / (p1 - p0).z * num_steps_lin;
	//v.xz = -v.xz;

	int i;
	for (i = 0; i < num_steps_lin; i++)	{
		if (p.z < tex2D(s, p.xy).x)
			p += v;
	}

	for (i = 0; i < num_steps_bin; i++) {
		v *= 0.5;
		if (p.z < tex2D(s, p.xy).x)
			p += v;
		else
			p -= v;
	}
	return p;
}

float4 PS_DepthRay(float4 world:TEXCOORD0) : OUTPUT0 {

	float4	o	= mul(cofactors(worldViewProj), platform_fix(float3(0, 0, -1)));
//	float4	o	= mul(cofactors(worldViewProj), float4(0, 0, 0, 2));
	float4	d	= world - o;
	float	t0	= world.z / d.z;
	float	t1	= (world.w - world.z) / (d.w - d.z);

	float3	p0	= project(lerp(o, world, 1 - t0));
	float3	p1	= project(lerp(o, world, 1 - t1));

#if 0
	p0 = p0 * float3(0.5, -0.5, 1) + float3(0.5, 0.5, 0);
	p1 = p1 * float3(0.5, -0.5, 1) + float3(0.5, 0.5, 0);

	if (any(min(p0.xy, p1.xy) > 1) || any(max(p0.xy, p1.xy) < 0) || p1.z < p0.z)
		clip(-1);

	float3	p	= RayIntersect(linear_samp, p0, p1);
//	float3	p	= RayIntersectMip(linear_samp, o + k0 * d, (k1 - k0) * d);
#else
	float3	p	= p1 * float3(0.5, -0.5, 1) + float3(0.5, 0.5, 0);
#endif
	float2	t	= abs(p.xy - 0.5);
	clip(0.5 - max(t.x, t.y));

	return float4(tex2D(linear_samp, p.xy).rgb, 1);

//	float3	p	= o + k * d;
//	return float4(p.xyz, 1);

//	return world / world.w;
/*	float3	d = v.worldpos.xyz - iview[3].xyz;
	float3	p = float3(uv, 1);

	p = RayIntersect(p, d);

	return float4(tex2D(diffuse_samp, p.xy).rgb, 1);
	*/
}
#endif

//-----------------------------------

technique background {
	PASS(p0,VS_Background,PS_Background)
}

technique coloured {
	PASS(p0,VS_Transform,PS_Col)
}

technique blend {
	PASS(p0,VS_Transform,PS_Blend)
}

technique blend4 {
	PASS(p0,VS_Transform4,PS_Blend)
}

technique blend_vc {
	PASS(p0,VS_TransformColour,PS_Blend)
}

technique add {
	PASS(p0,VS_Transform,PS_Add)
}

technique add_vc {
	PASS(p0,VS_TransformColour,PS_Add)
}

technique tex_vc {
	PASS(p0,VS_TransformColourTex,PS_TexCol)
}

technique tex {
	PASS(p0,VS_TransformTex,PS_Tex)
}

technique tex_blend {
	PASS(p0,VS_TransformTex,PS_TexBlend)
}

technique tex_blend_vc {
	PASS(p0,VS_TransformColourTex,PS_TexBlend)
}

technique tex_blend_mask {
	PASS(p0,VS_TransformColourTex2,PS_TexBlendMask)
}

technique tex_dist_mask {
	PASS(p0,VS_TransformColourTex2,PS_TexDistMask)
}

technique tex_add_vc {
	PASS(p0,VS_TransformColourTex,PS_TexAdd)
}

technique specular {
	PASS(p0,VS_TransformLighting,PS_Specular)
}

technique specular4 {
	PASS(p0,VS_TransformLighting4,PS_Specular)
}

technique trivial3D {
#ifdef PLAT_X360
	PASS_0(p0, VS_Trivial3D)
#elif defined(PLAT_PS3)
	PASS(p0, VS_Trivial3D, PS_Black)
#else
	PASS(p0, VS_Trivial3D, PS_White)
#endif
}

#ifdef PLAT_PC
technique blend_idx {
	PASS(p0,VS_Transform_idx,PS_Blend)
}

#ifndef USE_DX11
technique depth_min {
	PASS(p0,VS_PassThrough,PS_DepthMin)
}

technique depth_ray {
	PASS(p0,VS_ScreenToWorld,PS_DepthRay)
}

technique show_world {
	PASS(p0,VS_ShowWorld,PS_DepthRay)
}
#endif

//-----------------------------------------------------------------------------
//	Oculus Rift
//-----------------------------------------------------------------------------

sampler_def2D(ovr_samp, FILTER_MIN_MAG_MIP_LINEAR;);
float4		EyeToSourceUVTrans;
float4x4	EyeRotationStart, EyeRotationEnd;

float2 TimewarpTexCoord(float2 TexCoord, float4x4 rotMat) {
	float3 transformed	= mul(rotMat, float4(TexCoord.xy, 1, 1)).xyz;
	float2 flattened	= transformed.xy / transformed.z;
	return EyeToSourceUVTrans.xy * flattened + EyeToSourceUVTrans.zw;
}

float4 VS_oculus(
	in float2	Position			: POSITION,
	in float	timewarpLerpFactor	: POSITION1,
	in float	Vignette			: POSITION2,
	in float2	TexCoordR			: TEXCOORD0,
	in float2	TexCoordG			: TEXCOORD1,
	in float2	TexCoordB			: TEXCOORD2,
	out float2	oTexCoordR			: TEXCOORD0,
	out float2	oTexCoordG			: TEXCOORD1,
	out float2	oTexCoordB			: TEXCOORD2,
	out float	oVignette			: TEXCOORD3
) : POSITION_OUT {
	float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, timewarpLerpFactor);
	oTexCoordR  = TimewarpTexCoord(TexCoordR, lerpedEyeRot);
	oTexCoordG  = TimewarpTexCoord(TexCoordG, lerpedEyeRot);
	oTexCoordB  = TimewarpTexCoord(TexCoordB, lerpedEyeRot);
	oVignette	= Vignette;
	return float4(Position, 0.5, 1.0);
}

//Distortion pixel shader
float4 PS_oculus(
	in float4 pos : POSITION_OUT,
	in float2 oTexCoordR : TEXCOORD0,
	in float2 oTexCoordG : TEXCOORD1,
	in float2 oTexCoordB : TEXCOORD2,
	in float  oVignette  : TEXCOORD3
) : OUTPUT0 { 
	return float4(
		tex2D(ovr_samp, oTexCoordR).r,
		tex2D(ovr_samp, oTexCoordG).g,
		tex2D(ovr_samp, oTexCoordB).b,
		1
	) * oVignette;
}

technique oculus {
	PASS(p0,VS_oculus,PS_oculus)
}

#endif

#if defined(USE_DX11) || defined(PLAT_PS4)

float2	point_size = float2(1 / 50.f, 1 / 50.f);

//-----------------------------------------------------------------------------
//	ThickPoint
//-----------------------------------------------------------------------------

float4 Clip(float4 p0, float4 p1) {
	if (p0.z < 0)
		return p0 + (p1 - p0) * -p0.z / (p1.z - p0.z);
	return p0;
}

float cross2(float2 a, float2 b) {
	return a.x * b.y - a.y * b.x;
}

float2 perp(float2 a) {
	return float2(-a.y, a.x);
}

struct ThickPoint {
    float4 pos	: POSITION_IN;
};
 
ThickPoint VS_thickpoint(float3 pos : POSITION_IN) {
	ThickPoint	p;
	p.pos	= mul(float4(pos, 1.0), worldViewProj);
	return p;
}

GEOM_SHADER(4)
void GS_thickpoint(point ThickPoint v[1], inout TriangleStream<S_TransformColTex> tris) {
	S_TransformColTex	p;
	p.colour = diffuse_colour;
 
	float4	pw	= v[0].pos;
	if (pw.z < -pw.w)
		return;

    float2 pos	= pw.xy / pw.w;
    float4 size	= float4(-point_size, point_size);

	p.pos	= float4(pos + size.xy, 0, 1);
	p.uv	= float2(-1, -1);
	tris.Append(p);
 
	p.pos	= float4(pos + size.zy, 0, 1);
	p.uv	= float2(+1, -1);
	tris.Append(p);
 
	p.pos	= float4(pos + size.xw, 0, 1);
	p.uv	= float2(-1, +1);
	tris.Append(p);
 
	p.pos	= float4(pos + size.zw, 0, 1);
	p.uv	= float2(+1, +1);
	tris.Append(p);
}

float4 PS_thickpoint(S_TransformColTex p) : OUTPUT0 {
	float	r2	= dot(p.uv, p.uv);
	float	d	= max(abs(ddx(r2)), abs(ddy(r2)));
	return p.colour * smoothstep(1, 1 - d, r2);
}

technique thickpoint {
    pass p0 {
		SET_VS(VS_thickpoint);
		SET_GS(GS_thickpoint);
		SET_PS(PS_thickpoint);
	}
}

//-----------------------------------------------------------------------------
//	Thick line
//-----------------------------------------------------------------------------

GEOM_SHADER(4)
void GS_thickline(line ThickPoint v[2], inout TriangleStream<S_TransformColTex> tris) {
	S_TransformColTex	p;
	p.colour = diffuse_colour;
 
    float4 pw0		= Clip(v[0].pos, v[1].pos);
    float4 pw1		= Clip(v[1].pos, pw0);

    float2 pos0		= pw0.xy / pw0.w;
    float2 pos1		= pw1.xy / pw1.w;

	float2 d		= normalise(pos1 - pos0);
    float2 across	= point_size * perp(d);

	p.pos	= float4(pos0 - across, 0, 1);
	p.uv	= float2(-1, -1);
	tris.Append(p);
 
	p.pos	= float4(pos1 - across, 0, 1);
	p.uv	= float2(+1, -1);
	tris.Append(p);
 
	p.pos	= float4(pos0 + across, 0, 1);
	p.uv	= float2(-1, +1);
	tris.Append(p);
 
	p.pos	= float4(pos1 + across, 0, 1);
	p.uv	= float2(+1, +1);
	tris.Append(p);
}

float4 PS_thickline(S_TransformColTex p) : OUTPUT0 {
	float	d = max(abs(ddx(p.uv.y)), abs(ddy(p.uv.y)));
	return p.colour * smoothstep(1, 1 - d, abs(p.uv.y));
}

technique thickline {
    pass p0 {
		SET_VS(VS_thickpoint);
		SET_GS(GS_thickline);
		SET_PS(PS_thickline);
	}
}
//-----------------------------------------------------------------------------
//	Thick line with Adjacency
//-----------------------------------------------------------------------------

float2 intersect_lines(float2 pos0, float2 dir0, float2 pos1, float2 dir1) {
	float	d = cross2(dir0, dir1);
	if (d == 0)
		return pos1;
	return (dir0 * cross2(pos1, dir1) - dir1 * cross2(pos0, dir0)) / d;
}

float2 intersect_offsets(float2 pos, float2 dir0, float2 dir1, float2 point_size) {
	return intersect_lines(pos + perp(dir0) * point_size, dir0, pos + perp(dir1) * point_size, dir1);
}

GEOM_SHADER(5)
void GS_thicklineA(lineadj ThickPoint v[4], inout TriangleStream<S_TransformColTex> tris) {
	S_TransformColTex	p;
	p.colour = diffuse_colour;
 
    float4	pwa		= Clip(v[0].pos, v[1].pos);
    float4	pw0		= Clip(v[1].pos, v[2].pos);
    float4	pw1		= Clip(v[2].pos, pw0);
    float4	pw2		= Clip(v[3].pos, pw1);

    float2	posa	= pwa.xy / pwa.w;
    float2	pos0	= pw0.xy / pw0.w;
    float2	pos1	= pw1.xy / pw1.w;
    float2	pos2	= pw2.xy / pw2.w;

	float2	d1		= normalise(pos1 - pos0);
	float2	d0		= all(pos0 == posa) ? d1 : normalise(pos0 - posa);
	float2	d2		= all(pos1 == pos2) ? d1 : normalise(pos2 - pos1);

	bool	bevel0	= dot(d0, d1) < -.5;
	bool	bevel1	= dot(d1, d2) < -.5;

	if (bevel0) {
		// extra triangle for bevel
		if (cross2(d0, d1) < 0)
			p.pos	= float4(intersect_offsets(pos0, +d0, -d1, point_size), 0, 1);//A
		else
			p.pos	= float4(intersect_offsets(pos0, +d1, -d0, point_size), 0, 1);//B
		p.uv	= float2(-1, -1);
		tris.Append(p);
	}

	if (bevel0 && cross2(d0, d1) < 0)
		p.pos	= float4(intersect_offsets(pos0, -d0, +d1, point_size), 0, 1);
	else
		p.pos	= float4(intersect_offsets(pos0, +d1, +d0, point_size), 0, 1);//C
	p.uv	= float2(-1, -1);
	tris.Append(p);
 
	if (bevel0 && cross2(d0, d1) > 0)
		p.pos	= float4(intersect_offsets(pos0, +d0, -d1, point_size), 0, 1);
	else
		p.pos	= float4(intersect_offsets(pos0, -d0, -d1, point_size), 0, 1);
	p.uv	= float2(-1, +1);
	tris.Append(p);

	if (bevel1 && cross2(d1, d2) < 0)
		p.pos	= float4(intersect_offsets(pos1, -d2, +d1, point_size), 0, 1);//A
	else
		p.pos	= float4(intersect_offsets(pos1, +d2, +d1, point_size), 0, 1);//C
	p.uv	= float2(+1, -1);
	tris.Append(p);
 
	if (bevel1 && cross2(d1, d2) > 0)
		p.pos	= float4(intersect_offsets(pos1, +d2, -d1, point_size), 0, 1);//B
	else
		p.pos	= float4(intersect_offsets(pos1, -d2, -d1, point_size), 0, 1);
	p.uv	= float2(+1, +1);

	tris.Append(p);
}

technique thicklineA {
    pass p0 {
		SET_VS(VS_thickpoint);
		SET_GS(GS_thicklineA);
		SET_PS(PS_thickline);
	}
}

//-----------------------------------------------------------------------------
//	Circle tesselator
//-----------------------------------------------------------------------------

struct Circle {
	float4	v : CIRCLE;
};

struct CircleConsts {
	float	tess[2] : TESS_FACTOR;
};

Circle VS_circle(float4	v : POSITION_IN) {
	Circle	c;
	c.v		= v;
	return c;
}

// patch Constant Function
CircleConsts HS_circleC(InputPatch<Circle, 1> c, uint id : PRIMITIVE_ID) {	
    CircleConsts	cc;

	float	w	= mul(float4(c[0].v.xyz, 1.0), worldViewProj).w;

	cc.tess[0]	= 1;
	cc.tess[1]	= c[0].v.w / w * 64;
	return cc;
}

// hull shader
HULL_SHADER(HS_circleC, isoline,fractional_even,line,1)
Circle HS_circle(InputPatch<Circle, 1> c, uint id : PRIMITIVE_ID, uint i : OUTPUT_CONTROL_POINT_ID) {
	return c[0];
}

// domain shader
DOMAIN_SHADER(isoline) 
ThickPoint DS_circle(CircleConsts cc, float t : DOMAIN_LOCATION, const OutputPatch<Circle, 1> c) {
	ThickPoint	p;
	float2	sc;
	sincos(t * 2 * 3.1415926535, sc.y, sc.x);
	float3	pos = c[0].v.xyz + float3(sc * c[0].v.w, 0);
	p.pos	= mul(float4(pos, 1.0), worldViewProj);
	return p;
}

technique circletess {
    pass p0 {
		SET_VS(VS_circle);
		SET_HS(HS_circle);
		SET_DS(DS_circle);
		SET_GS(GS_thickline);
		SET_PS(PS_thickline);
	}
}

#endif

]]>
            </fileSource>
        </file>
        <file userSpecifiedFileName="D:\dev\shared\assets\shaders/common.fxh" absoluteFileName="D:\dev\shared\assets\shaders\common.fxh" fileID="3" primary="0">
            <fileInfo creationTime="2015-06-19T05:07:57Z" modificationTime="2015-06-24T14:46:00Z"/>
            <includeReference refFileID="2" refLineNumber="1" includeText="&quot;common.fxh&quot;"/>
            <fileSource>
                <![CDATA[#ifndef COMMON_FXH
#define COMMON_FXH

#ifdef _3DSMAX_
string ParamID = "0x0001";
#endif

#if defined(PLAT_IOS) || defined(PLAT_MAC)
#define PLAT_GLSL
#endif

#ifndef PLAT_GLSL
#define lowp
#define mediump
#define highp
#endif

//------------------------------------
//	DX11 compatibility
//------------------------------------
#ifdef USE_DX11

#define technique		technique11
#define VS_PROFILE		vs_4_1
#define PS_PROFILE		ps_4_1
#define GS_PROFILE		gs_4_1
#define HS_PROFILE		hs_5_0
#define DS_PROFILE		ds_5_0

#define SET_PS0			SetPixelShader(NULL);
#define SET_PS(f)		SetPixelShader(CompileShader(PS_PROFILE, f()))
#define SET_VS(f)		SetVertexShader(CompileShader(VS_PROFILE, f()))
#define SET_GS(f)		SetGeometryShader(CompileShader(GS_PROFILE, f()))
#define SET_HS(f)		SetHullShader(CompileShader(HS_PROFILE, f()))
#define SET_DS(f)		SetDomainShader(CompileShader(DS_PROFILE, f()))

#define GEOM_SHADER(n)\
	[maxvertexcount(n)]
#define HULL_SHADER(const_fn, dom,part,topol,num_control)\
	[patchconstantfunc(#const_fn)]\
	[domain(#dom)]\
	[partitioning(#part)]\
	[outputtopology(#topol)]\
	[outputcontrolpoints(num_control)]
#define DOMAIN_SHADER(dom)\
	[domain(#dom)]

BlendState				NoBlend { AlphaToCoverageEnable = FALSE;  BlendEnable[0] = FALSE; };
BlendState				blend_state	{SrcBlend = ONE; DestBlend = INV_SRC_ALPHA;};
RasterizerState			raster_state {CullMode = FRONT;};
DepthStencilState		depth_state {DEPTHWRITEMASK = ZERO;};

#define	STATES							SetBlendState(blend_state, float4(0,0,0,0), 0xFFFFFFFF); SetRasterizerState(raster_state) 
#define	STATES_NOZW						STATES; SetDepthStencilState(depth_state)
#define	STATE_PARAM(x)					x
#define	FILTER_MIN_MAG_MIP_POINT		FILTER = MIN_MAG_MIP_POINT
#define	FILTER_MIN_MAG_LINEAR_MIP_POINT	FILTER = MIN_MAG_LINEAR_MIP_POINT
#define	FILTER_MIN_MAG_MIP_LINEAR		FILTER = MIN_MAG_MIP_LINEAR
#define	FILTER_ANISOTROPIC				FILTER = ANISOTROPIC

#define sampler1D	iso_sampler1D
#define sampler2D	iso_sampler2D
#define sampler3D	iso_sampler3D
#define samplerCUBE	iso_samplerCUBE

struct sampler1D {
	Texture1D		t;
	SamplerState	s;
};
struct sampler2D {
	Texture2D		t;
	SamplerState	s;
};
struct sampler3D {
	Texture3D		t;
	SamplerState	s;
};
struct samplerCUBE {
	TextureCube		t;
	SamplerState	s;
};
struct sampler2DArray {
	Texture2DArray	t;
	SamplerState	s;
};

#define sampler						SamplerState
#define sampler_tex1D(n, t, v)		SamplerState	n##_s {v}; static const sampler1D n = {t, n##_s}
#define sampler_tex2D(n, t, v)		SamplerState	n##_s {v}; static const sampler2D n = {t, n##_s}
#define sampler_texCUBE(n, t, v)	SamplerState	n##_s {v}; static const samplerCUBE n = {t, n##_s}
#define sampler_tex2DArray(n, t, v)	SamplerState	n##_s {v}; static const sampler2DArray n = {t, n##_s}
#define sampler_def1D(n, v)			Texture1D		n##_t; sampler_tex1D(n, n##_t, v)
#define sampler_def2D(n, v)			Texture2D		n##_t; sampler_tex2D(n, n##_t, v)
#define sampler_defCUBE(n, v)		TextureCube		n##_t; sampler_texCUBE(n, n##_t, v)
#define sampler_def2DArray(n, v)	Texture2DArray	n##_t; sampler_tex2DArray(n, n##_t, v)

float4 tex1D(sampler1D x, float v)			{ return x.t.Sample(x.s, v); }
float4 tex2D(sampler2D x, float2 v)			{ return x.t.Sample(x.s, v); }
float4 tex3D(sampler3D x, float3 v)			{ return x.t.Sample(x.s, v); }
float4 texCUBE(samplerCUBE x, float3 v)		{ return x.t.Sample(x.s, v); }

float4 tex1Dlod(sampler1D x, float4 v)		{ return x.t.SampleLevel(x.s, v.x, v.w); }
float4 tex2Dlod(sampler2D x, float4 v)		{ return x.t.SampleLevel(x.s, v.xy, v.w); }
float4 tex3Dlod(sampler3D x, float4 v)		{ return x.t.SampleLevel(x.s, v.xyz, v.w); }
float4 texCUBElod(samplerCUBE x, float4 v)	{ return x.t.SampleLevel(x.s, v.xyz, v.w); }

#define UNIFORM_SEMANTIC(s)		: s
#define OUTPUT0					SV_Target0
#define OUTPUT(n)				SV_Target##n
#define POSITION_IN				POSITION
#define POSITION_OUT			SV_Position
#define OUTPUT_DEPTH			SV_Depth
#define OUTPUT_DEPTH_GE			SV_DepthGreaterEqual
#define OUTPUT_DEPTH_LE			SV_DepthLessEqual
#define CLIP_DISTANCE(n)		SV_ClipDistance##n
#define CULL_DISTANCE(n)		SV_CullDistance##n
#define COVERAGE				SV_Coverage
#define INNER_COVERAGE			SV_InnerCoverage
#define FRONT_FACE				SV_IsFrontFace
#define SAMPLE_INDEX			SV_SampleIndex
#define STENCIL_REF				SV_StencilRef

#define VERTEX_ID				SV_VertexID
#define INSTANCE_ID				SV_InstanceID
#define GSINSTANCE_ID			SV_GSInstanceID
#define PRIMITIVE_ID			SV_PrimitiveID
#define OUTPUT_CONTROL_POINT_ID	SV_OutputControlPointID

#define DISPATCH_THREAD_ID		SV_DispatchThreadID
#define GROUP_ID				SV_GroupID
#define GROUP_INDEX				SV_GroupIndex
#define GROUP_THREAD_ID			SV_GroupThreadID

#define RENDER_TARGET_INDEX		SV_RenderTargetArrayIndex
#define VIEWPORT_INDEX			SV_ViewportArrayIndex
#define TESS_FACTOR				SV_TessFactor
#define INSIDE_TESS_FACTOR		SV_InsideTessFactor
#define DOMAIN_LOCATION			SV_DomainLocation

#define Matrix					NotMatrix

#elif defined(__PSSL__)
//------------------------------------
//	PSSL
//------------------------------------

#define	STATES							SrcBlend = ONE; DestBlend = INVSRCALPHA; CullMode = CW
#define	STATES_NOZW						STATES; ZWRITEENABLE = FALSE
#define	STATE_PARAM(x)					<x>
#define	FILTER_MIN_MAG_MIP_POINT		MIPFILTER = POINT; MINFILTER = POINT; MAGFILTER = POINT
#define	FILTER_MIN_MAG_LINEAR_MIP_POINT	MIPFILTER = POINT; MINFILTER = LINEAR; MAGFILTER = LINEAR
#define	FILTER_MIN_MAG_MIP_LINEAR		MIPFILTER = LINEAR; MINFILTER = LINEAR; MAGFILTER = LINEAR
#define	FILTER_ANISOTROPIC				MIPFILTER = LINEAR; MINFILTER = ANISOTROPIC; MAGFILTER = LINEAR

#define SET_PS0
#define SET_VS(f)	OrbisVertexShader = f
#define SET_HS(f)	OrbisHullShader = f
#define SET_DS(f)	OrbisDomainShader = f
#define SET_GS(f)	OrbisGeometryShader = f
#define SET_PS(f)	OrbisPixelShader = f

#define GEOM_SHADER(n)\
	[MAX_VERTEX_COUNT(n)]
#define HULL_SHADER(const_fn, dom,part,topol,num_control)\
	[PATCH_CONSTANT_FUNC(#const_fn)]\
	[DOMAIN_PATCH_TYPE(#dom)]\
	[PARTITIONING_TYPE(#part)]\
	[OUTPUT_TOPOLOGY_TYPE(#topol)]\
	[OUTPUT_CONTROL_POINTS(num_control)]
#define DOMAIN_SHADER(dom)\
	[DOMAIN_PATCH_TYPE(#dom)] 

#define point						Point
#define line						Line
#define triangle					Triangle
#define lineadj						AdjacentLine
#define triangleadj					AdjacentTriangle

#define StructuredBuffer			RegularBuffer
#define RWStructuredBuffer			RWRegularBuffer
#define ByteAddressBuffer			ByteBuffer
#define RWByteAddressBuffer			RWByteBuffer
#define AppendStructuredBuffer		AppendRegularBuffer
#define ConsumeStructuredBuffer		ConsumeRegularBuffer
#define PointStream					PointBuffer
#define LineStream					LineBuffer
#define TriangleStream				TriangleBuffer					

struct sampler1D {
	Texture1D		t;
	SamplerState	s;
};
struct sampler2D {
	Texture2D		t;
	SamplerState	s;
};
struct sampler3D {
	Texture3D		t;
	SamplerState	s;
};
struct samplerCUBE {
	TextureCube		t;
	SamplerState	s;
};
struct sampler2DArray {
	Texture2D_Array	t;
	SamplerState	s;
};

#define sampler						SamplerState
#define sampler_tex1D(n, t, v)		SamplerState	n##_s {v}; sampler1D n = {t, n##_s}
#define sampler_tex2D(n, t, v)		SamplerState	n##_s {v}; sampler2D n = {t, n##_s}
#define sampler_texCUBE(n, t, v)	SamplerState	n##_s {v}; samplerCUBE	n = {t, n##_s}
#define sampler_tex2DArray(n, t, v)	SamplerState	n##_s {v}; sampler2DArray n = {t, n##_s}

#define sampler_def1D(n, v)			Texture1D		n##_t; sampler_tex1D(n, n##_t, v)
#define sampler_def2D(n, v)			Texture2D		n##_t; sampler_tex2D(n, n##_t, v)
#define sampler_defCUBE(n, v)		TextureCube		n##_t; sampler_texCUBE(n, n##_t, v)
#define sampler_def2DArray(n, v)	Texture2D_Array	n##_t; sampler_tex2DArray(n, n##_t, v)

float4 tex1D(sampler1D x, float v)		{ return x.t.Sample(x.s, v); }
float4 tex2D(sampler2D x, float2 v)		{ return x.t.Sample(x.s, v); }
float4 tex3D(sampler3D x, float3 v)		{ return x.t.Sample(x.s, v); }
float4 texCUBE(samplerCUBE x, float3 v)	{ return x.t.Sample(x.s, v); }

#define UNIFORM_SEMANTIC(s)
#define OUTPUT0					S_TARGET_OUTPUT0
#define OUTPUT(n)				S_TARGET_OUTPUT##n
#define POSITION_IN				POSITION
#define POSITION_OUT			S_POSITION
#define OUTPUT_DEPTH			S_DEPTH_OUTPUT
#define OUTPUT_DEPTH_GE			S_DEPTH_GE_OUTPUT
#define OUTPUT_DEPTH_LE			S_DEPTH_LE_OUTPUT
#define	CLIP_DISTANCE(n)		S_CLIP_DISTANCE##n
#define	CULL_DISTANCE(n)		S_CULL_DISTANCE##n
#define	COVERAGE				S_COVERAGE
#define	FRONT_FACE				S_FRONT_FACE
#define	SAMPLE_INDEX			S_SAMPLE_INDEX

#define VERTEX_ID				S_VERTEX_ID
#define	INSTANCE_ID				S_INSTANCE_ID
#define	GSINSTANCE_ID			S_GSINSTANCE_ID
#define	PRIMITIVE_ID			S_PRIMITIVE_ID
#define	OUTPUT_CONTROL_POINT_ID	S_OUTPUT_CONTROL_POINT_ID

#define	DISPATCH_THREAD_ID		S_DISPATCH_THREAD_ID
#define	GROUP_ID				S_GROUP_ID
#define	GROUP_INDEX				S_GROUP_INDEX
#define	GROUP_THREAD_ID			S_GROUP_THREAD_ID

#define	RENDER_TARGET_INDEX		S_RENDER_TARGET_INDEX
#define	VIEWPORT_INDEX			S_VIEWPORT_INDEX
#define	TESS_FACTOR				S_EDGE_TESS_FACTOR
#define	INSIDE_TESS_FACTOR		S_INSIDE_TESS_FACTOR
#define	DOMAIN_LOCATION			S_DOMAIN_LOCATION

#define	POINT_SIZE				S_POINT_SIZE
#define	POINT_COORD				S_POINT_COORD

//#define row_major
#define Matrix					NotMatrix

#else
//------------------------------------
//	not PSSL or DX11
//------------------------------------

#define	STATES							SrcBlend = ONE; DestBlend = INVSRCALPHA; CullMode = CW
#define	STATES_NOZW						STATES; ZWRITEENABLE = FALSE
#define	STATE_PARAM(x)					<x>
#define	FILTER_MIN_MAG_MIP_POINT		MIPFILTER = POINT; MINFILTER = POINT; MAGFILTER = POINT
#define	FILTER_MIN_MAG_LINEAR_MIP_POINT	MIPFILTER = POINT; MINFILTER = LINEAR; MAGFILTER = LINEAR
#define	FILTER_MIN_MAG_MIP_LINEAR		MIPFILTER = LINEAR; MINFILTER = LINEAR; MAGFILTER = LINEAR
#define	FILTER_ANISOTROPIC				MIPFILTER = LINEAR; MINFILTER = ANISOTROPIC; MAGFILTER = LINEAR

#ifdef PLAT_WII
#define VS_PROFILE	vs_wii
#define PS_PROFILE	ps_wii
#elif defined(PLAT_GLSL)
#define VS_PROFILE	vs_glsl
#define PS_PROFILE	ps_glsl
#elif defined(PLAT_PS3)
#define VS_PROFILE	vs_ps3
#define PS_PROFILE	ps_ps3
#else
#define VS_PROFILE	vs_3_0
#define PS_PROFILE	ps_3_0
#endif

#define SET_PS0
#define SET_PS(f)		PixelShader		= compile PS_PROFILE f()
#define SET_VS(f)		VertexShader	= compile VS_PROFILE f()
#define SET_GS(f)

#define sampler_tex1D(n, t, v)		sampler		n : t = sampler_state {texture = <t>; v}
#define sampler_tex2D(n, t, v)		sampler		n : t = sampler_state {texture = <t>; v}
#define sampler_texCUBE(n, t, v)	samplerCUBE	n : t = sampler_state {texture = <t>; v}
#define sampler_tex2DArray(n, t, v)	sampler		n : t = sampler_state {texture = <t>; v}

#define sampler_def1D(n, v)			sampler		n = sampler_state {v}
#define sampler_def2D(n, v)			sampler2D	n = sampler_state {v}
#define sampler_defCUBE(n, v)		samplerCUBE	n = sampler_state {v}
#define sampler_def2DArray(n, v)	sampler		n = sampler_state {v}

#ifndef PLAT_X360
#define	Texture1DArray			texture
#define	Texture2D	  			texture
#define	Texture2DArray			texture
#define	Texture3D	  			texture
#define	TextureCube	  			texture
#endif

#define UNIFORM_SEMANTIC(s)		: s
#define OUTPUT0					COLOR0
#define OUTPUT_DEPTH			DEPTH
#define POSITION_IN				POSITION
#define POSITION_OUT			POSITION

#endif

#define PASS(n,v,p)		pass n { SET_VS(v); SET_PS(p); }
#define PASS_S(n,v,p,s)	pass n { SET_VS(v); SET_PS(p); s; }
#define PASS_0(n,v)		pass n { SET_VS(v); SET_PS0 }

//------------------------------------
//	function composition
//------------------------------------
#define COMPOSE_FN(f, g)				f##_##g
#define COMPOSE_DEC(f, g, o, i)			o f##_##g(i)
#define COMPOSE_DEF(f, g, o, i)			o f##_##g(i p)			{ return f(g(p)); }
#define COMPOSE_DEC2(f, g, o, i1, i2)	o f##_##g(i1, i2)
#define COMPOSE_DEF2(f, g, o, i1, i2)	o f##_##g(i1 p1, i2 p2) { return f(g(p1, p2)); }

#define EXTRA_INPUT
#define EXTRA_VS_PRE(vi, vs)
#define EXTRA_VS(vo, vs)
#define EXTRA_PASS(vs, ps)

#ifdef _3DSMAX_
	#define PLAT_PC
	#define meters(x)	(39.27 * x)
	#define seconds		((time * 6.25) / 30)
#else
	#define meters(x)	x
	#define seconds		time
#endif

//------------------------------------
//	defines
//------------------------------------

typedef row_major float4x4	Matrix;
typedef highp float			fogtype;

#define normalise	normalize

#ifdef _3DSMAX_
	#define MAPCHAN2(NAME,TC,MC)	int NAME : TEXCOORD <int Texcoord = TC; int MapChannel = MC;>;
	#define MAPCHAN(TC,MC)			MAPCHAN2(texcoord##TC,TC,MC)
	#define	VCDEFS(C,A)\
		MAPCHAN2(vertexcolour, C, 0)\
		MAPCHAN2(vertexalpha, A, -2)\
		float4	get_vc(colour_alpha c)				{ return float4(c.rgb,c.a); }
		//struct	colour_alpha { float3 rgb : TEXCOORD##C; float a : TEXCOORD##A; };
	#define	VCIDEFS(RGB,A,I)	VCDEFS(RGB,A)\
		MAPCHAN2(vertexillum, I, -1)\
		float3	get_norm(normal_illum c)					{ return c.normal;		}\
		void	set_norm(inout normal_illum c, float3 n)	{ c.normal = n;			}\
		float	get_illum(normal_illum c)					{ return 1 - c.illum.r;	}
		//struct	normal_illum { float3 normal : NORMAL; float3 illum : TEXCOORD##I; };
#else
	#define MAPCHAN2(NAME,TC,MC)
	#define MAPCHAN(TC,MC)
	#define	VCDEFS(RGB,A)\
		struct	colour_alpha { float4 rgba : COLOR0; };\
		float4	get_vc(colour_alpha c)				{ return c.rgba; }
	#define	VCIDEFS(RGB,A,I)	VCDEFS(RGB,A)\
		struct	normal_illum { float4 normal : NORMAL; };\
		float3	get_norm(normal_illum c)					{ return c.normal.xyz;	}\
		void	set_norm(inout normal_illum c, float3 n)	{ c.normal.xyz = n;		}\
		float	get_illum(normal_illum c)					{ return c.normal.w;	}
#endif

#ifdef PLAT_WII
	#define UNNORMALISED	NORMALISED = FALSE;
#else
	#define UNNORMALISED
#endif

#if defined(PLAT_PC)		//	PC specific defines
	#define CENTRE			POSITION1
	#define AMBIENT			TEXCOORD4
	#define COLOR_HDR		TEXCOORD5
#elif defined(PLAT_X360)	//	X360 specific defines
	#define CENTRE			POSITION1
	#define VFETCH(d, i, s)	{float4 t; asm { vfetch t, i, s }; d = t;}
	#define AMBIENT			TEXCOORD4
	#define COLOR_HDR		TEXCOORD5
#elif defined(PLAT_PS3)		//	PS3 specific defines
	#define CENTRE			BLENDWEIGHT
	#define NORMAL1			BINORMAL
	#define FOG				FOGC
	#define AMBIENT			TEXCOORD4
	#define COLOR_HDR		TEXCOORD5
#elif defined(PLAT_WII)		//	WII specific defines
	#define CENTRE			_IGNORE	//TEXCOORD7
	#define AMBIENT			COLOR1
	#define COLOR_HDR		COLOR0
	#define samplerCUBE		sampler
	#undef DYNAMIC_LIGHTS
#elif defined(PLAT_IOS)		//	IOS specific defines
	#define AMBIENT			COLOR1
	#define COLOR_HDR		COLOR0
	#define NORMAL1			BINORMAL
	#define saturate(x)		clamp(x, 0.0, 1.0)
	#define clip(x)			if (x < 0.0) discard
#endif

struct position4 { float4 p : POSITION4; };

//------------------------------------
//	matrices
//------------------------------------

Matrix	worldViewProj	UNIFORM_SEMANTIC(WORLDVIEWPROJ);
Matrix	worldView		UNIFORM_SEMANTIC(WORLDVIEW);
Matrix	world			UNIFORM_SEMANTIC(WORLD);
Matrix	view			UNIFORM_SEMANTIC(VIEW);
Matrix	projection		UNIFORM_SEMANTIC(PROJECTION);
Matrix	iview			UNIFORM_SEMANTIC(VIEWI);
Matrix	iviewProj		UNIFORM_SEMANTIC(VIEWPROJI);
float	time			UNIFORM_SEMANTIC(TIME);

float2	zbconv;

#ifdef _3DSMAX_
	Matrix	ViewProj()	{ return mul(view, projection); }
#else
	Matrix	viewProj	UNIFORM_SEMANTIC(VIEWPROJ);
	Matrix	ViewProj()	{ return viewProj; }
#endif

//------------------------------------
//	random uniforms
//------------------------------------

float4	tint		= { 1, 1, 1, 1 };
float	layer_scaler;

//------------------------------------
//	flags
//------------------------------------

bool	sort			<string UIName = "Sort";>					= false;
bool	no_shadow		<string UIName = "Don't Cast Shadow";>		= false;
bool	double_sided	<string UIName = "Double Sided";>			= false;
bool	draw_first		<string UIName = "Draw first";>				= false;
bool	draw_last		<string UIName = "Draw last";>				= false;

//------------------------------------
//	samplers
//------------------------------------

sampler_def2D(_screen,
	FILTER_MIN_MAG_LINEAR_MIP_POINT;
	ADDRESSU	= CLAMP;
	ADDRESSV	= CLAMP;
);

highp sampler_def2D(_zbuffer,
	FILTER_MIN_MAG_MIP_POINT;
	ADDRESSU	= CLAMP;
	ADDRESSV	= CLAMP;
);

#ifdef PLAT_IOS
sampler2DShadow	_zbuffer_shadow;
#endif

//------------------------------------
//	functions
//------------------------------------

float3	project(float4 p)	{ return p.xyz / p.w; }
float	len2(float2 v)		{ return dot(v, v); }
float	len2(float3 v)		{ return dot(v, v); }
float	len2(float4 v)		{ return dot(v, v); }
float	square(float v)		{ return v * v; }
float2	square(float2 v)	{ return v * v; }
float3	square(float3 v)	{ return v * v; }
float4	square(float4 v)	{ return v * v; }
float	max_comp(float2 v)	{ return max(v.x, v.y); }
float	max_comp(float3 v)	{ return max(max(v.x, v.y), v.z); }
float	max_comp(float4 v)	{ return max(max(v.x, v.y), max(v.z, v.w)); }

float3x3 GetBasis(float3 normal, float3 tangent)						{ return float3x3(tangent, cross(normal, tangent), normal);	}
float3	CalcNormal(float2 n)											{ return float3(n, sqrt(1 - dot(n, n)));					}
float3	GetNormal(sampler2D s, float2 uv)								{ return CalcNormal(tex2D(s, uv).xy * 2 - 1);				}
float3	GetNormal(sampler2D s, float2 uv, float lod)					{ return CalcNormal((tex2D(s, uv).xy * 2 - 1) * lod);		}
float3	GetNormal(sampler2D s1, float2 uv1, sampler2D s2, float2 uv2)	{ return CalcNormal((tex2D(s1, uv1).xy + tex2D(s2, uv2).xy) * 2 - 2); }


float3x3 cofactors(float3x3 m) {
	return float3x3(
		cross(m[1], m[2]),
		cross(m[2], m[0]),
		cross(m[0], m[1])
	);
}

float4x4 cofactors(float4x4 m) {
	float3	c0 = cross(m[2].xyz, m[3].xyz);
	float3	c1 = m[2].xyz * m[3].w - m[3].xyz * m[2].w;
	float4	dx = float4(cross(m[1].xyz, c1) + c0 * m[1].w, -dot(c0, m[1].xyz));
	float4	dy = float4(cross(c1, m[0].xyz) - c0 * m[0].w,  dot(c0, m[0].xyz));

	float3	c2 = cross(m[0].xyz, m[1].xyz);
	float3	c3 = m[0].xyz * m[1].w - m[1].xyz * m[0].w;
	float4	dz = float4(cross(m[3].xyz, c3) + c2 * m[3].w, -dot(c2, m[3].xyz));
	float4	dw = float4(cross(c3, m[2].xyz) - c2 * m[2].w,  dot(c2, m[2].xyz));

	return float4x4(dx, dy, dz, dw);
}

float3x3 inverse_transpose(float3x3 m) {
	float3x3	c = cofactors(m);
	return c / dot(m[0], c[0]);
}

float4x4 inverse_transpose(float4x4 m) {
	float4x4	c = cofactors(m);
	return c / dot(m[0], c[0]);
}

float3x3 quaternion_to_float3x3(float4 q) {
	float3	v	= q.xyz + q.xyz;
	float3	d	= v * q.xyz;
	float3	t	= v * q.yzx;
	float3	u	= v * q.w;
	float3	a	= t.xyz - u.zxy;
	float3	b	= t.zxy + u.yzx;
	d	= 1 - d.yzx - d.zxy;
	return float3x3(
		float3(d.x, a.x, b.x),
		float3(b.y, d.y, a.y),
		float3(a.z, b.z, d.z)
	);
}
// quaternion * vector
float3 quat_vec_mul(float4 q, float3 v) {
	return v + 2 * cross(q.xyz, cross(q.xyz, v) - v * q.w);
}
// quaternion * quaternion
float4 quat_quat_mul(float4 a, float4 b) {
	return float4(b.xyz * a.w + a.xyz * b.w - cross(a.xyz, b.xyz), a.w * b.w - dot(a.xyz, b.xyz));
}

float4	Blend(float4 c)								{ return float4(c.rgb * c.a, c.a);	}
float4	Add(float4 c)								{ return float4(c.rgb * c.a, 0);	}
float4	PremultBlend(float4 d, float4 s)			{ return d * (1 - s.a) + s;			}

#ifdef PLAT_PS3
//------------------------------------
//	PS3 only
//------------------------------------
#define far_depth	0
#define near_depth	1
#define nearest		max
#define furthest	min
#define ztest(z, b)	((z) >= (b))
#define	CalcNormalU	CalcNormal
#define	GetNormalU	GetNormal
float4	hdr(float4 col)								{ return float4(col.rgb * 2, 1);	}
#else
//------------------------------------
//	Not PS3
//------------------------------------
#define far_depth	1
#define near_depth	0
#define nearest		min
#define furthest	max
#define ztest(z, b)	((z) <= (b))
float3	CalcNormalU(float2 n)							{ return float3(n, sqrt(0.25 - dot(n, n)));			}
float3	GetNormalU(sampler2D s, float2 uv)				{ return CalcNormalU(tex2D(s, uv).xy - .5);		}
float3	GetNormalU(sampler2D s, float2 uv, float lod)	{ return CalcNormalU((tex2D(s, uv).xy - .5) * lod);	}
float3	GetNormalU(sampler2D s1, float2 uv1, sampler2D s2, float2 uv2)	{ return CalcNormalU(tex2D(s1, uv1).xy + tex2D(s2, uv2).xy - 1); }
float4	hdr(float4 col)									{ return float4(col.rgb, 1);	}
#endif

#ifdef PLAT_X360
//------------------------------------
//	X360 only
//------------------------------------
#define ztest_map(z, b)	ztest((b),(z))
#else
//------------------------------------
//	Not X360
//------------------------------------
#define ztest_map(z, b)	ztest((z),(b))
#endif

#ifdef PLAT_WII
//------------------------------------
//	Wii only
//------------------------------------
struct packed_uvs0 { float2 uv0: TEXCOORD0, uv1: TEXCOORD6; };
struct packed_uvs1 { float2 uv0: TEXCOORD1, uv1: TEXCOORD4; };
packed_uvs0 pack_uvs0(float2 x, float2 y) { packed_uvs0 t; t.uv0 = x; t.uv1 = y; return t; }
packed_uvs1 pack_uvs1(float2 x, float2 y) { packed_uvs1 t; t.uv0 = x; t.uv1 = y; return t; }
float2		get0(packed_uvs0 t) { return t.uv0; }
float2		get1(packed_uvs0 t) { return t.uv1; }
float2		get2(packed_uvs1 t) { return t.uv0; }
float2		get3(packed_uvs1 t) { return t.uv1; }

#define PACKED_UV01		float2	uv0		: TEXCOORD0;\
						float2	uv1		: TEXCOORD6;
#define PACK_UV01(x, y)	v2.uv0			= x;\
						v2.uv1			= y;
#define UV0				v.uv0
#define UV1				v.uv1
#define PACKED_UV23		float2	uv2		: TEXCOORD1;\
						float2	uv3		: TEXCOORD4;
#define PACK_UV23(x, y)	v2.uv2			= x;\
						v2.uv3			= y;
#define UV2				v.uv2
#define UV3				v.uv3

float2	UnnormaliseUV(float2 r_image_size, float2 uv)					{ return uv; }
float4	UnnormalisedTex(sampler s, float2 r_image_size, float2 uv)		{ return tex2D(s, uv); }
float3	GetNormal(sampler s, float2 uv, float3 normal, float3 tangent)	{ return normal; }
float	Distance0(float t1, float t)		{ return saturate((t - t1 * 0.874) * 8); }
float4	Distance1(float4 colour1, float t1, float t, float d) {
	return colour1 * Distance0(t1, t);
}
float4	Distance2(float4 colour1, float4 colour2, float t1, float t2, float t, float d) {
	float	a1 = Distance0(t1, t);
	float	a2 = Distance0(t2, t);
	return lerp(colour2, colour1, a1) * a2;
}

#else
//------------------------------------
//	Not Wii
//------------------------------------
float2 UnnormaliseUV(float2 r_image_size, float2 uv)						{ return uv * r_image_size; }
float4 UnnormalisedTex(sampler2D s, float2 r_image_size, float2 uv)			{ return tex2D(s, uv * r_image_size); }
float3 GetNormal(sampler2D s, float2 uv, float3 normal, float3 tangent) {
	return normalise(mul(GetNormalU(s, uv), GetBasis(normal, tangent)));
}
float3 GetNormal(sampler2D s1, sampler2D s2, float2 uv1, float2 uv2, float3 normal, float3 tangent) {
	return normalise(mul(GetNormalU(s1, uv1, s2, uv2), GetBasis(normal, tangent)));
}
float4 Distance1(float4 colour1, float t1, float t, float d) {
	return colour1 * smoothstep(t1 - d, t1 + d, t);
}
float4 Distance2(float4 colour1, float4 colour2, float t1, float t2, float t, float d) {
	return lerp(colour2, colour1, smoothstep(t1 - d, t1 + d, t)) * smoothstep(t2 - d, t2 + d, t);
}
float4 OuterGlow(float4 colour1, float4 colour2, float t1, float t2, float t, float d) {
	return lerp(colour2, colour1, smoothstep(t1 - d, t1 + d, t)) * saturate((t - t2) / (t1 - t2));
}
struct packed_uvs0 { float4 uv: TEXCOORD0; };
struct packed_uvs1 { float4 uv: TEXCOORD1; };
packed_uvs0 pack_uvs0(float2 x, float2 y) { packed_uvs0 t; t.uv = float4(x, y); return t; }
packed_uvs1 pack_uvs1(float2 x, float2 y) { packed_uvs1 t; t.uv = float4(x, y); return t; }
float2		get0(packed_uvs0 t) { return t.uv.xy; }
float2		get1(packed_uvs0 t) { return t.uv.zw; }
float2		get2(packed_uvs1 t) { return t.uv.xy; }
float2		get3(packed_uvs1 t) { return t.uv.zw; }
#define PACKED_UV01		float4	uv0_1	: TEXCOORD0;
#define PACK_UV01(x, y)	v2.uv0_1		= float4(x, y);
#define UV0				v.uv0_1.xy
#define UV1				v.uv0_1.zw
#define PACKED_UV23		float4	uv2_3	: TEXCOORD1;
#define PACK_UV23(x, y)	v2.uv2_3		= float4(x, y);
#define UV2				v.uv2_3.xy
#define UV3				v.uv2_3.zw

#endif

// general:		-1 < x,y,z < +1
// platform:	what platform API expects (e.g. -1 < x,y < +1, 0 < z < 1)
//map_fix:			general to texture coord
//platform_fix:		general to platform
//platform_to_map:	platform to texture coord

#ifdef PLAT_X360
//------------------------------------
//	360 specific
//------------------------------------
float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5;	}
float3	map_fix(float3 pos)					{ return pos * float3(0.5, 0.5, -0.5) + 0.5; }
float4	map_fix(float4 pos)					{ float4 t = pos * float4(1,+1,-1,1); return t + t.wwww; }
float4	platform_fix(float3 pos)			{ return float4(pos * float3(1,-1,-0.5) + float3(0,0,0.5), 1); }
float4	platform_fix(float4 pos)			{ float4 t = pos * float4(1,-1,-1,1); return t + t.xyww; }
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,-0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos * float4(1,-1,1,1) + pos.wwzw; }
float4	punch_pixel(float4 c)				{ return tint.a == 1 ? c / c.a : float4(c.rgb * tint.a, c.a); }

float3	VS_texARRAY(float3 t)				{ return float3(t.xy, (t.z + 0.5) * layer_scaler); }
float4	PS_texARRAY(sampler s, float3 t)	{ return tex3D(s, t);		}

float4 PointSample(sampler2D s, float2 uv) {
	float4 col;
	asm { tfetch2D col, uv, s, MinFilter=point, MagFilter=point };
	return col;
}
float4 PointSample(sampler2D s, float2 uv, float offx, float offy) {
	float4	col;
	asm { tfetch2D col, uv, s, MinFilter=point, MagFilter=point, OffsetX=offx, OffsetY=offy };
	return col;
}
float4 PointSample(sampler2D s, float2 uv, float2 offset) {
	return PointSample(s, uv, offset.x, offset.y);
}

float GetDepth(sampler2D s, float2 uv) {
	return PointSample(s, uv).x;
}
float GetDepth(sampler2D s, float2 uv, float2 offset) {
	float4	col;
	float	x = offset.x, y = offset.y;
	asm { tfetch2D col, uv, s, MinFilter=point, MagFilter=point, OffsetX=x, OffsetY=y };
	return col.x;
}

#elif defined(PLAT_PS3)
//------------------------------------
//	PS3 specific
//------------------------------------
float2	inv_tex_size;

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5;			}
float3	map_fix(float3 pos)					{ return pos * 0.5 + 0.5;			}
float4	map_fix(float4 pos)					{ return pos + pos.wwww;			}
float4	platform_fix(float3 pos)			{ return float4(pos * float3(1,1,0.5) + float3(0,0,0.5), 1); }
float4	platform_fix(float4 pos)			{ return pos + pos.xyww;			}
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos + pos.wwzw;			}
float4	punch_pixel(float4 c)				{ return tint.a == 1 ? c / c.a : float4(c.rgb * tint.a, c.a); }

float4	PointSample(sampler s, float2 uv)							{ return tex2D(s, uv); }
float4	PointSample(sampler s, float2 uv, float2 offset)			{ return PointSample(s, uv + offset * inv_tex_size); }
float4	PointSample(sampler s, float2 uv, float offx, float offy)	{ return PointSample(s, uv, float2(offx, offy)); }

float GetDepth(sampler s, float2 uv) {
	return dot(round(tex2D(s, uv).wxy * 255), float3(65536.0/16777215.0, 256.0/16777215.0, 1.0/16777215.0));
}
float GetDepth(sampler s, float2 uv, float2 offset)	{ return GetDepth(s, uv + offset * inv_tex_size); }

float3 VS_texARRAY(float3 t) {
	float	f = frac(t.z);
	return float3(t.x, t.y + t.z - f, f);
}
float4 PS_texARRAY(sampler s, float3 t) {
	float	fw	= t.z;
	t.yz		= (float(t.y) + float2(0, 1)) * layer_scaler;
	return lerp(tex2D(s, t.xy), tex2D(s, t.xz), fw);
}

#elif defined(PLAT_PS4)
//------------------------------------
//	PS4
//------------------------------------
SamplerState	point_sampler : register(s8) {	// 'built in'
	FILTER_MIN_MAG_MIP_POINT;
	ADDRESSU	= CLAMP;
	ADDRESSV	= CLAMP;
};

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5;			}
float3	map_fix(float3 pos)					{ return pos * 0.5 + 0.5;			}
float4	map_fix(float4 pos)					{ return pos + pos.wwww;			}
float4	platform_fix(float3 pos)			{ return float4(pos * float3(1,1,0.5) + float3(0,0,0.5), 1); }
float4	platform_fix(float4 pos)			{ return pos + pos.xyww;			}
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos + pos.wwzw;			}
float4	punch_pixel(float4 c)				{ return c; }

float4	PointSample(sampler2D s, float2 uv)							{ return s.t.Sample(point_sampler, uv); }
float4	PointSample(sampler2D s, float2 uv, int2 offset)			{ return s.t.Sample(point_sampler, uv, offset); }
float4	PointSample(sampler2D s, float2 uv, int offx, int offy)		{ return s.t.Sample(point_sampler, uv, int2(offx, offy)); }

float	GetDepth(sampler2D s, float2 uv)							{ return s.t.Sample(point_sampler, uv).x; }
float	GetDepth(sampler2D s, float2 uv, int2 offset)				{ return s.t.Sample(point_sampler, uv, offset).x; }

float3	VS_texARRAY(float3 t)										{ return t; }
float4	PS_texARRAY(sampler2DArray s, float3 t)						{ return s.t.Sample(s.s, t); }

#elif defined(PLAT_WII)
//------------------------------------
//	Wii specific
//------------------------------------
float2 inv_tex_size;

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5;		}
float3	map_fix(float3 pos)					{ return pos * 0.5 + 0.5;		}
float4	map_fix(float4 pos)					{ return pos * 0.5 + 0.5;		}
float4	platform_fix(float3 pos)			{ return float4(pos, 1);		}
float4	platform_fix(float4 pos)			{ return pos;					}
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos;					}
float4	punch_pixel(float4 c)				{ return c;						}

float	PointSample(sampler s, float2 uv)							{ return tex2D(s, uv);			}
float4	PointSample(sampler s, float2 uv, float2 offset)			{ return tex2D(s, uv + offset * inv_tex_size); }
float4	PointSample(sampler s, float2 uv, float offx, float offy)	{ return PointSample(s, uv, float2(offx, offy)); }

float	GetDepth(sampler s, float2 uv)					{ return tex2D(s, uv).x; }
float	GetDepth(sampler s, float2 uv, float2 offset)	{ return GetDepth(s, uv + offset * inv_tex_size); }

float3 VS_texARRAY(float3 t) {
	return t;
}
float4 PS_texARRAY(sampler s, float3 t) {
	float	fw	= t.z;
	t.yz		= (float(t.y) + float2(0, 1)) * layer_scaler;
	return lerp(tex2D(s, t.xy), tex2D(s, t.xz), fw);
}

#elif defined(PLAT_IOS)
//------------------------------------
//	IOS specific
//------------------------------------
float2	inv_tex_size;

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5;			}
float3	map_fix(float3 pos)					{ return pos * 0.5 + 0.5;			}
float4	map_fix(float4 pos)					{ return pos + pos.wwww;			}
float4	platform_fix(float3 pos)			{ return float4(pos, 1);			}
float4	platform_fix(float4 pos)			{ return pos;						}
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,0.5,0.5) + float3(0.5,0.5,0.5); }
float4	platform_to_map(float4 pos)			{ return pos + pos.wwww;			}
float4	punch_pixel(float4 c)				{ return c;							}

float4	PointSample(sampler s, highp float2 uv)							{ return tex2D(s, uv); }
float4	PointSample(sampler s, highp float2 uv, highp float2 offset)	{ return tex2D(s, uv + offset * inv_tex_size); }
float4	PointSample(sampler s, float2 uv, float offx, float offy)		{ return PointSample(s, uv, float2(offx, offy)); }

float	GetDepth(sampler s, float2 uv)						{ return tex2D(s, uv).x; }
float	GetDepth(sampler s, float2 uv, float2 offset)		{ return GetDepth(s, uv + offset * inv_tex_size); }
float	TestDepth(sampler2DShadow s, float3 uvz)			{ return shadow2D(s, uvz); }
float	TestDepth(sampler2DShadow s, float2 uv, float z)	{ return shadow2D(s, float3(uv, z)); }

float3 VS_texARRAY(float3 t) {
	float	f = frac(t.z);
	return float3(t.x, t.y + t.z - f, f);
}
float4 PS_texARRAY(sampler s, highp float3 t) {
	float	fw	= t.z;
	t.yz		= (float(t.y) + float2(0, 1)) * layer_scaler;
	return lerp(tex2D(s, t.xy), tex2D(s, t.xz), fw);
}

#elif defined(USE_DX11)
//------------------------------------
//	DX11 / xbox ONE
//------------------------------------
float2	inv_tex_size;

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5; }
float3	map_fix(float3 pos)					{ return pos * float3(0.5, 0.5, -0.5) + 0.5; }
float4	map_fix(float4 pos)					{ float4 t = pos * float4(1,+1,-1,1); return t + t.wwww; }
float4	platform_fix(float3 pos)			{ return float4(pos * float3(1,-1,-0.5) + float3(0,0,1), 1); }
float4	platform_fix(float4 pos)			{ float4 t = pos * float4(1,-1,-1,1); return t + t.xyww; }
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos * float4(1,-1,1,1) + pos.wwzw; }
float4	punch_pixel(float4 c)				{ return c; }

float4	PointSample(sampler2D s, float2 uv)							{ return tex2D(s, uv); }
float4	PointSample(sampler2D s, float2 uv, float2 offset)			{ return tex2D(s, uv + offset * inv_tex_size); }
float4	PointSample(sampler2D s, float2 uv, float offx, float offy)	{ return PointSample(s, uv, float2(offx, offy)); }

float	GetDepth(sampler2D s, float2 uv)							{ return tex2D(s, uv).x; }
float	GetDepth(sampler2D s, float2 uv, float2 offset)				{ return GetDepth(s, uv + offset * inv_tex_size); }

float3	VS_texARRAY(float3 t)										{ return t; }
float4	PS_texARRAY(sampler2DArray s, float3 t)						{ return s.t.Sample(s.s, t); }

#else

//------------------------------------
//	PC / generic
//------------------------------------
float2	inv_tex_size;

float2	map_fix(float2 pos)					{ return pos * 0.5 + 0.5; }
float3	map_fix(float3 pos)					{ return pos * 0.5 + 0.5; }
float4	map_fix(float4 pos)					{ float4 t = pos * float4(1,+1,-1,1); return t + t.wwww; }
//float4	platform_fix(float3 pos)		{ return float4(pos * float3(1,-1,-0.5) + float3(0,0,1), 1); }
//float4	platform_fix(float4 pos)		{ float4 t = pos * float4(1,-1,-1,1); return t + t.xyww; }
float4	platform_fix(float3 pos)			{ return float4(pos * float3(1,-1,0.5) + float3(0,0,0.5), 1); }
float4	platform_fix(float4 pos)			{ float4 t = pos * float4(1,-1,1,1); return t + t.xyww; }
float3	platform_to_map(float3 pos)			{ return pos * float3(0.5,-0.5,1) + float3(0.5,0.5,0); }
float4	platform_to_map(float4 pos)			{ return pos * float4(1,-1,1,1) + pos.wwzw; }
float4	punch_pixel(float4 c)				{ return c; }

float4	PointSample(sampler2D s, float2 uv)							{ return tex2D(s, uv); }
float4	PointSample(sampler2D s, float2 uv, float2 offset)			{ return tex2D(s, uv + offset * inv_tex_size); }
float4	PointSample(sampler2D s, float2 uv, float offx, float offy)	{ return PointSample(s, uv, float2(offx, offy)); }

float	GetDepth(sampler2D s, float2 uv)							{ return tex2D(s, uv).x; }
float	GetDepth(sampler2D s, float2 uv, float2 offset)				{ return GetDepth(s, uv + offset * inv_tex_size); }

float3	VS_texARRAY(float3 t) {
	return t;
}
float4	PS_texARRAY(sampler2D s, float3 t) {
	float	w	= t.z;
	float	fw	= frac(w);
	t.y = (t.y + w - fw) * layer_scaler;
	return lerp(tex2D(s, t.xy), tex2D(s, t.xy + float2(0, layer_scaler)), fw);
}

#endif

//------------------------------------
//
//------------------------------------

highp float4	bilinear_offsets(highp float2 x) {
	float2	p	= 0.5 / x;
	return float4(-p, +p);
}
highp float4	bilinear_weights(highp float2 x) {
	float2	f = frac(x - .5);
	float4	a = float4(f, 1 - f);
	return a.zxzx * a.wwyy;
}
float4	bilinear_read(highp sampler2D s, highp float2 uv, float2 size) {
	float4	o	= bilinear_offsets(size);
	float4	w	= bilinear_weights(uv * size);
	return	PointSample(s, uv + o.xy) * w.x
		+	PointSample(s, uv + o.zy) * w.y
		+	PointSample(s, uv + o.xw) * w.z
		+	PointSample(s, uv + o.zw) * w.w;
}
float	bilinear_read1(sampler2D s, highp float2 uv, float2 size) {
	float4	o	= bilinear_offsets(size);
	return dot(bilinear_weights(uv * size), float4(
		PointSample(s, uv + o.xy).x,
		PointSample(s, uv + o.zy).x,
		PointSample(s, uv + o.xw).x,
		PointSample(s, uv + o.zw).x
	));
}

#ifdef _3DSMAX_
float	ZBToZ(float z) 	{ return projection[3][2] / (z - projection[2][2]); }
float	ZToZB(float z)	{ return projection[3][2] / z + projection[2][2];  }
#else
float	ZBToZ(float z) 	{ return zbconv.y / (z - zbconv.x); }
float	ZToZB(float z)	{ return zbconv.y / z + zbconv.x;  }
#endif

float	GetDepth2(sampler2D s, float2 uv)	{ return ZBToZ(GetDepth(s, uv)); }
float4	VS_texARRAY(float4 t)				{ return float4(VS_texARRAY(t.xyz), t.w); }

#endif// COMMON_FXH
]]>
            </fileSource>
        </file>
        <file userSpecifiedFileName="D:\dev\shared\assets\shaders/lighting.fxh" absoluteFileName="D:\dev\shared\assets\shaders\lighting.fxh" fileID="1" primary="0">
            <fileInfo creationTime="2014-09-28T01:26:57Z" modificationTime="2015-04-23T07:18:38Z"/>
            <includeReference refFileID="2" refLineNumber="2" includeText="&quot;lighting.fxh&quot;"/>
            <fileSource>
                <![CDATA[#ifndef LIGHTING_FXH
#define LIGHTING_FXH

#include "common.fxh"

//------------------------------------
//	defines
//------------------------------------

#define HALF_ANGLE

#ifndef PLAT_IOS
#define DYNAMIC_LIGHTS	2
#endif

//------------------------------------
//	uniform variables
//------------------------------------

float4	fog_dir1;
float4	fog_col1;
float4	diffuse_irradiance[9] = {
	float4(0,0,0,0),
	float4(0,0,0,0),
	float4(0,0,0,0),
	float4(0.25f,0.25f,0.25f,1),
	float4(0.25f,0.25f,0.25f,1),
	float4(0.25f,0.25f,0.25f,1),
	float4(0,0,0,0),
	float4(0,0,0,0),
	float4(0,0,0,0)
};
float4	light_ambient		= {0.25,0.25,0.25,1};

#ifdef DYNAMIC_LIGHTS
struct Light {
	float4	pos;
	float4	col;
};
Light		lights[DYNAMIC_LIGHTS];
#if defined(PLAT_PS3) || defined(PLAT_IOS)
static const int num_lights = DYNAMIC_LIGHTS;
#else
int num_lights;
#endif
#endif

float3	shadowlight_dir UNIFORM_SEMANTIC(DIRECTION) <
	string UIName = "Light Direction";
	string Object = "TargetLight";
>;
float3	shadowlight_col UNIFORM_SEMANTIC(LIGHTCOLOR) <
	int	LightRef = 0;
>;

#ifdef PLAT_WII
//------------------------------------
//	Wii only
//------------------------------------
sampler_def2D(_fakespec )
	FILTER_MIN_MAG_MIP_LINEAR;
	ADDRESSU		= CLAMP;
	ADDRESSV		= CLAMP;
};
float	VSFog(float3 pos)					{ return 1;			}
float3	Fog(float3 colour, float fog)		{ return colour;	}
float4	Fog(float4 colour, float fog)		{ return colour;	}
float3	Fog(float3 colour, float3 pos)		{ return colour;	}
float4	Fog(float4 colour, float3 pos)		{ return colour;	}
#else
//------------------------------------
//	Not Wii
//------------------------------------
float	VSFog(float3 pos)					{ return dot(pos, fog_dir1.xyz) + fog_dir1.w; }
float3	Fog(float3 colour, float fog)		{ return lerp(colour, fog_col1.rgb, saturate(fog) * fog_col1.a); }
float4	Fog(float4 colour, float fog)		{ return float4(lerp(colour.rgb, fog_col1.rgb, saturate(fog) * fog_col1.a), colour.a); }
float3	Fog(float3 colour, float3 pos)		{ return lerp(colour, fog_col1.rgb, saturate(dot(pos, fog_dir1.xyz) + fog_dir1.w) * fog_col1.a); }
float4	Fog(float4 colour, float3 pos)		{ return float4(Fog(colour.rgb, pos), colour.a); }
#endif

//------------------------------------
//	Lighting functions
//------------------------------------

float4 DiffuseIrradiance(float3 n) {
	float3 n2	= n * n;
	float3 n3	= n * n.yzx;
	return float4(
		diffuse_irradiance[0].rgb * n.x +
		diffuse_irradiance[1].rgb * n.y +
		diffuse_irradiance[2].rgb * n.z +
		diffuse_irradiance[3].rgb * n2.x +
		diffuse_irradiance[4].rgb * n2.y +
		diffuse_irradiance[5].rgb * n2.z +
		diffuse_irradiance[6].rgb * n3.x +
		diffuse_irradiance[7].rgb * n3.y +
		diffuse_irradiance[8].rgb * n3.z,
		tint.a
	);
}

float4 DiffuseIrradiance4(float3 n) {
	float3 n2	= n * n;
	float3 n3	= n * n.yzx;
	return
		diffuse_irradiance[0] * n.x +
		diffuse_irradiance[1] * n.y +
		diffuse_irradiance[2] * n.z +
		diffuse_irradiance[3] * n2.x +
		diffuse_irradiance[4] * n2.y +
		diffuse_irradiance[5] * n2.z +
		diffuse_irradiance[6] * n3.x +
		diffuse_irradiance[7] * n3.y +
		diffuse_irradiance[8] * n3.z;
}

float3 ReflectionCalc(float3 norm, float3 eye) {
	return eye - dot(norm, eye) * norm * 2;
}
float DiffuseCalc(float3 light, float3 norm) {
	return saturate(dot(norm, light));
}
float SpecularCalc(float3 light, float3 norm, float3 eye, float glossiness) {
#ifdef HALF_ANGLE
	float	t = dot(norm, normalise(light - eye));
#else
	float	t = dot(ReflectionCalc(norm, eye), light);
#endif
	return t > 0 ? pow(t, glossiness) : 0;
}

float2 CalcLight(float4 light, float3 p, float3 norm, float3 eye, float glossiness) {
	float3	i	= light.xyz - p * light.w;
	float	i2	= dot(i, i);
	float3	iu	= i * rsqrt(i2);
	return float2(DiffuseCalc(iu, norm), SpecularCalc(iu, norm, eye, glossiness)) * saturate(1 / (i2 + 1) - 0.05);
}

#ifdef DYNAMIC_LIGHTS
void DynamicLights(float3 pos, float3 norm, float3 eye, float glossiness, inout float3 diffuse, inout float3 specular) {
	for (int j = 0; j < num_lights; j++) {
#ifdef PLAT_PS3
		[branch]
		if (lights[j].col.a != 0)
#endif
		{
			float2	l0	= CalcLight(lights[j].pos, pos, norm, eye, glossiness);
			diffuse		+= l0.x * lights[j].col.rgb;
			specular	+= l0.y * lights[j].col.rgb;
		}
	}
}
#else
void DynamicLights(float3 pos, float3 norm, float3 eye, float glossiness, float3 diffuse, float3 specular) {}
#endif

//------------------------------------
//	Pixel shader lighting
//------------------------------------

float4 SpecularLight(float3 pos, float3 norm, float4 colour, float4 ambient, float glossiness, float mask, float shadow) {
#ifdef PLAT_WII
	float3	diffuse		= shadow;
	return Blend(float4(colour.xyz * diffuse, colour.a));
#else
	float3	diffuse		= DiffuseCalc(shadowlight_dir, norm) * shadow * shadowlight_col + ambient.rgb;
	float3	eye			= normalise(pos - iview[3].xyz);
	float3	specular	= SpecularCalc(shadowlight_dir, norm, eye, glossiness) * shadowlight_col * shadow;

	DynamicLights(pos, norm, eye, glossiness, diffuse, specular);

	float	alpha		= colour.a * ambient.a;
	return float4(
		diffuse * colour.rgb * alpha
	+	specular * mask * ambient.a
	,	alpha);
#endif
}

float4 FogSpecularLight(float3 pos, float3 norm, float4 colour, float4 ambient, float glossiness, float3 mask, float shadow, float fog) {
#ifdef PLAT_WII
	float3	diffuse		= ambient.rgb;
	float	alpha		= colour.a;// * ambient.a;
#if 0
	float4	reflection	= tex2D(_fakespec, norm.xy * 0.5 + 0.5);
	float3	specular	= reflection.rgb * mask * reflection.a;
	return float4(saturate(diffuse * colour.rgb + specular), alpha);
#else
	return float4(saturate(diffuse * colour.rgb), alpha);
#endif
#else
	float3	diffuse		= DiffuseCalc(shadowlight_dir, norm) * shadow * shadowlight_col + ambient.rgb;
	float3	eye			= normalise(pos - iview[3].xyz);
	float3	specular	= SpecularCalc(shadowlight_dir, norm, eye, glossiness) * shadowlight_col * (shadow + 0.25) / 1.25;

	DynamicLights(pos, norm, eye, glossiness, diffuse, specular);

	float	foga	= saturate(fog) * fog_col1.a; // this part was moved from the VS to the PS to make it perspective-correct
	float	alpha	= colour.a * ambient.a;

	return float4(
		lerp(diffuse * colour.rgb, fog_col1.rgb, foga) * alpha
	+	specular * mask * (1 - foga) * ambient.a
	,	alpha);
#endif
}

float4 FogReflectionLight(samplerCUBE env, float3 pos, float3 norm, float4 colour, float4 ambient, float glossiness, float3 mask, float shadow, float fog) {
#ifdef PLAT_WII
	float3	diffuse		= ambient.rgb;
	float3	reflection	= tex2D(env, norm.xy * 0.5 + 0.5).rgb;
	float	alpha		= colour.a;// * ambient.a;
	return float4(saturate(diffuse * colour.rgb + reflection * mask), alpha);
#else
	float3	eye			= normalise(pos - iview[3].xyz);
	float3	reflection	= texCUBE(env, ReflectionCalc(norm, eye).xzy).rgb;
	float3	diffuse		= DiffuseCalc(shadowlight_dir, norm) * shadow * shadowlight_col + ambient.rgb;
	float3	specular	= 0;

	DynamicLights(pos, norm, eye, glossiness, diffuse, specular);

	float	foga		= saturate(fog) * fog_col1.a; // this part was moved from the VS to the PS to make it perspective-correct
	float	alpha		= colour.a * ambient.a;
	return float4(
		lerp(diffuse * colour.rgb, fog_col1.rgb, foga) * alpha
	+	(specular + reflection) * mask * (1 - foga) * ambient.a
	,	alpha);
#endif
}

float4 FogSpecularReflectionLight(samplerCUBE env, float3 pos, float3 norm, float4 colour, float4 ambient, float glossiness, float3 mask, float shadow, float fog, float spec_refl_selector) {
#ifdef PLAT_WII
	float3	diffuse		= ambient.rgb;
	float4	reflection	= tex2D(env, norm.xy * 0.5 + 0.5);
	float3	specular	= reflection.rgb * mask * reflection.a;

	specular = lerp(specular, reflection.rgb, spec_refl_selector);
	float	alpha		= colour.a;// * ambient.a;
	return float4(saturate(diffuse * colour.rgb + specular), alpha);
#else
	float3	eye			= normalise(pos - iview[3].xyz);
	float3	specular	= SpecularCalc(shadowlight_dir, norm, eye, glossiness) * shadowlight_col * (shadow + 0.25) / 1.25;
	float3	reflection	= texCUBE(env, ReflectionCalc(norm, eye).xzy).rgb;

	specular = lerp(specular, reflection, spec_refl_selector);

	float3	diffuse		= DiffuseCalc(shadowlight_dir, norm) * shadow * shadowlight_col + ambient.rgb;

	DynamicLights(pos, norm, eye, glossiness, diffuse, specular);

	float	alpha		= colour.a * ambient.a;
	float	foga		= saturate(fog) * fog_col1.a; // this part was moved from the VS to the PS to make it perspective-correct
	return float4(
		lerp(diffuse * colour.rgb, fog_col1.rgb, foga) * alpha
	+	specular * mask * (1 - foga) * ambient.a
	,	alpha);
#endif
}

float4 DiffuseLight(float3 pos, float3 norm, float4 colour, float4 ambient, float shadow) {
#if defined(PLAT_WII)
	return (ambient + float4(light_ambient.xyz, 0)) * colour;
#else
	float3	diffuse		= DiffuseCalc(shadowlight_dir, norm) * shadowlight_col * shadow + ambient.rgb;
#ifdef DYNAMIC_LIGHTS
	for (int j = 0; j < num_lights; j++) {
 #ifdef PLAT_PS3
		[branch]
		if (lights[j].col.a != 0)
 #endif
		{
			float3	i	= lights[j].pos.xyz - pos * lights[j].pos.w;
			float	i2	= dot(i, i);
			float	l0	= DiffuseCalc(i * rsqrt(i2), norm) * saturate(1 / (i2 + 1) - 0.05);
			diffuse += l0 * lights[j].col.rgb;
		}
	}
#endif
	return float4(diffuse, ambient.a) * colour;
#endif
}

//------------------------------------
//	Vertex shader lighting
//------------------------------------

float4 DiffuseLight(float3 pos, float3 norm) {
#ifdef _3DSMAX_
	return float4(DiffuseCalc(shadowlight_dir, norm) * shadowlight_col, 1);
#elif defined(PLAT_WII)
	return GXLighting(pos, norm, GX_DF_CLAMP, GX_AF_SPOT);
#else
	return DiffuseIrradiance(norm);
#endif
}

#endif// LIGHTING_FXH
]]>
            </fileSource>
        </file>
        <file userSpecifiedFileName="D:\dev\shared\assets\shaders/shadow.fxh" absoluteFileName="D:\dev\shared\assets\shaders\shadow.fxh" fileID="6" primary="0">
            <fileInfo creationTime="2014-07-21T09:48:29Z" modificationTime="2015-04-15T07:08:35Z"/>
            <includeReference refFileID="2" refLineNumber="3" includeText="&quot;shadow.fxh&quot;"/>
            <fileSource>
                <![CDATA[#ifndef SHADOW_FXH
#define SHADOW_FXH

#define USE_SHADOWS
#define HAS_SHADOWTEXTURES

#if defined(_3DSMAX_) || !defined(USE_SHADOWS)

#define SHADOW_VO
#define SHADOW_VS(v,p)	
#define GETSHADOW(v)	1

#elif defined(PLAT_IOS)
//-----------------------------------------------------------------------------
//	ios
//-----------------------------------------------------------------------------

#ifdef HAS_SHADOWTEXTURES
sampler2DShadow	_shadow_global_map;
sampler2DShadow	_shadow_nearfar_map;
#else
sampler2D		_shadow_global_map;
sampler2D		_shadow_nearfar_map;
#endif

Matrix	shadow_global_proj;
highp float4	shadow_nearfar_mult;
highp float4	shadow_nearfar_add;

#if 0
struct ShadowCoord {
	highp float3	n : SHADOWCOORD_N;
	highp float3	f : SHADOWCOORD_F;
	highp float3	g : SHADOWCOORD_G;
};

ShadowCoord CalcShadowCoord(float3 p) {
	ShadowCoord	s;
	s.g	= mul(float4(p, 1), shadow_global_proj).xyz;
	float4	t	= s.g.xyxy * shadow_nearfar_mult + shadow_nearfar_add;
	t.xz		= (t.xz + float2(0, 1)) * 0.5;
	s.n	= float3(t.xy, s.g.z);
	s.f	= float3(t.zw, s.g.z);
	return s;
}

#define SHADOW_VO		ShadowCoord	shadow_coord;
#define SHADOW_VS(v,p)	v.shadow_coord = CalcShadowCoord(p);
#define GETSHADOW(v)	GetShadow(v.shadow_coord)

float GetShadow(ShadowCoord s) {
	float4  radial	= step(abs(float4(s.n.xy, s.f.xy) - float4(0.25, 0.5, 0.75, 0.5)), float4(0.25, 0.5, 0.25, 0.5));	//abs(uv01 - 0.5) <= 0.5
	float2	blend	= radial.xz * radial.yw;	

	return	min(
		1 + (shadow2D(_shadow_nearfar_map, s.n) - 1) * blend.x,
		shadow2D(_shadow_global_map, s.g)
	);
}

#else

#define SHADOW_VO		highp float3	shadow_uv : SHADOWCOORD;
#define SHADOW_VS(v,p)	v.shadow_uv = mul(float4(p, 1), shadow_global_proj).xyz;
#define GETSHADOW(v)	GetShadow(v.shadow_uv)

#ifdef HAS_SHADOWTEXTURES
float GetShadow(float3 uv) { return	shadow2D(_shadow_global_map, uv); }
#else
float GetShadow(float3 uv) { return	step(uv.z, tex2D(_shadow_global_map, uv.xy).x); }
#endif

#endif

#elif defined(PLAT_WII)
//-----------------------------------------------------------------------------
//	wii
//-----------------------------------------------------------------------------

#define SHADOW_VO
#define SHADOW_VS(v,p)	
#define GETSHADOW(v)	GetShadow(v.worldpos.xyz)

sampler				_shadow_global_map;
sampler				_shadow_nearfar_map;
row_major float4x3	shadow_global_proj;
row_major float4x3	shadow_near_proj;

float GetShadow(float3 v) {
	float	s1		= tex2D(_shadowmap1, mul(float4(v.xyz, 1), shadow_near_proj).xy).x;
	float	sg		= tex2D(_shadowmapg, mul(float4(v.xyz, 1), shadow_global_proj).xy).x;
	return	s1 * sg;
}

#else
//-----------------------------------------------------------------------------
//	other platforms
//-----------------------------------------------------------------------------

#define SHADOW_VO
#define SHADOW_VS(v,p)	
#define GETSHADOW(v)	GetShadow(v.worldpos.xyz)

#if defined(USE_DX11)
Texture2D<float>	_shadow_global_map_;
Texture2D<float2>	_shadow_nearfar_map_;
#endif

sampler_def2D(_shadow_global_map,
	FILTER_MIN_MAG_MIP_LINEAR;
	ADDRESSU	= CLAMP;
	ADDRESSV	= CLAMP;
	MAXANISOTROPY = 4;
);

sampler_def2D(_shadow_nearfar_map,
	FILTER_MIN_MAG_LINEAR_MIP_POINT;
	ADDRESSU	= CLAMP;
	ADDRESSV	= CLAMP;
);

Matrix		shadow_global_proj;
float4		shadow_nearfar_mult;
float4		shadow_nearfar_add;
float3		shadow_expscale;
float4		shadow_blend;

#if defined(PLAT_PS3) // Convert between R16G16 and A8R8G8B8
float4	EncodeRG16(float2 val)	{ return unpack_4ubyte(pack_2ushort(val)); } // convert 2 halves, which represent R16G16 data, into 4 halves, which represent R8G8B8A8 data
float2	DecodeRG16(float2 val)	{ return val; }
#elif defined(PLAT_X360) // Convert between R16G16 [-32,32] and [0, 1]
float4	EncodeRG16(float2 val)	{ return float4(val * 64 - 32, 0, 0); }
float2	DecodeRG16(float2 val)	{ return val / 64 + .5; }
#else
float4	EncodeRG16(float2 val)	{ return float4(val, 0, 0); }
float2	DecodeRG16(float2 val)	{ return val; }
#endif

float GetShadow(float3 v) {
	float3	uvg		= mul(float4(v, 1), shadow_global_proj).xyz;
	float4	uv01	= uvg.xyxy * shadow_nearfar_mult + shadow_nearfar_add;
	float4  radial	= saturate(abs(uv01 * 2 - 1));
	float2	blend	= saturate(max(radial.xz, radial.yw) * shadow_blend.xz + shadow_blend.yw);
	float3	sz		= float3(
		tex2D(_shadow_nearfar_map,	uv01.xy).r,
		tex2D(_shadow_nearfar_map,	uv01.zw).g,
		tex2D(_shadow_global_map,	uvg.xy).x
	);
	sz.xy  = DecodeRG16(sz.xy);

	float3	e	= min(0, shadow_expscale * (uvg.z - sz));
	float	e2	= lerp(lerp(e.z, e.y, blend.y), e.x, blend.x);
	return saturate(exp(e2));
}

#endif

#endif	//SHADOW_FXH
]]>
            </fileSource>
        </file>
    </allFiles>
    <compilerDiagnostics>
        <diagnostic type="warning" string="parameter &apos;pos&apos; is unreferenced" fileID="1" line="287" diagID="5203" includeDirectiveStack="D:\dev\shared\assets\shaders/lighting.fxh(2,10) : In file included at D:\dev\shared\assets\shaders/lighting.fxh(2,10)
        "/>
        <diagnostic type="warning" string="implicit cast from &apos;row_major float4x4&apos; to &apos;column_major float4x4&apos;" fileID="2" line="92" diagID="5202"/>
        <diagnostic type="note" string="function &apos;cofactors&apos; that caused the implict cast was declared here" fileID="3" line="511" diagID="5005" includeDirectiveStack="D:\dev\shared\assets\shaders/common.fxh(1,10) : In file included at D:\dev\shared\assets\shaders/common.fxh(1,10)
        "/>
        <diagnostic type="warning" string="implicit cast from &apos;row_major float4x4&apos; to &apos;column_major float4x4&apos;" fileID="2" line="101" diagID="5202"/>
        <diagnostic type="note" string="function &apos;inverse_transpose&apos; that caused the implict cast was declared here" fileID="3" line="530" diagID="5005" includeDirectiveStack="D:\dev\shared\assets\shaders/common.fxh(1,10) : In file included at D:\dev\shared\assets\shaders/common.fxh(1,10)
        "/>
        <diagnostic type="warning" string="parameter &apos;id&apos; is unreferenced" fileID="2" line="768" diagID="5203"/>
        <diagnostic type="warning" string="parameter &apos;id&apos; is unreferenced" fileID="2" line="780" diagID="5203"/>
        <diagnostic type="warning" string="parameter &apos;i&apos; is unreferenced" fileID="2" line="780" diagID="5203"/>
        <diagnostic type="warning" string="parameter &apos;cc&apos; is unreferenced" fileID="2" line="786" diagID="5203"/>
    </compilerDiagnostics>
    <usertypelayouts>
        <struct structID="0" name="__CB0____GLOBAL_CB__" size="64">
            <member type="float4x4" isRowMajor="1" name="worldViewProj" size="64"/>
        </struct>
    </usertypelayouts>
    <resourceInfo>
        <constantbuffer symbolName="__GLOBAL_CB__" cbUnit="0" containedStructID="0"/>
        <attribute symbolName="pos" semantic="implicit" semanticName="POSITION" semanticIndex="0" resourceIndex="0" leafFormat="fp32:3" declID="561"/>
        <VSOutput symbolName="VS_thickpoint.pos" semantic="implicit" semanticName="POSITION" semanticIndex="0" resourceIndex="0" leafFormat="fp32:4" declID="560"/>
    </resourceInfo>
    <activeLines>
        <fileAndLine fileID="2" lineNumber="5"/>
        <fileAndLine fileID="2" lineNumber="6"/>
        <fileAndLine fileID="2" lineNumber="8"/>
        <fileAndLine fileID="2" lineNumber="14"/>
        <fileAndLine fileID="2" lineNumber="20"/>
        <fileAndLine fileID="2" lineNumber="33"/>
        <fileAndLine fileID="2" lineNumber="34"/>
        <fileAndLine fileID="2" lineNumber="35"/>
        <fileAndLine fileID="2" lineNumber="36"/>
        <fileAndLine fileID="2" lineNumber="544"/>
        <fileAndLine fileID="2" lineNumber="568"/>
        <fileAndLine fileID="2" lineNumber="569"/>
        <fileAndLine fileID="2" lineNumber="570"/>
        <fileAndLine fileID="2" lineNumber="571"/>
        <fileAndLine fileID="3" lineNumber="212"/>
        <fileAndLine fileID="3" lineNumber="213"/>
        <fileAndLine fileID="3" lineNumber="217"/>
        <fileAndLine fileID="3" lineNumber="218"/>
        <fileAndLine fileID="3" lineNumber="425"/>
        <fileAndLine fileID="3" lineNumber="426"/>
        <fileAndLine fileID="3" lineNumber="427"/>
        <fileAndLine fileID="3" lineNumber="428"/>
        <fileAndLine fileID="3" lineNumber="429"/>
        <fileAndLine fileID="3" lineNumber="430"/>
        <fileAndLine fileID="3" lineNumber="431"/>
        <fileAndLine fileID="3" lineNumber="432"/>
        <fileAndLine fileID="3" lineNumber="434"/>
        <fileAndLine fileID="3" lineNumber="439"/>
        <fileAndLine fileID="3" lineNumber="447"/>
        <fileAndLine fileID="3" lineNumber="448"/>
        <fileAndLine fileID="3" lineNumber="454"/>
        <fileAndLine fileID="3" lineNumber="455"/>
        <fileAndLine fileID="3" lineNumber="456"/>
        <fileAndLine fileID="3" lineNumber="457"/>
        <fileAndLine fileID="3" lineNumber="458"/>
        <fileAndLine fileID="3" lineNumber="464"/>
        <fileAndLine fileID="3" lineNumber="470"/>
        <fileAndLine fileID="3" lineNumber="765"/>
        <fileAndLine fileID="1" lineNumber="20"/>
        <fileAndLine fileID="1" lineNumber="21"/>
        <fileAndLine fileID="1" lineNumber="22"/>
        <fileAndLine fileID="1" lineNumber="23"/>
        <fileAndLine fileID="1" lineNumber="24"/>
        <fileAndLine fileID="1" lineNumber="25"/>
        <fileAndLine fileID="1" lineNumber="26"/>
        <fileAndLine fileID="1" lineNumber="27"/>
        <fileAndLine fileID="1" lineNumber="28"/>
        <fileAndLine fileID="1" lineNumber="29"/>
        <fileAndLine fileID="1" lineNumber="30"/>
        <fileAndLine fileID="1" lineNumber="31"/>
        <fileAndLine fileID="1" lineNumber="33"/>
        <fileAndLine fileID="1" lineNumber="40"/>
        <fileAndLine fileID="1" lineNumber="44"/>
        <fileAndLine fileID="1" lineNumber="48"/>
        <fileAndLine fileID="1" lineNumber="52"/>
        <fileAndLine fileID="6" lineNumber="109"/>
        <fileAndLine fileID="6" lineNumber="116"/>
        <fileAndLine fileID="6" lineNumber="122"/>
        <fileAndLine fileID="6" lineNumber="123"/>
        <fileAndLine fileID="6" lineNumber="124"/>
        <fileAndLine fileID="6" lineNumber="125"/>
        <fileAndLine fileID="6" lineNumber="126"/>
    </activeLines>
    <shaderbinaryheader size="36" encoding="base64">
        AAQrIkDuxtsQm/piAAEAASABAAABAAAAAAAAAAAAAAAAAAAA
    </shaderbinaryheader>
    <gnmxheader type="export" major="7" minor="2" size="52" encoding="base64">
        3AAABAAAAAA0AAAA/////wEBDAAYAAAAAQAAAAQAAAASAAAAFwACEBoABAACAAgAAAQDAA==
    </gnmxheader>
    <programs>
        <program progid="0" stage="es" size="220" offsetCodeEnd="128" offsetShaderBinaryInfo="192" encoding="base64">
            /wPrvhcAAAAAIYC+AAkIw38AjL8cAgB+CAWAwBgMAD4dAgJ+GQwCPh4CBH4UCgA+GgwEPh8CBn4VCgI+EAgAPhsMBj4WCgQ+EQgCPhcKBj4SCAQ+EwgGPn8AjL8AQHDg
            AABADARAcOAAAUAMCEBw4AACQAwMQHDgAANADAAAgb85ag4ABABqEAAMAM3oAQBrAAEAAJAAawIEAAARAAAAACAAAAASAAAAFwACEBoABAACAAgAAQAAAAEAAAArIgAA
            T3JiU2hkcgdLgAAAAwQUA0DuxtsQm/pihFsymA==
        </program>
    </programs>
    <builtintypelayouts>
        <type name="float4" size="16" align="4"/>
        <type name="float" size="4" align="4"/>
        <type name="float2" size="8" align="4"/>
        <type name="float3" size="12" align="4"/>
        <type name="row_major float4x4" size="64" align="4"/>
        <type name="int" size="4" align="4"/>
        <type name="bool" size="4" align="4"/>
        <type name="column_major float3x3" size="36" align="4"/>
        <type name="column_major float4x4" size="64" align="4"/>
        <type name="int2" size="8" align="4"/>
        <type name="int4" size="16" align="4"/>
        <type name="column_major float4x3" size="48" align="4"/>
        <type name="bool2" size="8" align="4"/>
    </builtintypelayouts>
</sdb>
